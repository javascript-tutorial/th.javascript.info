# Arrow functions ขั้นพื้นฐาน

มีการสร้างฟังก์ชันอีกรูปแบบหนึ่งที่ประโยคเรียบง่ายและกระชับกว่านิพจน์ฟังก์ชัน

มันเรียกว่า "Arrow function" เพราะมีรูปประโยคดังนี้:

```js
let func = (arg1, arg2, ..., argN) => expression;
```

จากตัวอย่างด้านบน คือสร้างฟังก์ชัน `func` ที่ยอมรับอาร์กิวเมนต์ `arg1..argN` จากนั้นจึงประเมิน expression ที่อยู่ทางด้านขวาแล้วส่งคืนผลลัพธ์

กล่าวอีกนัยหนึ่งก็คือ เวอร์ชันที่สั้นกว่าของ

```js
let func = function(arg1, arg2, ..., argN) {
  return expression;
};
```

มาดูตัวอย่างที่เป็นรูปธรรมกัน:

```js run
let sum = (a, b) => a + b;

/* Arrow function นี้เป็นรูปที่เขียนสั้นกว่าของ:

let sum = function(a, b) {
  return a + b;
};
*/

alert( sum(1, 2) ); // 3
```

<<<<<<< HEAD
อย่างที่เราเห็น `(a, b) => a + b` หมายถึงฟังก์ชันที่ยอมรับสองอาร์กิวเมนต์ชื่อ `a` และ `b` เมื่อดำเนินการ มันจะประเมินนิพจน์ `a + b` และส่งคืนผลลัพธ์
=======
As you can see, `(a, b) => a + b` means a function that accepts two arguments named `a` and `b`. Upon the execution, it evaluates the expression `a + b` and returns the result.
>>>>>>> 29216730a877be28d0a75a459676db6e7f5c4834

- หากเรารับอาร์กิวเมนต์เพียงตัวเดียว วงเล็บรอบพารามิเตอร์สามารถละเว้นได้ ซึ่งจะทำให้มันเขียนสั้นลงอีก

    ตัวอย่างเช่น:

    ```js run
    *!*
    let double = n => n * 2;
    // roughly the same as: let double = function(n) { return n * 2 }
    */!*

    alert( double(3) ); // 6
    ```

- หากไม่มีอาร์กิวเมนต์ จะเขียนวงเล็บเปล่าๆ (ควรมีวงเล็บเพื่อโปรแกรมจะได้รู้ว่านี่คือฟังก์ชั่น):

    ```js run
    let sayHi = () => alert("Hello!");

    sayHi();
    ```

Arrow functions เหมือนกันกับนิพจน์ฟังก์ชันทุกอย่าง (Function Expressions)

ตัวอย่างเช่น การสร้างฟังก์ชันแบบไดนามิก:

```js run
let age = prompt("What is your age?", 18);

let welcome = (age < 18) ?
  () => alert('Hello') :
  () => alert("Greetings!");

welcome();
```

Arrow functions อาจดูไม่คุ้นเคยและไม่ค่อยอ่านง่ายในตอนแรก แต่เมื่อเราทำงานกับมันเรื่อยๆก็จะคุ้นเคยกับพวกมันอย่างรวดเร็ว

หากเราขี้เกียจจะเขียนหลายบรรทัด Arrow functions สะดวกมากสำหรับการเขียนฟังก์ชั่นแบบบรรทัดเดียว 

## Arrow functions แบบหลายบรรทัด

ตัวอย่างข้างต้นใช้อาร์กิวเมนต์จากด้านซ้ายของ `=>` และประเมินนิพจน์ที่อยู่ด้านขวา

หากเราต้องการเขียนนิพจน์หรือคำสั่งหลายๆตัวใน Arrow function เราก็ทำได้เช่นกันเพียงแค่ ใส่ปีกกาเหมือนฟังก์ชั่นปกติ ดั่งตัวอย่างด้านล่าง

แบบนี้:

```js run
let sum = (a, b) => {  // ปีกกาเปิดเพื่อเขียนนิพจน์หรือคำสั่งหลายๆตัว
  let result = a + b;
*!*
<<<<<<< HEAD
  return result; // หากเราใส่ปีกกาอย่าลืมใส่ `return` ลงไปด้วยเพื่อส่งกลับผลลัพธ์ที่ได้ ไม่งั้นฟังก์ชั่นนี้จะส่ง `undefined` แทน
=======
  return result; // if we use curly braces, then we need an explicit "return"
>>>>>>> 29216730a877be28d0a75a459676db6e7f5c4834
*/!*
};

alert( sum(1, 2) ); // 3
```

```smart header="เพิ่มเติม"
เราอวย Arrow functions เพราะว่ามันทำให้การเขียนฟังก์ชั่นกระชับขึ้น แต่นั่นไม่ใช่เหตุผลทั้งหมด

Arrow functions ยังมีฟีเจอร์ที่น่าสนใจอื่นๆอีก

หากต้องการศึกษาเชิงลึก เราต้องทำความรู้จักกับจาวาสคริปต์ในด้านอื่นๆ ก่อน ดังนั้นเราค่อยจะกลับมาเจอกับ Arrow functions ใหม่ในบท <info:arrow-functions>

ในตอนนี้ เราก็สามารถใช้ Arrow functions เขียนฟังก์ชั่นบรรทัดเดียว รวมถึง ฟังก์ชันไว้เรียกทีหลัง (Callback function) ได้แล้ว 
```

## สรุป

Arrow functions สำหรับคนชอบความกระชับ สามารถเขียนได้สองแบบ:

1. ไม่มีปีกกา: `(...args) => expression` -- ด้านขวาคือนิพจน์: ฟังก์ชันจะประเมินและส่งคืนผลลัพธ์ทันที
2. มีปีกกา: `(...args) => { body }` -- ช่วยให้เราสามารถเขียนหลายคำสั่งภายในฟังก์ชัน แต่เราจำเป็นต้องมี `return` เพื่อส่งผลลัพธ์กลับไป
