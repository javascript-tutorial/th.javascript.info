## ตัวดำเนินการตรรกะ

JavaScript มีตัวดำเนินการตรรกะ 4 ตัว ได้แก่ `||` (OR), `&&` (AND), `!` (NOT), และ `??` (Nullish Coalescing) ที่นี่เราจะครอบคลุม 3 ตัวแรก ตัวดำเนินการ `??` อยู่ในบทความถัดไป

แม้ว่าจะเรียกว่า "ตรรกะ" แต่ก็สามารถนำไปใช้กับค่าทุกประเภท ไม่ใช่แค่แบบบูลีน ผลลัพธ์ของพวกมันก็สามารถเป็นประเภทใดก็ได้

มาดูรายละเอียดกัน

## || (OR)

ตัวดำเนินการ "OR" แสดงด้วยเครื่องหมายเส้นแนวตั้งสองอัน:

```js
result = a || b;
```

ในการเขียนโปรแกรมแบบดั้งเดิม OR ตรรกะใช้สำหรับจัดการค่าบูลีนเท่านั้น ถ้าอาร์กิวเมนต์ใดๆ เป็น `true` มันจะส่งคืน `true` มิฉะนั้นจะส่งคืน `false`

ใน JavaScript ตัวดำเนินการมีความซับซ้อนและมีประสิทธิภาพมากกว่าเล็กน้อย แต่ก่อนอื่น มาดูสิ่งที่เกิดขึ้นกับค่าบูลีนกัน

มีสี่ชุดค่าตรรกะที่เป็นไปได้:

```js run
alert( true || true );   // true
alert( false || true );  // true
alert( true || false );  // true
alert( false || false ); // false
```

อย่างที่เราเห็น ผลลัพธ์คือ `true` เสมอ ยกเว้นกรณีที่ทั้งสองตัวถูกดำเนินการเป็น `false`

ถ้าตัวดำเนินการไม่ใช่แบบบูลีน มันจะถูกแปลงเป็นแบบบูลีนเพื่อการประเมิน

ตัวอย่างเช่น ตัวเลข `1` ถูกตีความเป็น `true` ตัวเลข `0` เป็น `false`:

```js run
if (1 || 0) { // ทำงานเหมือนกับ if( true || false )
  alert( 'truthy!' );
}
```

ส่วนใหญ่ OR `||` ใช้ในคำสั่ง `if` เพื่อทดสอบว่าเงื่อนไขใด *ก็ตาม* ในเงื่อนไขที่กำหนดเป็น `true`

ตัวอย่างเช่น:

```js run
let hour = 9;

*!*
if (hour < 10 || hour > 18) {
*/!*
  alert( 'The office is closed.' );
}
```

เราสามารถใส่เงื่อนไขเพิ่มเติมได้:

```js run
let hour = 12;
let isWeekend = true;

if (hour < 10 || hour > 18 || isWeekend) {
  alert( 'The office is closed.' ); // วันหยุดสุดสัปดาห์
}
```

## || "OR" หาค่า truthy ตัวแรก [#or-finds-the-first-truthy-value]

ตรรกะที่อธิบายไว้ข้างต้นค่อนข้างคลาสสิก ตอนนี้เรามาดู "ฟีเจอร์พิเศษ" ของ JavaScript กัน

อัลกอริทึมที่ขยายแล้วทำงานดังนี้

กำหนดค่า OR หลายค่า:

```js
result = value1 || value2 || value3;
```

ตัวดำเนินการ OR `||` ทำสิ่งต่อไปนี้:

- ประเมินตัวดำเนินการจากซ้ายไปขวา
- สำหรับตัวดำเนินการแต่ละตัวแปลงเป็นแบบบูลีน ถ้าผลลัพธ์เป็น `true` ให้หยุดและส่งคืนค่าเดิมของตัวดำเนินการนั้น
- ถ้าประเมินตัวดำเนินการทั้งหมดแล้ว (ทั้งหมดเป็น `false`) จะส่งคืนตัวดำเนินการสุดท้าย

ค่าจะถูกส่งคืนในรูปแบบเดิมโดยไม่เปลี่ยนแปลง

กล่าวอีกนัยหนึ่ง  OR `||` ช่วงหนึ่งจะส่งคืนค่า truthy ตัวแรก หรือตัวสุดท้ายถ้าไม่พบค่า truthy

ตัวอย่างเช่น:

```js run
alert( 1 || 0 ); // 1 (1 เป็น truthy)

alert( null || 1 ); // 1 (1 เป็นค่า truthy ตัวแรก)
alert( null || 0 || 1 ); // 1 (ค่า truthy ตัวแรก)

alert( undefined || null || 0 ); // 0 (ทั้งหมดเป็น falsy ส่งคืนค่าสุดท้าย)
```

สิ่งนี้นำไปสู่การใช้งานที่น่าสนใจเมื่อเทียบกับ "OR แบบคลาสสิก แบบบูลีนเท่านั้น"

1. แสดงค่า truthy ตัวแรกจากรายการตัวแปรหรือนิพจน์

ยกตัวอย่างเช่น เราต้องการเลือกแสดงชื่อของผู้ใช้โดยใช้ตัวแปร `firstName`, `lastName`, `nickName` ซึ่งตัวแปรเหล่านี้อาจจะไม่มีข้อมูล (undefined) หรือมีค่าที่ไม่ใช่จริง (falsy)

เราสามารถใช้ตัวดำเนินการ OR `||` เพื่อเลือกค่าแรกที่มีข้อมูลและแสดงผล (หรือแสดง `"คนไร้นาม"` ถ้าไม่มีข้อมูลเลย)

```js run
let firstName = "";
let lastName = "";
let nickName = "SuperCoder";

*!*
alert( firstName || lastName || nickName || "Anonymous"); // SuperCoder
*/!*
```

ถ้าตัวแปรทั้งหมดเป็น falsy โปรแกรมจะแสดง `"Anonymous"`

2. การประเมินแบบลัดวงจร (Short-circuit evaluation)

อีกหนึ่งฟีเจอร์ของตัวดำเนินการ OR `||` คือการประเมินแบบลัดวงจร (short-circuit)

หมายความว่า `||` จะประมวลผลอาร์กิวเมนต์ของตัวเองจนกว่าจะเจอค่า truthy ตัวแรก จากนั้นจะส่งคืนค่านั้นทันที โดยไม่แตะอาร์กิวเมนต์อื่นเลย

ความสำคัญของฟีเจอร์นี้จะชัดเจนขึ้นหากตัวถูกดำเนินการไม่ใช่แค่ค่า แต่เป็นนิพจน์ที่มีผลข้างเคียง เช่น การกำหนดตัวแปรหรือการเรียกใช้ฟังก์ชัน

ในตัวอย่างด้านล่าง มีเพียงข้อความที่สองเท่านั้นที่ถูกพิมพ์:

    ```js run no-beautify
    *!*true*/!* || alert("ไม่ถูกพิมพ์");
    *!*false*/!* || alert("ถูกพิมพ์");
    ```

ในบรรทัดแรก ตัวดำเนินการ OR `||` จะหยุดการประเมินทันทีที่เห็น `true` ดังนั้น `alert` จึงไม่ทำงาน

บางครั้ง ผู้ใช้ฟีเจอร์นี้เพื่อสั่งให้รันคำสั่งเฉพาะในกรณีที่เงื่อนไขในส่วนซ้ายเป็น falsy

## && (AND)

ตัวดำเนินการ AND แสดงด้วยเครื่องหมาย ampersand สองตัว `&&`:

```js
result = a && b;
```

ในการเขียนโปรแกรมแบบดั้งเดิม AND จะส่งคืน `true` ถ้าทั้งสองตัวถูกดำเนินการเป็น truthy มิฉะนั้นจะส่งคืน `false` :

```js run
alert( true && true );   // true
alert( false && true );  // false
alert( true && false );  // false
alert( false && false ); // false
```

ตัวอย่างกับ `if`:

```js run
let hour = 12;
let minute = 30;

if (hour == 12 && minute == 30) {
  alert( 'เวลานี้คือ 12:30' );
}
```

เช่นเดียวกับ OR ค่าใดๆ ก็สามารถใช้เป็นตัวถูกดำเนินการของ AND:

```js run
if (1 && 0) { // ประเมินเป็น true && false
  alert( "ไม่ทำงาน เพราะผลลัพธ์เป็น falsy" );
}
```


## AND "&&" หาค่า falsy ตัวแรก

กำหนดค่า AND หลายค่า:

```js
result = value1 && value2 && value3;
```

ตัวดำเนินการ AND `&&` ทำสิ่งต่อไปนี้:

- ประเมินตัวดำเนินการจากซ้ายไปขวา
- สำหรับตัวดำเนินการแต่ละตัวแปลงเป็นแบบบูลีน ถ้าผลลัพธ์เป็น `false` ให้หยุดและส่งคืนค่าเดิมของตัวดำเนินการนั้น
- ถ้าประเมินตัวดำเนินการทั้งหมดแล้ว (ทั้งหมดเป็น truthy) จะส่งคืนตัวดำเนินการสุดท้าย

กล่าวอีกนัยหนึ่ง AND จะส่งคืนค่า falsy ตัวแรก หรือตัวสุดท้ายถ้าไม่พบค่า falsy

กฎข้างต้นคล้ายกับ OR ความแตกต่างคือ AND ส่งคืนค่า *falsy* ตัวแรก ในขณะที่ OR ส่งคืนค่า *truthy* ตัวแรก

ตัวอย่าง:

```js run
// ถ้าตัวดำเนินการตัวแรกเป็น truthy
// AND จะส่งคืนตัวดำเนินการที่สอง:
alert( 1 && 0 ); // 0
alert( 1 && 5 ); // 5

// ถ้าตัวดำเนินการตัวแรกเป็น falsy
// AND จะส่งคืนตัวนั้น ตัวดำเนินการตัวที่สองจะถูกละเว้น
alert( null && 5 ); // null
alert( 0 && "no matter what" ); // 0
```

เราสามารถส่งค่าหลายค่าติดต่อกันได้ ดูว่าค่า falsy ตัวแรกถูกส่งคืนอย่างไร:

```js run
alert( 1 && 2 && null && 3 ); // null
```

เมื่อค่าทั้งหมดเป็น truthy ค่าสุดท้ายจะถูกส่งคืน:

```js run
alert( 1 && 2 && 3 ); // 3, the last one
```

````smart header="ลำดับความสำคัญของ AND `&&` สูงกว่า OR `||`"
ลำดับความสำคัญของตัวดำเนินการ AND `&&` สูงกว่า OR `||`.

ดังนั้นโค้ด `a && b || c && d` จริงๆแล้วเหมือนกับว่านิพจน์ `&&` อยู่ในวงเล็บ: `(a && b) || (c && d)`.
````

````warn header="อย่าแทนที่ `if` ด้วย `||` หรือ `&&`"
บางครั้ง ผู้ใช้ตัวดำเนินการ AND `&&` เป็น "วิธีที่สั้นกว่าในการเขียน `if`".

ตัวอย่างเช่น:

```js run
let x = 1;

(x > 0) && alert( 'Greater than zero!' );


การกระทำทางด้านขวาของ `&&` จะดำเนินการเฉพาะในกรณีที่การประเมินไปถึงเท่านั้น นั่นคือ ในกรณีที่ `(x > 0)` เป็นจริง

ดังนั้น โดยทั่วไป `&&` สามารถใช้แทน `if` ได้ แต่ไม่ใช่เสมอไป ดังนี้:

js run
let x = 1;

if (x > 0) alert( 'Greater than zero!' );


แม้ว่าตัวแปร `&&` จะสั้นกว่า `if` แต่ `if` ก็ชัดเจนกว่าและอ่านง่ายกว่าเล็กน้อย ดังนั้นเราขอแนะนำให้ใช้แต่ละโครงสร้างตามวัตถุประสงค์: ใช้ `if` ถ้าเราต้องการ `if` และใช้ `&&` ถ้าเราต้องการ AND
````


## ! (NOT)

ตัวดำเนินการ NOT แบบบูลีนแสดงด้วยเครื่องหมายอัศเจรีย์ `!`

ไวยากรณ์ค่อนข้างง่าย:

```js
result = !value;
```

ตัวดำเนินการรับอาร์กิวเมนต์ตัวเดียวและทำสิ่งต่อไปนี้:

1. แปลงตัวถูกดำเนินการเป็นประเภทบูลีน: `true/false`
2. ส่งคืนค่าผกผัน

ตัวอย่างเช่น:

```js run
alert( !true ); // false
alert( !0 ); // true
```

บางครั้งใช้ NOT `!!` ซ้อนกันเพื่อแปลงค่าเป็นประเภทบูลีน:

```js run
alert( !!"non-empty string" ); // true
alert( !!null ); // false
```

นั่นคือ NOT ตัวแรกแปลงค่าเป็นบูลีนและส่งคืนค่าผกผัน และ NOT ตัวที่สองทำให้ผกผันอีกครั้ง สุดท้าย เรามีการแปลงค่าเป็นบูลีนอย่างง่าย

มีวิธีที่ยาวกว่าเล็กน้อยในการทำสิ่งเดียวกัน -- ฟังก์ชัน `Boolean` ที่มีมาให้:

```js run
alert( Boolean("non-empty string") ); // true
alert( Boolean(null) ); // false
```

ลำดับความสำคัญของ NOT `!` สูงที่สุดในบรรดาตัวดำเนินการตรรกะทั้งหมด ดังนั้นมันจะทำงานก่อนเสมอ ก่อน `&&` หรือ `||`