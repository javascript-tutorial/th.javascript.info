# การวนซ้ำ (Loops): while และ for

เราจำเป็นต้องทำซ้ำคำสั่งบ่อยๆ 

ยกตัวอย่างเช่น การแสดงสินค้าจากรายการออกมาทีละชิ้น หรือแค่รันโค้ดเดิมซ้ำๆ กับตัวเลขแต่ละตัวจาก 1 ถึง 10

*Loops* คือวิธีการที่ใช้ในการทำซ้ำโค้ดเดิมหลายๆ ครั้ง

```smart header="การวนซ้ำ for..of และ for..in"
ประกาศสำหรับผู้อ่านขั้นสูง

บทความนี้ครอบคลุมเฉพาะ loops พื้นฐาน: `while`, `do..while` และ `for(..;..;..)`

ถ้าคุณมาถึงบทความนี้เพื่อค้นหาประเภทอื่นๆ ของ loops ลองดูที่นี่:
- ดู [for..in](info:object#forin) สำหรับการวนซ้ำคุณสมบัติของออบเจ็กต์
- ดู [for..of](info:array#loops) และ [iterables](info:iterable) สำหรับการวนซ้ำอาร์เรย์และออบเจ็กต์ที่สามารถวนซ้ำได้

ถ้าไม่ใช่ ขอให้อ่านต่อไป
```

## การวนซ้ำแบบ "while"

การวนซ้ำแบบ `while` มีรูปแบบดังนี้:

```js
while (เงื่อนไข) {
  // โค้ด
  // เรียกว่า "loop body"
}
```

ในขณะที่ `เงื่อนไข` ยังเป็นจริง `โค้ด` ใน loop body จะถูกรัน

ยกตัวอย่างเช่น loop ด้านล่างจะแสดง `i` ตราบใดที่ `i < 3`:

```js run
let i = 0;
while (i < 3) { // แสดง 0, จากนั้น 1, จากนั้น 2
  alert( i );
  i++;
}
```

การรันโค้ดใน loop body หนึ่งรอบ เรียกว่า *an iteration* loop ในตัวอย่างด้านบน จะทำ 3 iterations

ถ้าไม่มีการเพิ่ม `i++` ใน loop จะวนซ้ำไปเรื่อยๆ (ในทางทฤษฎี) ในทางปฏิบัติ เบราว์เซอร์จะมีวิธีการในการหยุด loop แบบนี้ และใน JavaScript ฝั่งเซิร์ฟเวอร์ เราสามารถหยุดกระบวนการได้

นิพจน์หรือตัวแปรใดก็ได้สามารถใช้เป็นเงื่อนไขในการวนซ้ำได้ ไม่จำกัดแค่เป็นการเปรียบเทียบเท่านั้น: เงื่อนไขจะถูกประเมินและแปลงเป็น boolean โดย `while`

ตัวอย่างเช่น วิธีที่สั้นกว่า `while (i != 0)` คือ `while (i)`:

```js run
let i = 3;
*!*
while (i) { // เมื่อ i เป็น 0, เงื่อนไขจะเป็น falsy แล้ว loop จะหยุด
*/!*
  alert( i );
  i--;
}
```

````smart header="ไม่ต้องใส่ปีกกา { } ถ้า loop body มีแค่คำสั่งเดียว"
ถ้า loop body มีแค่คำสั่งเดียว เราสามารถละปีกกา `{…}` ได้:

```js run
let i = 3;
*!*
while (i) alert(i--);
*/!*
```
````

## การวนซ้ำแบบ "do..while"

การตรวจสอบเงื่อนไขสามารถย้ายไปอยู่ *ข้างล่าง* loop body ได้ ด้วยการใช้ `do..while`:

```js
do {
  // loop body
} while (เงื่อนไข);
```

Loop จะรันโค้ดใน body ก่อน แล้วค่อยมาตรวจสอบเงื่อนไข และถ้าเงื่อนไขเป็นจริง ก็จะรันซ้ำไปเรื่อยๆ

ตัวอย่าง:

```js run
let i = 0;
do {
  alert( i );
  i++;
} while (i < 3);
```

รูปแบบนี้ควรใช้เฉพาะตอนที่คุณต้องการให้ loop body รันอย่างน้อยหนึ่งครั้ง ไม่ว่าเงื่อนไขจะเป็นจริงหรือไม่ก็ตาม ในกรณีทั่วไป ควรเลือกใช้รูปแบบ `while(…) {…}` มากกว่า

## การวนซ้ำแบบ "for" 

การวนซ้ำแบบ `for` มีความซับซ้อนมากกว่า แต่ก็เป็นรูปแบบที่นิยมใช้มากที่สุดเช่นกัน

มีรูปแบบดังนี้:

```js
for (เริ่มต้น; เงื่อนไข; ขั้นตอน) {
  // ... loop body ...
}
```

ลองมาศึกษาความหมายของแต่ละส่วนจากตัวอย่างกัน loop ด้านล่างจะรัน `alert(i)` เมื่อ `i` มีค่าตั้งแต่ `0` ถึง `3` (ไม่รวม `3`):

```js run
for (let i = 0; i < 3; i++) { // แสดง 0, จากนั้น 1, จากนั้น 2
  alert(i);
}
```

มาดูแต่ละส่วนของคำสั่ง `for` กัน:

| ส่วน  |          |                                                                            |
|-------|----------|----------------------------------------------------------------------------|
| เริ่มต้น | `let i = 0`    | รันครั้งเดียวตอนเข้า loop                                    |
| เงื่อนไข | `i < 3`| ตรวจสอบก่อนทุกรอบของ loop ถ้าเป็น false loop จะหยุด          |
| body | `alert(i)`| รันซ้ำๆ ตราบใดที่เงื่อนไขยังเป็นจริง                         |
| ขั้นตอน| `i++`      | รันหลังจาก body ในแต่ละรอบ |

อัลกอริทึมทั่วไปของ loop จะทำงานดังนี้:

```
รันส่วนเริ่มต้น
→ (ถ้าเงื่อนไขเป็นจริง → รัน body และรันขั้นตอน)
→ (ถ้าเงื่อนไขเป็นจริง → รัน body และรันขั้นตอน)
→ (ถ้าเงื่อนไขเป็นจริง → รัน body และรันขั้นตอน)
→ ...
```

ถ้าพูดให้ชัดเจน `เริ่มต้น` จะรันครั้งเดียว แล้วก็จะเข้าสู่ iteration: หลังจากการตรวจสอบ `เงื่อนไข` `body` และ `ขั้นตอน` จะถูกรัน

ถ้าคุณใหม่กับ loops การกลับไปอ่านตัวอย่างพร้อมๆ กับเขียนว่าแต่ละขั้นตอนทำงานอย่างไรก็อาจจะช่วยได้

นี่คือสิ่งที่เกิดขึ้นในตัวอย่างของเรา:

```js
// for (let i = 0; i < 3; i++) alert(i)

// รันส่วนเริ่มต้น
let i = 0
// ถ้าเงื่อนไขเป็นจริง → รัน body และรันขั้นตอน
if (i < 3) { alert(i); i++ }
// ถ้าเงื่อนไขเป็นจริง → รัน body และรันขั้นตอน
if (i < 3) { alert(i); i++ }
// ถ้าเงื่อนไขเป็นจริง → รัน body และรันขั้นตอน
if (i < 3) { alert(i); i++ }
// ...เสร็จสิ้น เพราะตอนนี้ i == 3
```

````smart header="ประกาศตัวแปรใน loop"
ในตัวอย่าง ตัวแปร "counter" `i` ถูกประกาศภายใน loop โดยตรง นี่เรียกว่า "inline" variable declaration ตัวแปรเหล่านี้จะมองเห็นเฉพาะใน loop เท่านั้น

```js run
for (*!*let*/!* i = 0; i < 3; i++) {
  alert(i); // 0, 1, 2
}
alert(i); // error, ไม่มีตัวแปรนี้
```

แทนที่จะประกาศตัวแปรใหม่ เราสามารถใช้ตัวแปรที่มีอยู่แล้วได้:

```js run
let i = 0;

for (i = 0; i < 3; i++) { // ใช้ตัวแปรที่มีอยู่แล้ว
  alert(i); // 0, 1, 2
}

alert(i); // 3, มองเห็น เพราะประกาศนอก loop
```
````

### การข้ามส่วน

เราสามารถข้ามส่วนใดส่วนหนึ่งของ `for` ได้

ยกตัวอย่างเช่น เราสามารถละ `เริ่มต้น` ได้ถ้าเราไม่ต้องทำอะไรตอนเริ่ม loop

อย่างเช่นที่นี่:

```js run
let i = 0; // เราประกาศ i ไว้แล้วก่อนหน้านี้

for (; i < 3; i++) { // ไม่จำเป็นต้องมี "เริ่มต้น" 
  alert( i ); // 0, 1, 2
}
```

เราสามารถละส่วน `ขั้นตอน` ได้เช่นกัน:

```js run
let i = 0;

for (; i < 3;) {
  alert( i++ );
}
```

นี่จะทำให้ loop เหมือนกับ `while (i < 3)`

เราสามารถลบได้ทุกอย่างเลย เพื่อสร้าง infinite loop:

```js
for (;;) {
  // วนซ้ำไม่มีที่สิ้นสุด
}
```

โปรดทราบว่า semicolon `;` ทั้งสองใน `for` ต้องมีนะ ไม่อย่างนั้นจะเป็น syntax error

## การหยุด loop

โดยปกติ loop จะหยุดเมื่อเงื่อนไขเป็น falsy

แต่เราสามารถบังคับให้หยุดเมื่อไรก็ได้ด้วยคำสั่ง `break`

ยกตัวอย่างเช่น loop ด้านล่างจะถามผู้ใช้ให้กรอกตัวเลข และจะ "break" เมื่อไม่มีการป้อนตัวเลข:

```js run
let sum = 0;

while (true) {

  let value = +prompt("ใส่ตัวเลข", '');

*!*
  if (!value) break; // (*)
*/!*

  sum += value;

}
alert( 'ผลรวม: ' + sum );
```

คำสั่ง `break` จะถูกเรียกที่บรรทัด `(*)` ถ้าผู้ใช้ป้อนบรรทัดว่าง หรือกด cancel มันจะหยุด loop ในทันที และส่งการทำงานไปยังบรรทัดแรกหลัง loop นั่นคือ `alert`

การผสมผสานของ "infinite loop + `break` เมื่อต้องการ" เหมาะสำหรับสถานการณ์ที่ต้องการตรวจสอบเงื่อนไขในกลางหรือหลายตำแหน่งในส่วน body ของลูป

## การข้ามไปยัง Iteration ถัดไป [#continue]

คำสั่ง `continue` เป็น "เวอร์ชันเบาๆ" ของ `break` มันไม่ได้หยุด loop ทั้งหมด แต่มันจะหยุด iteration ปัจจุบัน และบังคับให้ loop เริ่มใหม่ (ถ้าเงื่อนไขอนุญาต)

เราสามารถใช้มันได้ถ้าเราทำส่วนปัจจุบันเสร็จแล้ว และต้องการไปยังรอบถัดไป

Loop ด้านล่างใช้ `continue` เพื่อแสดงผลเฉพาะค่าที่เป็นเลขคี่:

```js run no-beautify
for (let i = 0; i < 10; i++) {

  // ถ้า true ข้ามส่วนที่เหลือของ body ไป
  *!*if (i % 2 == 0) continue;*/!*

  alert(i); // 1, แล้วก็ 3, 5, 7, 9
}
```

สำหรับค่า `i` ที่เป็นเลขคู่ คำสั่ง `continue` จะหยุดการทำงานของ body และส่งต่อการควบคุมไปยัง iteration ถัดไปของ `for` (ด้วยเลขตัวถัดไป) ดังนั้น `alert` จะถูกเรียกใช้เฉพาะสำหรับเลขคี่

````smart header="`continue` ช่วยลดการซ้อนกันของโค้ด"
Loop ที่แสดงแต่เลขคี่สามารถเขียนได้แบบนี้:

```js run
for (let i = 0; i < 10; i++) {

  if (i % 2) {
    alert( i );
  }

}
```

ในแง่ของเทคนิค สิ่งนี้เหมือนกับตัวอย่างด้านบน แน่นอน เราสามารถห่อโค้ดใส่บล็อก `if` แทนการใช้ `continue` ได้

แต่ผลข้างเคียงคือ มันจะสร้างการซ้อนกันของโค้ดขึ้นมาอีกชั้นหนึ่ง (การเรียก `alert` อยู่ในปีกกาหยัก) ถ้าโค้ดใน `if` ยาวกว่าสองสามบรรทัด มันอาจทำให้โค้ดอ่านยากขึ้น
````

````warn header="ไม่มี `break/continue` อยู่ทางขวาของ '?'"
โปรดทราบว่า syntax constructs ที่ไม่ใช่ expressions ไม่สามารถใช้กับตัวดำเนินการ ternary `?` ได้ โดยเฉพาะคำสั่งอย่าง `break/continue` จะไม่อนุญาตให้ใช้ได้

ตัวอย่างเช่น ถ้าเราเอาโค้ดนี้:

```js
if (i > 5) {
  alert(i);
} else {
  continue;
}
```

...แล้วเขียนใหม่โดยใช้เครื่องหมายคำถาม:

```js no-beautify
(i > 5) ? alert(i) : *!*continue*/!*; // ไม่อนุญาต continue ให้ใช้ที่นี่
```

...มันจะไม่ทำงาน: จะเป็น syntax error

นี่เป็นอีกเหตุผลหนึ่งที่ไม่ควรใช้ตัวดำเนินการ `?` แทน `if`  
````

## Labels สำหรับ break/continue

บางครั้งเราต้องการ break ออกจาก nested loops หลายชั้นในครั้งเดียว

ตัวอย่างเช่น ในโค้ดด้านล่าง เราจะวน loop บน `i` และ `j` เพื่อรับค่าพิกัด `(i, j)` จาก `(0,0)` ถึง `(2,2)`:

```js run no-beautify
for (let i = 0; i < 3; i++) {

  for (let j = 0; j < 3; j++) {

    let input = prompt(`Value at coords (${i},${j})`, '');

    // ถ้าเราต้องการออกจากนี่ไปที่ Done (ด้านล่าง) ล่ะ?
  }
}

alert('Done!');
```

เราต้องการหยุดกระบวนการนี้ได้ถ้าผู้ใช้ยกเลิกการป้อนค่า

`break` ปกติหลัง `input` จะออกจาก inner loop เท่านั้น มันไม่พอ - เราต้องใช้ labels!

*Label* คือ identifier ที่ตามด้วยเครื่องหมายทวิภาคก่อน loop:

```js
labelName: for (...) {
  ...
}
```

คำสั่ง `break <labelName>` ในตัวอย่างด้านล่างจะหยุด loop แล้วออกไปที่ label:

```js run no-beautify
*!*outer:*/!* for (let i = 0; i < 3; i++) {

  for (let j = 0; j < 3; j++) {

    let input = prompt(`Value at coords (${i},${j})`, '');

    // ถ้าใส่สตริงว่าง หรือกด cancel, ให้ออกจากทั้งสอง loops
    if (!input) *!*break outer*/!*; // (*)

    // ทำบางอย่างกับค่าที่ได้...
  }
}

alert('Done!');
```

ในโค้ดด้านบน `break outer` จะมองหา label ชื่อ `outer` ข้างบนและหยุดการทำงานของ loop นั้น

เพราะฉะนั้นการทำงานจะกระโดดจาก `(*)` ไปที่ `alert('Done!')` เลย

เราสามารถย้าย label ไปอยู่บนบรรทัดแยกต่างหากได้:

```js no-beautify
outer:
for (let i = 0; i < 3; i++) { ... }
```

คำสั่ง `continue` ก็สามารถใช้กับ label ได้ในแบบเดียวกัน ในกรณีนี้ การทำงานของโค้ดจะกระโดดไปที่การเริ่ม iteration ถัดไปของ loop ที่มี label

````warn header="Labels ไม่อนุญาตให้ \"กระโดด\" ไปที่ไหนก็ได้"
Labels ไม่อนุญาตให้เรากระโดดไปยังจุดใด ๆ ในโค้ดได้อย่างอิสระ

ตัวอย่างเช่น มันไม่สามารถทำแบบนี้ได้:

```js
break label; // กระโดดไปยัง label ด้านล่าง (ไม่ทำงาน)

label: for (...)
```

คำสั่ง `break` ต้องอยู่ภายใน code block เท่านั้น ในทางเทคนิค label สามารถใส่หน้า code block ใด ๆ ก็ได้ เช่น:

```js
label: {
  // ...
  break label; // ทำงาน
  // ...
}
```

...แม้ว่า 99.9% ของครั้ง `break` จะถูกใช้ข้างใน loops เหมือนในตัวอย่างที่เราเห็นด้านบน

`continue` ก็ใช้ได้เฉพาะข้างใน loop เท่านั้น
````

## สรุป

เราได้พูดถึง loop 3 แบบ:

- `while` -- เงื่อนไขจะถูกตรวจสอบก่อนเริ่มแต่ละ iteration
- `do..while` -- เงื่อนไขจะถูกตรวจสอบหลังจบแต่ละ iteration  
- `for (;;)` -- เงื่อนไขจะถูกตรวจสอบก่อนเริ่มแต่ละ iteration และสามารถกำหนดการตั้งค่าเพิ่มเติมได้

ในการสร้าง "infinite" loop โดยทั่วไปจะใช้ `while(true)` การสร้างแบบนี้ เหมือนกับ loop แบบอื่น ๆ สามารถหยุดได้ด้วยคำสั่ง `break`

ถ้าเราไม่ต้องการทำอะไรใน iteration ปัจจุบัน และต้องการข้ามไปที่รอบถัดไป เราสามารถใช้คำสั่ง `continue`

`break/continue` รองรับการใส่ label ไว้ข้างหน้า loop label เป็นวิธีเดียวที่ `break/continue` จะสามารถออกจาก nested loop ได้และไปยัง outer loop
