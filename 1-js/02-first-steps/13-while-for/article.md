# ลูป: while และ for

เราต้องทำซ้ำการกระทำบางอย่างบ่อยๆ 

ตัวอย่างเช่น แสดงผลสินค้าจากรายการทีละชิ้น หรืออาจเป็นแค่การรันโค้ดเดิมซ้ำๆ สำหรับทุกตัวเลขตั้งแต่ 1 ถึง 10

*ลูป* คือวิธีการทำให้โค้ดทำงานซ้ำหลายรอบ

````smart header="ลูป for..of และ for..in"
ข้อความสำหรับผู้อ่านระดับสูงเล็กน้อย

บทความนี้จะกล่าวถึงเฉพาะลูปพื้นฐาน ได้แก่ `while`, `do..while` และ `for(..;..;..)`

หากคุณมาที่บทความนี้เพื่อหาข้อมูลเกี่ยวกับลูปประเภทอื่นๆ สามารถดูได้จาก:

- [for..in](info:object#forin) สำหรับการวนลูปเพื่อเข้าถึงพร็อพเพอร์ตี้ของออบเจ็กต์
- [for..of](info:array#loops) และ [iterable](info:iterable) สำหรับการวนลูปอาร์เรย์และออบเจ็กต์ที่สามารถวนซ้ำได้ (iterable objects)

หากไม่ใช่ กรุณาอ่านต่อไปได้เลยครับ
````

## ลูป "while"

ลูป `while` มีไวยากรณ์ดังนี้:

```js
while (condition) {
  // โค้ด
  // เรียกว่า "loop body"
}
```

ตราบใดที่ `condition` เป็นจริง `code` ใน loop body จะถูกประมวลผล

ยกตัวอย่างเช่น ลูปด้านล่างจะแสดงค่า `i` ตราบเท่าที่ `i < 3`:

```js run
let i = 0;
while (i < 3) { // แสดง 0, แล้ว 1, แล้ว 2
  alert( i );
  i++;
}
```

การประมวลผล loop body หนึ่งรอบเรียกว่า *การวนซ้ำ (iteration)* ลูปในตัวอย่างข้างต้นทำการวนซ้ำสามรอบ

หากไม่มีคำสั่ง `i++` ในตัวอย่างข้างต้น ลูปจะทำซ้ำ (ในทางทฤษฎี) ไปเรื่อยๆ ในทางปฏิบัติ เบราว์เซอร์จะมีวิธีหยุดลูปเช่นนี้ และใน JavaScript ฝั่งเซิร์ฟเวอร์ เราสามารถยุติกระบวนการได้

เงื่อนไขลูปสามารถเป็นนิพจน์หรือตัวแปรใดๆ ก็ได้ ไม่จำเป็นต้องเป็นการเปรียบเทียบเท่านั้น: `while` จะประเมินเงื่อนไขและแปลงเป็นบูลีน

ตัวอย่างเช่น วิธีที่สั้นกว่าในการเขียน `while (i != 0)` คือ `while (i)`:

```js run
let i = 3;
*!*
while (i) { // เมื่อ i เป็น 0, เงื่อนไขจะเป็นเท็จ และลูปจะหยุด
*/!*
  alert( i );
  i--;
}
```

````smart header="ไม่จำเป็นต้องใช้วงเล็บปีกกาสำหรับ loop body ที่มีคำสั่งเดียว"
หาก loop body มีเพียงคำสั่งเดียว เราสามารถละวงเล็บปีกกา `{…}` ได้:

```js run
let i = 3;
*!*
while (i) alert(i--);
*/!*
````

## ลูป "do..while"

เราสามารถย้ายการตรวจสอบเงื่อนไขไปอยู่*ด้านล่าง*ของ loop body ได้ด้วยการใช้ไวยากรณ์ `do..while`:

```js
do {
  // loop body
} while (condition);
```

ลูปจะทำการประมวลผล body ก่อน จากนั้นจึงตรวจสอบเงื่อนไข และหากเงื่อนไขเป็นจริง ก็จะประมวลผลซ้ำไปเรื่อยๆ

ตัวอย่างเช่น:

```js run
let i = 0;
do {
  alert( i );
  i++;
} while (i < 3);
```

ไวยากรณ์ในรูปแบบนี้ควรใช้เฉพาะเมื่อต้องการให้ body ของลูปทำงาน**อย่างน้อยหนึ่งครั้ง** โดยไม่คำนึงว่าเงื่อนไขจะเป็นจริงหรือไม่ โดยทั่วไปแล้วมักจะนิยมใช้รูปแบบอื่นมากกว่า เช่น `while(…) {…}`

## ลูป "for"

ลูป `for` มีความซับซ้อนกว่า แต่ก็เป็นลูปที่ใช้บ่อยที่สุดเช่นกัน

รูปแบบของมันเป็นดังนี้:

```js
for (begin; condition; step) {
  // ... loop body ...
}
```

มาทำความเข้าใจความหมายของแต่ละส่วนผ่านตัวอย่างกัน ลูปด้านล่างจะรัน `alert(i)` สำหรับ `i` ตั้งแต่ `0` ถึง (แต่ไม่รวม) `3`:

```js run
for (let i = 0; i < 3; i++) { // แสดง 0, แล้ว 1, แล้ว 2
  alert(i);
}
```

มาดูประโยค `for` ทีละส่วนกัน:

| ส่วน  |          |                                                                            |
|-------|----------|----------------------------------------------------------------------------|
| begin | `let i = 0`    | ทำงานครั้งเดียวเมื่อเริ่มเข้าลูป                                             |
| condition | `i < 3`| ตรวจสอบก่อนการวนลูปทุกรอบ ถ้าเป็นเท็จ ลูปจะหยุด                             |
| body | `alert(i)`| ทำซ้ำไปเรื่อยๆ ตราบเท่าที่เงื่อนไขเป็นจริง                                     |
| step| `i++`      | ทำงานหลัง body ในแต่ละรอบ |

ขั้นตอนการทำงานของลูปโดยทั่วไปเป็นดังนี้:

```
Run begin
→ (if condition → run body and run step)
→ (if condition → run body and run step)
→ (if condition → run body and run step)
→ ...
```

นั่นคือ `begin` จะถูกรันครั้งเดียว จากนั้นจะเริ่มวนลูป: หลังจากตรวจสอบ `condition` แต่ละครั้ง `body` และ `step` จะถูกประมวลผล

ถ้าคุณเพิ่งเริ่มเรียนรู้เรื่องลูป การย้อนกลับไปดูตัวอย่างและลองเขียนเองทีละขั้นตอนบนกระดาษอาจช่วยทำความเข้าใจได้ดีขึ้น

ต่อไปนี้คือสิ่งที่เกิดขึ้นจริงๆ ในกรณีของเรา:

```js
// for (let i = 0; i < 3; i++) alert(i)

// run begin
let i = 0
// if condition → run body and run step
if (i < 3) { alert(i); i++ }
// if condition → run body and run step
if (i < 3) { alert(i); i++ }
// if condition → run body and run step
if (i < 3) { alert(i); i++ }
// ...finish, because now i == 3
```

```smart header="การประกาศตัวแปรอินไลน์"
ในที่นี้ ตัวแปร "ตัวนับ" `i` ถูกประกาศภายในลูปโดยตรง เรียกว่าการประกาศตัวแปรแบบ "อินไลน์" ตัวแปรแบบนี้จะมองเห็นได้เฉพาะภายในลูปเท่านั้น

```js run
for (*!*let*/!* i = 0; i < 3; i++) {
  alert(i); // 0, 1, 2
}
alert(i); // error, ไม่มีตัวแปรนี้
```

แทนที่จะประกาศตัวแปรใหม่ เราสามารถใช้ตัวแปรที่มีอยู่แล้วก็ได้:

```js run
let i = 0;

for (i = 0; i < 3; i++) { // ใช้ตัวแปรที่มีอยู่
  alert(i); // 0, 1, 2
}

alert(i); // 3, มองเห็นได้ เพราะประกาศไว้นอกลูป
```

### การข้ามบางส่วน

ส่วนใดๆ ของ `for` ก็ข้ามได้

ตัวอย่างเช่น เราสามารถละส่วน `begin` ได้ถ้าไม่จำเป็นต้องทำอะไรตอนเริ่มลูป

แบบนี้:

```js run
let i = 0; // เรามีการประกาศและกำหนดค่า i อยู่แล้ว

for (; i < 3; i++) { // ไม่ต้องมีส่วน "begin"
  alert( i ); // 0, 1, 2
}
```

เราสามารถเอาส่วน `step` ออกได้ด้วย:

```js run
let i = 0;

for (; i < 3;) {
  alert( i++ );
}
```

ลูปแบบนี้จะเหมือนกับ `while (i < 3)`

จริงๆ แล้วเราสามารถเอาทุกอย่างออกได้ เพื่อสร้างลูปไม่รู้จบ:

```js
for (;;) {
  // วนซ้ำไม่มีที่สิ้นสุด
}
```

โปรดสังเกตว่าจะต้องมีอัฒภาค `;` ทั้งสองตัวของ `for` อยู่เสมอ ไม่เช่นนั้นจะเกิด syntax error

## การออกจากลูป

โดยปกติแล้ว ลูปจะจบลงเมื่อเงื่อนไขเป็นเท็จ

แต่เราสามารถบังคับให้ออกจากลูปได้ทุกเมื่อด้วยการใช้คำสั่งพิเศษ `break`

ยกตัวอย่างเช่น ลูปด้านล่างจะถามผู้ใช้ให้ป้อนตัวเลขเป็นชุด และจะ "break" เมื่อไม่มีการป้อนตัวเลข:

```js run
let sum = 0;

while (true) {

  let value = +prompt("Enter a number", '');

*!*
  if (!value) break; // (*)
*/!*

  sum += value;

}
alert( 'Sum: ' + sum );
```

คำสั่ง `break` จะทำงานที่บรรทัด `(*)` ถ้าผู้ใช้ป้อนบรรทัดว่างหรือกด cancel มันจะหยุดลูปทันที โดยส่งการควบคุมไปที่บรรทัดแรกหลังลูป นั่นคือไปที่ `alert`

การใช้ "ลูปไม่รู้จบ + `break` เมื่อต้องการ" นั้นเหมาะมากสำหรับสถานการณ์ที่ต้องตรวจสอบเงื่อนไขของลูป ไม่ใช่ที่จุดเริ่มต้นหรือจุดสิ้นสุดของลูป แต่อยู่ตรงกลางหรือแม้กระทั่งหลายๆ จุดในตัวลูปเอง

## การข้ามไปยังรอบถัดไป [#continue]

คำสั่ง `continue` เป็น "เวอร์ชันที่เบากว่า" ของ `break` มันไม่ได้หยุดลูปทั้งหมด แต่จะหยุดเฉพาะรอบปัจจุบันและบังคับให้ลูปเริ่มรอบใหม่แทน (ถ้าเงื่อนไขอนุญาต)

เราสามารถใช้มันได้ถ้าเราเสร็จสิ้นกับการประมวลผลในรอบปัจจุบันแล้วและต้องการข้ามไปยังรอบถัดไป

ลูปด้านล่างใช้ `continue` เพื่อแสดงผลเฉพาะค่าที่เป็นเลขคี่:

```js run no-beautify
for (let i = 0; i < 10; i++) {

  // ถ้าเป็นจริง ข้ามส่วนที่เหลือของ body
  *!*if (i % 2 == 0) continue;*/!*

  alert(i); // 1, แล้วก็ 3, 5, 7, 9
}
```

สำหรับค่า `i` ที่เป็นเลขคู่ คำสั่ง `continue` จะหยุดการประมวลผล body และส่งการควบคุมไปยังรอบถัดไปของ `for` (กับตัวเลขถัดไป) ดังนั้น `alert` จะถูกเรียกเฉพาะกับค่าที่เป็นเลขคี่เท่านั้น

````smart header="คำสั่ง `continue` ช่วยลดความซับซ้อนของโค้ด"
ลูปที่แสดงค่าที่เป็นเลขคี่อาจเขียนได้แบบนี้:

```js run
for (let i = 0; i < 10; i++) {

  if (i % 2) {
    alert( i );
  }

}
```

ในแง่เทคนิค โค้ดนี้เหมือนกับตัวอย่างด้านบนทุกประการ เราสามารถห่อโค้ดไว้ในบล็อก `if` แทนการใช้ `continue` ก็ได้

แต่ผลข้างเคียงคือ มันจะสร้างระดับความซับซ้อนของโค้ดเพิ่มขึ้นอีกหนึ่งชั้น (การเรียก `alert` อยู่ภายในวงเล็บปีกกา) ถ้าโค้ดภายใน `if` ยาวกว่าสองสามบรรทัด มันอาจลดความสามารถในการอ่านโค้ดโดยรวมได้
````

````warn header="ไม่มี `break/continue` ที่ด้านขวาของ '?'"
โปรดสังเกตว่า โครงสร้างทางไวยากรณ์ที่ไม่ใช่นิพจน์ จะไม่สามารถใช้กับตัวดำเนินการแบบ 3 พารามิเตอร์ `?` ได้ โดยเฉพาะอย่างยิ่ง คำสั่งอย่างเช่น `break/continue` จะไม่ได้รับอนุญาตให้ใช้ในตำแหน่งนั้น

ตัวอย่างเช่น ถ้าเรามีโค้ดแบบนี้:

```js
if (i > 5) {
  alert(i);
} else {
  continue;
}
```

...แล้วเขียนใหม่โดยใช้เครื่องหมายคำถาม:

```js no-beautify
(i > 5) ? alert(i) : *!*continue*/!*; // continue ไม่ได้รับอนุญาตที่นี่
```

...มันจะหยุดทำงาน: เกิด syntax error ขึ้น

นี่เป็นอีกเหตุผลหนึ่งที่ไม่ควรใช้ตัวดำเนินการแบบ 3 พารามิเตอร์ `?` แทน `if`
````

## Labels สำหรับ break/continue

บางครั้งเราอาจต้องออกจากลูปที่ซ้อนกันหลายชั้นในคราวเดียว

ตัวอย่างเช่น ในโค้ดด้านล่าง เราวนลูปด้วย `i` และ `j` เพื่อถามหาค่าที่พิกัด `(i, j)` ตั้งแต่ `(0,0)` ถึง `(2,2)`:

```js run no-beautify
for (let i = 0; i < 3; i++) {

  for (let j = 0; j < 3; j++) {

    let input = prompt(`Value at coords (${i},${j})`, '');

    // จะทำอย่างไรถ้าเราต้องการออกจากที่นี่ไปสู่ Done (ด้านล่าง)?
  }
}

alert('Done!');
```

เราต้องการวิธีหยุดกระบวนการนี้ถ้าผู้ใช้ยกเลิกการป้อนข้อมูล

การใช้ `break` ธรรมดาหลังจาก `input` จะออกจากลูปชั้นในเท่านั้น ซึ่งยังไม่เพียงพอ -- labels จะมาช่วยได้!

*label* คือตัวระบุที่มีเครื่องหมายโคลอนอยู่ข้างหน้าลูป:

```js
labelName: for (...) {
  ...
}
```

คำสั่ง `break <labelName>` ในลูปด้านล่างจะออกไปสู่ label:

```js run no-beautify
*!*outer:*/!* for (let i = 0; i < 3; i++) {

  for (let j = 0; j < 3; j++) {

    let input = prompt(`Value at coords (${i},${j})`, '');

    // ถ้าเป็นสตริงว่างหรือกด cancel ให้ออกจากลูปทั้งสอง
    if (!input) *!*break outer*/!*; // (*)

    // ทำอะไรบางอย่างกับค่าที่ได้...
  }
}

alert('Done!');
```

ในโค้ดด้านบน `break outer` จะมองหา label ชื่อ `outer` ขึ้นไป แล้วออกจากลูปนั้น

ดังนั้นการควบคุมจะข้ามจาก `(*)` ไปสู่ `alert('Done!')` โดยตรง

เราสามารถย้าย label ไปอยู่บนบรรทัดแยกต่างหากได้ด้วย:

```js no-beautify
outer:
for (let i = 0; i < 3; i++) { ... }
```

คำสั่ง `continue` ก็สามารถใช้ร่วมกับ label ได้เช่นกัน ในกรณีนี้ การประมวลผลโค้ดจะข้ามไปยังรอบถัดไปของลูปที่มี label กำกับ

```warn header="Labels ไม่อนุญาตให้ \"กระโดด\" ไปที่ใดก็ได้"
Labels ไม่ได้อนุญาตให้เรากระโดดไปยังตำแหน่งใดๆ ก็ได้ในโค้ด

ตัวอย่างเช่น เราไม่สามารถทำแบบนี้ได้:

```js
break label; // กระโดดไปสู่ label ด้านล่าง (ใช้ไม่ได้)

label: for (...)
```

คำสั่ง `break` ต้องอยู่ภายในบล็อกโค้ด ในทางเทคนิค บล็อกโค้ดใดๆ ที่มี label กำกับก็ใช้ได้ เช่น:

```js
label: {
  // ...
  break label; // ใช้ได้
  // ...
}
```

...อย่างไรก็ตาม ในความเป็นจริง 99.9% ของเวลา `break` จะถูกใช้ภายในลูป เหมือนที่เราเห็นในตัวอย่างด้านบน

ส่วน `continue` จะใช้ได้เฉพาะภายในลูปเท่านั้น
```
