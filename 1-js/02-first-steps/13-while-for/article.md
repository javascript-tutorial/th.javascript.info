# วงวน (Loops): while และ for

เราจำเป็นต้องทำคำสั่งซ้ำๆ บ่อยครั้ง

ยกตัวอย่างเช่น การแสดงสินค้าในรายการทีละชิ้น หรือการรันโค้ดเดิมซ้ำๆ กับตัวเลขตั้งแต่ 1 ถึง 10

*วงวน (Loops)* คือวิธีการทำซ้ำโค้ดเดิมหลายๆ รอบ

```smart header="วงวน for..of และ for..in"
ประกาศสำหรับผู้อ่านขั้นสูง

บทความนี้กล่าวถึงวงวนพื้นฐานเท่านั้น ได้แก่ `while`, `do..while` และ `for(..;..;..)`

ถ้าคุณมาที่บทความนี้เพื่อหาวงวนประเภทอื่นๆ ลองดูตรงนี้:

- ดู [for..in](info:object#forin) สำหรับการวนซ้ำ property ของ object
- ดู [for..of](info:array#loops) และ [iterables](info:iterable) สำหรับการวนซ้ำ array และ iterable objects

มิฉะนั้นก็อ่านต่อได้เลย
```

## วงวน "while"

วงวน `while` มีรูปแบบไวยากรณ์ดังนี้:

```js
while (condition) {
  // code
  // เรียกว่า "loop body"
}
```

ตราบใดที่ `condition` ยังเป็นจริง `code` ใน loop body ก็จะถูกรัน

ยกตัวอย่างเช่น วงวนด้านล่างจะแสดง `i` ตราบใดที่ `i < 3`:

```js run
let i = 0;
while (i < 3) { // แสดง 0, แล้ว 1, แล้ว 2
  alert( i );
  i++;
}
```

การรันโค้ดใน loop body หนึ่งรอบเรียกว่า *อิเทอเรชัน (iteration)* วงวนในตัวอย่างข้างต้นจะทำ 3 อิเทอเรชัน

ถ้าขาด `i++` ในตัวอย่าง วงวนจะทำซ้ำไปตลอด (ในทางทฤษฎี) แต่ในทางปฏิบัติ เบราว์เซอร์จะมีวิธีหยุดวงวนแบบนี้ และใน JavaScript ฝั่งเซิร์ฟเวอร์ เราก็หยุดโพรเซสได้

นิพจน์หรือตัวแปรใดๆ ก็ตามสามารถใช้เป็นเงื่อนไขวงวนได้ ไม่จำกัดแค่การเปรียบเทียบ: `while` จะประเมินเงื่อนไขและแปลงเป็น boolean 

เช่น วิธีเขียน `while (i != 0)` ให้สั้นลงคือ `while (i)`:

```js run
let i = 3;
*!*
while (i) { // เมื่อ i เป็น 0, เงื่อนไขจะเป็น falsy และวงวนจะหยุด
*/!*
  alert( i );
  i--;
}
```

````smart header="ไม่ต้องใส่ปีกกา { } ถ้า loop body มีคำสั่งเดียว"
ถ้า loop body มีแค่คำสั่งเดียว เราสามารถละปีกกา `{…}` ได้:

```js run
let i = 3;
*!*
while (i) alert(i--);
*/!*
```
````

## วงวน "do..while"

การตรวจสอบเงื่อนไขสามารถย้ายไปอยู่*ใต้* loop body ได้โดยใช้ `do..while`:

```js
do {
  // loop body
} while (condition);
```

วงวนจะรัน loop body ก่อน จากนั้นจึงตรวจสอบเงื่อนไข และหากเงื่อนไขเป็นจริง ก็จะรันซ้ำแล้วซ้ำอีก

ตัวอย่างเช่น:

```js run
let i = 0;
do {
  alert( i );
  i++;
} while (i < 3);
```

ควรใช้รูปแบบไวยากรณ์นี้เฉพาะเมื่อต้องการให้ loop body รันอย่างน้อย**หนึ่งครั้ง** โดยไม่คำนึงว่าเงื่อนไขจะเป็นจริงหรือไม่ โดยปกติแล้วมักนิยมใช้รูปแบบ `while(…) {…}` มากกว่า

## วงวน "for"

วงวน `for` มีความซับซ้อนมากกว่า แต่ก็เป็นวงวนที่ใช้กันบ่อยที่สุดเช่นกัน

รูปแบบคือ:

```js
for (begin; condition; step) {
  // ... loop body ...
}
```

มาดูความหมายของแต่ละส่วนจากตัวอย่างกัน วงวนด้านล่างจะรัน `alert(i)` สำหรับ `i` ตั้งแต่ `0` ถึง `3` (ไม่รวม `3`):

```js run
for (let i = 0; i < 3; i++) { // แสดง 0, แล้ว 1, แล้ว 2
  alert(i);
}
```

มาดูคำสั่ง `for` ทีละส่วน:

| ส่วน      |               |                                                                               |
|-----------|---------------|-------------------------------------------------------------------------------|
| begin     | `let i = 0`   | รันครั้งเดียวตอนเข้าวงวน                                                      |
| condition | `i < 3`       | ถูกตรวจสอบก่อนการรันวงวนแต่ละรอบ ถ้าเป็น false วงวนจะหยุด                   |
| body      | `alert(i)`    | รันซ้ำไปเรื่อยๆ ตราบใดที่ condition ยังเป็นจริง                               |
| step      | `i++`         | รันหลัง body ในแต่ละรอบ                                                       |

อัลกอริทึมทั่วไปของวงวนทำงานแบบนี้:

```
รันส่วนเริ่มต้น
→ (ถ้าเงื่อนไขเป็นจริง → รัน body และรันขั้นตอน)
→ (ถ้าเงื่อนไขเป็นจริง → รัน body และรันขั้นตอน)
→ (ถ้าเงื่อนไขเป็นจริง → รัน body และรันขั้นตอน)
→ ...
```

นั่นคือ `begin` รันครั้งเดียว แล้วก็จะเข้าสู่ iteration: หลังจากทดสอบ `condition` แล้ว `body` และ `step` จะถูกรัน

ถ้าคุณใหม่กับวงวน การย้อนกลับไปดูตัวอย่างพร้อมๆ กับเขียนว่าแต่ละขั้นตอนทำงานอย่างไร อาจจะช่วยให้เข้าใจได้ดีขึ้น

ต่อไปนี้คือสิ่งที่เกิดขึ้นจริงๆ ในตัวอย่างของเรา:

```js
// for (let i = 0; i < 3; i++) alert(i)

// รันส่วนเริ่มต้น
let i = 0
// ถ้าเงื่อนไขเป็นจริง → รัน body และรันขั้นตอน
if (i < 3) { alert(i); i++ }
// ถ้าเงื่อนไขเป็นจริง → รัน body และรันขั้นตอน
if (i < 3) { alert(i); i++ }
// ถ้าเงื่อนไขเป็นจริง → รัน body และรันขั้นตอน
if (i < 3) { alert(i); i++ }
// ...เสร็จสิ้น เพราะตอนนี้ i == 3
```

````smart header="การประกาศตัวแปรใน loop"
ในที่นี้ ตัวแปร "counter" `i` ถูกประกาศในวงวนโดยตรง เรียกว่าการประกาศตัวแปร "inline" ตัวแปรเหล่านี้จะมองเห็นได้เฉพาะในวงวนเท่านั้น

```js run
for (*!*let*/!* i = 0; i < 3; i++) {
  alert(i); // 0, 1, 2
}
alert(i); // error, ไม่มีตัวแปรนี้
```  

แทนที่จะประกาศตัวแปรใหม่ เราสามารถใช้ตัวแปรที่มีอยู่แล้ว:

```js run
let i = 0;

for (i = 0; i < 3; i++) { // ใช้ตัวแปรที่มีอยู่
  alert(i); // 0, 1, 2  
}

alert(i); // 3, มองเห็นได้ เพราะถูกประกาศนอกวงวน
```
````

### การข้ามส่วนต่างๆ ของวงวน

เราสามารถข้ามส่วนใดๆ ของ `for` ก็ได้

ยกตัวอย่างเช่น เราสามารถละส่วน `begin` ได้ ถ้าเราไม่จำเป็นต้องทำอะไรที่จุดเริ่มต้นของวงวน 

เช่นในตัวอย่างนี้:

```js run
let i = 0; // เรามีการประกาศและกำหนดค่า i ไว้ก่อนแล้ว

for (; i < 3; i++) { // ไม่จำเป็นต้องมีส่วน "begin"
  alert( i ); // 0, 1, 2
}
```

เราสามารถตัดส่วน `step` ออกได้ด้วย:

```js run
let i = 0;

for (; i < 3;) {
  alert( i++ );
}  
```

การทำแบบนี้จะทำให้วงวนเหมือนกับ `while (i < 3)`

จริงๆ แล้วเราสามารถตัดทุกอย่างออกได้เลย เพื่อสร้างวงวนอนันต์:

```js
for (;;) {
  // ทำซ้ำไม่รู้จบ
}
```

โปรดสังเกตว่าเครื่องหมายอัฒภาค `;` สองตัวของ `for` ต้องมี ไม่อย่างนั้นจะเกิด syntax error

## การออกจากวงวน

โดยปกติ วงวนจะจบลงเมื่อเงื่อนไขเป็น falsy

แต่เราสามารถบังคับให้ออกจากวงวนเมื่อไรก็ได้ โดยใช้คำสั่ง `break`

ตัวอย่างเช่น วงวนด้านล่างจะขอให้ผู้ใช้ป้อนชุดของตัวเลข และจะ "ออกจากวงวน" เมื่อไม่มีการป้อนตัวเลข:

```js run
let sum = 0;

while (true) {

  let value = +prompt("ป้อนตัวเลข", '');

*!*
  if (!value) break; // (*)
*/!*

  sum += value;

}
alert( 'ผลรวม: ' + sum );
```

คำสั่ง `break` จะทำงานที่บรรทัด `(*)` หากผู้ใช้ป้อนค่าว่างหรือกดยกเลิก มันจะหยุดวงวนทันทีแล้วส่งการควบคุมไปที่บรรทัดแรกหลังวงวน นั่นคือ `alert`

การใช้ "วงวนอนันต์ + `break` เมื่อจำเป็น" เป็นวิธีที่ดีสำหรับสถานการณ์ที่ต้องตรวจเช็คเงื่อนไขวงวน ไม่ใช่ที่จุดเริ่มต้นหรือจุดสิ้นสุด แต่อยู่ตรงกลางหรือหลายๆ ที่ในวงวน

## การข้ามไปทำรอบถัดไป [#continue]

คำสั่ง `continue` เป็น "เวอร์ชันที่เบากว่า" ของ `break` มันไม่ได้หยุดวงวนทั้งหมด แต่จะหยุดการทำงานในรอบปัจจุบันแล้วบังคับให้วงวนเริ่มรอบใหม่ (ถ้าเงื่อนไขอนุญาต)

เราสามารถใช้มันได้ถ้าเราเสร็จงานในรอบปัจจุบันแล้ว และต้องการข้ามไปทำรอบถัดไปเลย

วงวนด้านล่างใช้ `continue` เพื่อแสดงผลแค่ค่าคี่เท่านั้น:

```js run no-beautify
for (let i = 0; i < 10; i++) {

  // ถ้าเป็นจริง ให้ข้ามส่วนที่เหลือในรอบนี้
  *!*if (i % 2 == 0) continue;*/!*

  alert(i); // 1, แล้วก็ 3, 5, 7, 9
}
```

สำหรับค่า `i` ที่เป็นเลขคู่ คำสั่ง `continue` จะหยุดการทำงานในรอบปัจจุบันแล้วส่งการควบคุมไปเริ่มรอบถัดไปของ `for` (ด้วยตัวเลขถัดไป) ดังนั้น `alert` จะถูกเรียกเฉพาะสำหรับค่าคี่เท่านั้น

````smart header="คำสั่ง `continue` ช่วยลดการซ้อนโค้ด"
วงวนที่แสดงค่าคี่อาจเขียนได้แบบนี้:

```js run
for (let i = 0; i < 10; i++) {

  if (i % 2) {
    alert( i );
  }
  
}
```

ในแง่เทคนิค มันจะเหมือนกับตัวอย่างข้างบน แน่นอนว่าเราเพียงแค่ใส่โค้ดไว้ในบล็อก `if` แทนการใช้ `continue` ก็ได้

แต่มันก่อให้เกิดผลข้างเคียงคือเพิ่มระดับการซ้อนโค้ดอีกชั้น (เรียก `alert` ภายในปีกกาหลังเงื่อนไข) ถ้าโค้ดใน `if` ยาวกว่าสองสามบรรทัด มันอาจลดความสามารถในการอ่านโค้ดโดยรวม  
````

````warn header="ไม่มี `break/continue` ทางขวาของเครื่องหมาย '?'"
โปรดทราบว่าโครงสร้างทางไวยากรณ์ที่ไม่ใช่นิพจน์ ไม่สามารถใช้กับตัวดำเนินการ ternary `?` ได้ โดยเฉพาะอย่างยิ่ง คำสั่งอย่างเช่น `break/continue` จะใช้ไม่ได้

ตัวอย่างเช่น ถ้าเรามีโค้ดแบบนี้:

```js
if (i > 5) {
  alert(i);
} else {
  continue;
}  
```

...แล้วเขียนใหม่โดยใช้เครื่องหมายคำถาม:

```js no-beautify
(i > 5) ? alert(i) : *!*continue*/!*; // continue ใช้ที่นี่ไม่ได้
```

...มันจะไม่ทำงาน: จะเกิด syntax error

นี่เป็นอีกเหตุผลที่ไม่ควรใช้ตัวดำเนินการ `?` แทน `if`
````

## ป้ายกำกับสำหรับ break/continue

บางครั้งเราต้องการออกจากลูปที่ซ้อนกันหลายชั้นในครั้งเดียว

ตัวอย่างเช่น ในโค้ดด้านล่าง เราวนลูปด้วย `i` และ `j` พร้อมถามพิกัด `(i, j)` ตั้งแต่ `(0,0)` ถึง `(2,2)`:

```js run no-beautify
for (let i = 0; i < 3; i++) {

  for (let j = 0; j < 3; j++) {

    let input = prompt(`ค่าที่พิกัด (${i},${j})`, '');

    // จะทำอย่างไรถ้าเราต้องการออกจากที่นี่ไปยัง Done (ด้านล่าง)?
  }
}

alert('Done!');
```

เราต้องการวิธีหยุดกระบวนการ หากผู้ใช้ยกเลิกการป้อนข้อมูล

คำสั่ง `break` ปกติหลัง `input` จะออกจากลูป inner เท่านั้น ซึ่งยังไม่เพียงพอ -- ตอนนี้ป้ายกำกับมาช่วยเราได้!

*ป้ายกำกับ* คือตัวระบุที่มีเครื่องหมายทวิภาคนำหน้าลูป:

```js
labelName: for (...) {
  ...
}
```

คำสั่ง `break <labelName>` ในลูปด้านล่างจะออกไปยังป้ายกำกับ:

```js run no-beautify
*!*outer:*/!* for (let i = 0; i < 3; i++) {

  for (let j = 0; j < 3; j++) {

    let input = prompt(`ค่าที่พิกัด (${i},${j})`, '');

    // ถ้า string ว่างหรือยกเลิก จะออกจากลูปทั้งสอง 
    if (!input) *!*break outer*/!*; // (*)

    // ทำอะไรบางอย่างกับค่า...
  }
}

alert('Done!');
```

ในโค้ดข้างบน `break outer` จะค้นหาป้ายกำกับชื่อ `outer` ขึ้นไปและออกจากลูปนั้น

ดังนั้นการควบคุมจะข้ามจาก `(*)` ไปยัง `alert('Done!')` ทันที 

เราสามารถย้ายป้ายกำกับไปอยู่บนบรรทัดแยกต่างหากก็ได้:

```js no-beautify
outer:
for (let i = 0; i < 3; i++) { ... }  
```

คำสั่ง `continue` ก็ใช้กับป้ายกำกับได้เช่นกัน ในกรณีนี้ การทำงานของโค้ดจะข้ามไปยังรอบถัดไปของลูปที่ติดป้ายกำกับ

````warn header="ป้ายกำกับไม่อนุญาตให้ \"กระโดด\" ไปที่ไหนก็ได้"
ป้ายกำกับไม่อนุญาตให้เรากระโดดไปยังตำแหน่งใดๆ ในโค้ดตามใจชอบ

เช่น ไม่สามารถทำแบบนี้:

```js
break label; // กระโดดไปที่ป้ายกำกับด้านล่าง (ทำไม่ได้)

label: for (...)  
```

คำสั่ง `break` ต้องอยู่ในบล็อกโค้ด โดยทั่วไปแล้ว บล็อกโค้ดใดๆ ที่มีป้ายกำกับก็ใช้ได้ เช่น:

```js
label: {
  // ...
  break label; // ใช้ได้
  // ...  
}
```

...ถึงแม้ว่า 99.9% ของเวลา `break` จะใช้ในลูป ตามที่เราเห็นในตัวอย่างข้างบน

`continue` ใช้ได้เฉพาะข้างในลูปเท่านั้น  
````

## สรุป

เราได้เรียนรู้ลูป 3 ประเภท:

- `while` -- ตรวจสอบเงื่อนไขก่อนแต่ละรอบ
- `do..while` -- ตรวจสอบเงื่อนไขหลังแต่ละรอบ
- `for (;;)` -- ตรวจสอบเงื่อนไขก่อนแต่ละรอบ พร้อมตั้งค่าเพิ่มเติมได้

โดยทั่วไป เพื่อสร้างลูป "ไม่มีที่สิ้นสุด" จะใช้ `while(true)` ลูปแบบนี้เหมือนลูปอื่นๆ คือสามารถหยุดได้ด้วยคำสั่ง `break`

ถ้าเราไม่ต้องการทำอะไรในรอบปัจจุบัน และต้องการข้ามไปทำรอบถัดไป เราสามารถใช้คำสั่ง `continue`

`break/continue` รองรับป้ายกำกับไว้ข้างหน้าลูป ป้ายกำกับเป็นวิธีเดียวที่ `break/continue` จะออกจากลูปที่ซ้อนเพื่อไปยังลูปด้านนอกได้