# การเปรียบเทียบใน JavaScript

ในวิชาคณิตศาสตร์ เรารู้จักเครื่องหมายเปรียบเทียบต่างๆ มากมาย ซึ่งใน JavaScript ก็มีวิธีเขียนคล้ายกันดังนี้

- มากกว่า/น้อยกว่า: <code>a &gt; b</code>, <code>a &lt; b</code>
- มากกว่าหรือเท่ากับ/น้อยกว่าหรือเท่ากับ: <code>a &gt;= b</code>, <code>a &lt;= b</code> 
- เท่ากับ: `a == b` โปรดสังเกตว่าต้องใช้เครื่องหมายเท่ากับสองตัว `==` ในการเปรียบเทียบ ส่วนเครื่องหมาย `=` ตัวเดียวใช้สำหรับการกำหนดค่า  
- ไม่เท่ากับ: ในเชิงคณิตศาสตร์จะใช้สัญลักษณ์ <code>&ne;</code> แต่สำหรับ JavaScript จะเขียนเป็น <code>a != b</code>

ในบทความนี้ เราจะมาเรียนรู้เพิ่มเติมเกี่ยวกับการเปรียบเทียบประเภทต่างๆ วิธีที่ JavaScript ทำการเปรียบเทียบ รวมถึงข้อควรระวังที่สำคัญ

ในท้ายบทความ คุณจะพบเทคนิคดีๆ ในการหลีกเลี่ยงปัญหาที่อาจเกิดขึ้นจากความแปลกของภาษา JavaScript

## ผลลัพธ์เป็นแบบบูลีน 

เครื่องหมายเปรียบเทียบทั้งหมดจะให้ผลลัพธ์เป็นค่าบูลีน:

- `true` แปลว่า "ใช่" "ถูกต้อง" หรือ "เป็นความจริง"  
- `false` แปลว่า "ไม่ใช่" "ผิด" หรือ "ไม่เป็นความจริง"

ตัวอย่างเช่น

```js run
alert( 2 > 1 );  // true (ถูกต้อง)
alert( 2 == 1 ); // false (ผิด) 
alert( 2 != 1 ); // true (ถูกต้อง)
```

ผลลัพธ์จากการเปรียบเทียบสามารถเก็บในตัวแปรได้เหมือนกับการกำหนดค่าทั่วไป:

```js run
let result = 5 > 4; // เก็บผลการเปรียบเทียบลงตัวแปร
alert( result ); // true 
```
## การเปรียบเทียบสตริง

เพื่อตรวจสอบว่าสตริงหนึ่งมากกว่าอีกสตริงหนึ่งหรือไม่ JavaScript ใช้การเรียงลำดับแบบ "พจนานุกรม" หรือ "ตามตัวอักษร" 

หรือพูดอีกอย่างคือ สตริงจะถูกเปรียบเทียบทีละอักขระ

ยกตัวอย่างเช่น

```js run
alert( 'Z' > 'A' ); // true
alert( 'Glow' > 'Glee' ); // true
alert( 'Bee' > 'Be' ); // true
```

ขั้นตอนวิธีในการเปรียบเทียบสตริงสองตัวนั้นเข้าใจง่าย:

1. เปรียบเทียบอักขระตัวแรกของทั้งสองสตริง
2. ถ้าอักขระตัวแรกของสตริงแรกมากกว่า (หรือน้อยกว่า) สตริงอีกตัว แสดงว่าสตริงแรกมากกว่า (หรือน้อยกว่า) สตริงที่สอง เราได้ผลลัพธ์แล้ว
3. ถ้าอักขระตัวแรกของทั้งสองสตริงเท่ากัน ให้เปรียบเทียบอักขระที่สองด้วยวิธีเดียวกัน
4. ทำซ้ำจนถึงอักขระสุดท้ายของสตริงใดสตริงหนึ่ง 
5. ถ้าสตริงทั้งสองมีความยาวเท่ากัน ก็แสดงว่าเท่ากัน มิฉะนั้นสตริงที่ยาวกว่าจะมากกว่า

ในตัวอย่างแรกข้างต้น การเปรียบเทียบ `'Z' > 'A'` จะได้ผลลัพธ์ตั้งแต่ขั้นตอนแรก

การเปรียบเทียบที่สองระหว่าง `'Glow'` และ `'Glee'` ต้องใช้ขั้นตอนมากกว่าเพราะสตริงถูกเปรียบเทียบอักขระต่ออักขระ:

1. `G` เท่ากับ `G`
2. `l` เท่ากับ `l`
3. `o` มากกว่า `e` หยุดตรงนี้ สตริงแรกมากกว่า

```smart header="ไม่ใช่พจนานุกรมจริงๆ แต่เรียงตาม Unicode"
ขั้นตอนวิธีสำหรับเปรียบเทียบที่ให้มาข้างต้นนั้นใกล้เคียงกับที่ใช้ในพจนานุกรมหรือสมุดโทรศัพท์ แต่ก็ไม่เหมือนกันทีเดียว 

ยกตัวอย่างเช่น ตัวพิมพ์ใหญ่/เล็กมีผล ตัวพิมพ์ใหญ่ `"A"` จะไม่เท่ากับตัวพิมพ์เล็ก `"a"` แล้วอันไหนมากกว่า? ตัวพิมพ์เล็ก `"a"` ทำไมน่ะหรือ? เพราะอักขระตัวพิมพ์เล็กมีค่าดัชนีในตารางการเข้ารหัสภายในที่ JavaScript ใช้ (Unicode) สูงกว่านั่นเอง เราจะกลับมาดูรายละเอียดและผลกระทบของเรื่องนี้ในบท <info:string>
```

## ความเท่ากันแบบเคร่งครัด

การตรวจสอบความเท่ากันแบบปกติด้วย `==` นั้นมีปัญหา คือไม่สามารถแยกความแตกต่างระหว่าง `0` กับ `false` ได้:

```js run
alert( 0 == false ); // true
```

สถานการณ์เดียวกันนี้เกิดขึ้นกับสตริงว่าง:

```js run
alert( '' == false ); // true
```

ที่เป็นเช่นนี้เพราะตัวถูกดำเนินการที่มีชนิดข้อมูลแตกต่างกันจะถูกแปลงเป็นตัวเลขโดยตัวดำเนินการความเท่ากัน `==` สตริงว่างและ `false` จะกลายเป็นศูนย์ทั้งคู่

แล้วถ้าเราต้องการแยกความแตกต่างระหว่าง `0` กับ `false` ล่ะ จะทำอย่างไร?

**ตัวดำเนินการความเท่ากันแบบเคร่งครัด `===` จะตรวจสอบความเท่ากันโดยไม่มีการแปลงชนิดข้อมูล**

อีกนัยหนึ่งคือ ถ้า `a` และ `b` มีชนิดข้อมูลไม่เหมือนกัน การเปรียบเทียบ `a === b` จะคืนค่า `false` ทันทีโดยไม่พยายามแปลงชนิดข้อมูลก่อน

มาลองดูตัวอย่าง:

```js run  
alert( 0 === false ); // false เพราะเป็นคนละชนิดข้อมูล
```

นอกจากนี้ยังมีตัวดำเนินการ "ไม่เท่ากันแบบเคร่งครัด" `!==` คล้ายกับ `!=`

ตัวดำเนินการความเท่ากันแบบเคร่งครัดนั้นต้องเขียนยาวกว่านิดหน่อย แต่ช่วยให้เห็นได้ชัดเจนว่ากำลังเกิดอะไรขึ้นและลดโอกาสผิดพลาดได้
