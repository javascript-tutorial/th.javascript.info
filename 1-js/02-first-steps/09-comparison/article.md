## การเปรียบเทียบ

เราทุกคนรู้จักตัวดำเนินการเปรียบเทียบจากวิชาคณิตศาสตร์กันอยู่แล้ว

ใน JavaScript ตัวดำเนินการเปรียบเทียบเขียนแบบนี้:

- มากกว่า/น้อยกว่า: `a &gt; b`, `a &lt; b`.
- มากกว่า/น้อยกว่าหรือเท่ากับ: `a &gt;= b`, `a &lt;= b`.
- เท่ากับ: `a == b`, โปรดทราบว่าเครื่องหมายเท่ากับสองตัว `==` หมายถึงการทดสอบความเท่ากับ ในขณะที่เครื่องหมายเท่ากับตัวเดียว `a = b` หมายถึงการกำหนดค่า
- ไม่เท่ากับ: ในคณิตศาสตร์ใช้สัญลักษณ์ `&ne;` แต่ใน JavaScript เขียนเป็น `a != b`

ในบทความนี้ เราจะเรียนรู้เพิ่มเติมเกี่ยวกับประเภทของการเปรียบเทียบที่แตกต่างกัน ว่า JavaScript เปรียบเทียบอย่างไร รวมถึงความแปลกประหลาดที่สำคัญ

ในตอนท้าย คุณจะได้พบกับสูตรเด็ดในการหลีกเลี่ยงปัญหาที่เกี่ยวข้องกับ "JavaScript Quirks"

## เปรียบเทียบแล้วได้บูลีน (Boolean)

ตัวดำเนินการเปรียบเทียบทั้งหมดจะส่งคืนค่า **บูลีน (Boolean)**:

- `true` -- หมายถึง "ใช่" "ถูกต้อง" หรือ "ความจริง"
- `false` -- หมายถึง "ไม่ใช่" "ผิด" หรือ "ไม่ใช่ความจริง"

ตัวอย่างเช่น:

```js run
alert( 2 > 1 );  // true (ใช่)
alert( 2 == 1 ); // false (ไม่ใช่)
alert( 2 != 1 ); // true (ใช่)
```

ผลลัพธ์ของการเปรียบเทียบสามารถกำหนดให้กับตัวแปรได้เช่นเดียวกับค่าอื่นๆ:

```js run
let result = 5 > 4; // กำหนดผลลัพธ์ของการเปรียบเทียบ
alert( result ); // true
```

## เปรียบเทียบสตริง (String)

เพื่อดูว่าสตริงหนึ่งมากกว่าอีกสตริงหนึ่งหรือไม่ JavaScript ใช้ลำดับที่เรียกว่า "พจนานุกรม" หรือ "lexicographical"

กล่าวอีกนัยหนึ่ง สตริงจะถูกเปรียบเทียบทีละตัวอักษร

ตัวอย่างเช่น:

```js run
alert( 'Z' > 'A' ); // true
alert( 'Glow' > 'Glee' ); // true
alert( 'Bee' > 'Be' ); // true
```

ขั้นตอนการเปรียบเทียบสตริงสองสตริงทำได้ง่ายๆ ดังนี้:

1. เปรียบเทียบตัวอักษรตัวแรกของทั้งสองสตริง
2. ถ้าตัวอักษรตัวแรกของสตริงแรกมากกว่า (หรือน้อยกว่า) ตัวอักษรของอีกสตริง แสดงว่าสตริงแรกมากกว่า (หรือน้อยกว่า) สตริงที่สอง เสร็จเรียบร้อย
3. มิฉะนั้น ถ้าตัวอักษรตัวแรกของทั้งสองสตริงเหมือนกัน ให้เปรียบเทียบตัวอักษรตัวที่สองเช่นเดียวกัน
4. ทำซ้ำจนกว่าจะถึงจุดสิ้นสุดของสตริงใดสตริงหนึ่ง
5. ถ้าทั้งสองสตริงจบลงที่ความยาวเท่ากัน แสดงว่าทั้งสองสตริงเท่ากัน มิฉะนั้น สตริงที่ยาวกว่าจะใหญ่กว่า

ในตัวอย่างแรกข้างต้น การเปรียบเทียบ `'Z' > 'A'` จะได้ผลลัพธ์ในขั้นตอนแรก

การเปรียบเทียบที่สอง `'Glow'` และ `'Glee'` ต้องใช้ขั้นตอนเพิ่มเติมเนื่องจากสตริงถูกเปรียบเทียบทีละตัวอักษร:

1. `G` เหมือนกับ `G`
2. `l` เหมือนกับ `l`
3. `o` มากกว่า `e` หยุดตรงนี้. สตริงแรกมากกว่า

```smart header="ไม่ใช่พจนานุกรมจริงๆ แต่เป็นลำดับ Unicode"
ขั้นตอนการเปรียบเทียบที่ให้ไว้ข้างต้นนั้นเทียบเท่ากับที่ใช้ในพจนานุกรมหรือสมุดโทรศัพท์ แต่ไม่เหมือนกันซะทีเดียว

ตัวอย่างเช่น ตัวพิมพ์ใหญ่มีผล ตัวพิมพ์ใหญ่ `"A"` ไม่เท่ากับตัวพิมพ์เล็ก `"a"` ตัวไหนใหญ่กว่า? ตัวพิมพ์เล็ก `"a"`. ทำไม? เนื่องจากตัวอักษรตัวเล็กมีดัชนีที่สูงกว่าในตารางการเข้ารหัสภายในที่ JavaScript ใช้ (Unicode) เราจะกลับมาดูรายละเอียดและผลที่ตามมาของเรื่องนี้ในบท <info:string>.
```

## เปรียบเทียบคนละแบบ (Comparison of different types)

เวลาเปรียบเทียบค่าคนละแบบ JavaScript จะแปลงค่าเหล่านั้นเป็นตัวเลขเหมือนทำเวทมนตร์!

ตัวอย่างเช่น:

```js run
alert( '2' > 1 ); // true, string '2' becomes a number 2
alert( '01' == 1 ); // true, string '01' becomes a number 1
```

สำหรับค่าบูลีน `true` จะกลายเป็น `1` และ `false` จะกลายเป็น `0` เหมือนการเปิดไฟ (true) กับปิดไฟ (false)

For example:

```js run
alert( true == 1 ); // true
alert( false == 0 ); // true
```

````smart header="สนุกกับผลลัพธ์"
บางครั้งอาจเกิดขึ้นพร้อมกัน:

- สองค่าเท่ากัน
- หนึ่งในนั้นเป็น `true` อีกอันเป็น `false`

ตัวอย่างเช่น:

```js run
let a = 0;
alert( Boolean(a) ); // false

let b = "0";
alert( Boolean(b) ); // true

alert(a == b); // true!
```

จากมุมมองของ JavaScript ผลลัพธ์นี้ค่อนข้างปกติ การตรวจสอบความเท่ากันจะแปลงค่าโดยใช้การแปลงตัวเลข (ดังนั้น `"0"` จึงกลายเป็น `0`) ในขณะที่การแปลง `Boolean` อย่างชัดเจนใช้อีกชุดของกฎ
````

## เปรียบเทียบแบบเข้มงวด (Strict equality)

เปรียบเทียบแบบธรรมดาๆ `==` มีปัญหาอยู่! มันแยกความแตกต่างระหว่าง `0` กับ `false` ไม่ได้

```js run
alert( 0 == false ); // true
```

เหมือนตาบอดสีเลย!

ก็มันแปลง `0` กับ `false` ให้กลายเป็นตัวเลขเหมือนกันซะนี่

```js run
alert( '' == false ); // true
```

เอาไงดีล่ะถ้าอยากแยก `0` กับ `false` ออกจากกัน?

**ใช้การเปรียบเทียบแบบเข้มงวด `===` สิ!**

ตัวดำเนินการนี้เปรียบเทียบแบบละเอียด ไม่ต้องแปลงชนิดข้อมูล

พูดอีกอย่างก็คือ ถ้า `a` กับ `b` มีชนิดข้อมูลต่างกัน `a === b` จะรีบส่งคืน `false` ทันทีแบบไม่ต้องพยายามแปลง

ลองดู:

```js run
alert( 0 === false ); // false เพราะชนิดข้อมูลต่างกัน
```

นอกจากนี้ยังมีตัวดำเนินการ "ไม่เท่าเทียมแบบเข้มงวด" `!==` ที่คล้ายกับ `!=`

ตัวดำเนินการความเท่าเทียมแบบเข้มงวดเขียนยาวกว่าเล็กน้อย แต่ทำให้เห็นได้ชัดว่าเกิดอะไรขึ้นและมีโอกาสเกิดข้อผิดพลาดน้อยลง

## เปรียบเทียบกับ null และ undefined

เดี๋ยวๆๆๆๆ มีเรื่องตลกๆ เกี่ยวกับการเปรียบเทียบ `null` และ `undefined` กับค่าอื่นๆ นะ

**เปรียบเทียบแบบเข้มงวด `===`**

สองคนนี้ต่างกันนะ เพราะคนละชนิดกัน

    ```js run
    alert( null === undefined ); // false
    ```

**เปรียบเทียบแบบธรรมดา `==`**

อุ๊ย! มีกฎลับ! สองคนนี้เป็น "คู่รักสุดคิ้วท์": เท่ากัน (ตาม `==`) แต่ไม่เท่ากับค่าอื่นๆ นะ

    ```js run
    alert( null == undefined ); // true
    ```

**เปรียบเทียบแบบอื่นๆ `< > <= >=`**

`null` และ `undefined` จะถูกแปลงเป็นตัวเลข: `null` เป็น `0`, `undefined` เป็น `NaN` (Not a Number)

เดี๋ยวมาดูเรื่องตลกๆ ที่เกิดขึ้นจากกฎเหล่านี้กัน และที่สำคัญกว่านั้น เราจะไม่พลาดท่ากับกฎเหล่านี้อย่างไร

### สับสนงงงวย: null vs 0

ลองเปรียบเทียบ `null` กับ 0 กัน:

```js run
alert( null > 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null >= 0 ); // (3) *!*true*/!*
```

งงดิ! ผลลัพธ์สุดท้ายบอกว่า `null` มากกว่าหรือน้อยกว่าหรือเท่ากับ "0" ดังนั้นในการเปรียบเทียบข้างต้นอย่างน้อยหนึ่งข้อควรเป็น `true` แต่ดันเป็น `false` ทั้งคู่

สาเหตุคือการตรวจสอบความเท่าเทียม `==` และการเปรียบเทียบ `> < >= <=` ทำงานแตกต่างกัน การเปรียบเทียบจะแปลง `null` เป็นตัวเลข โดยพิจารณาว่าเป็น `0` นั่นคือเหตุผลที่ (3) `null >= 0` เป็น `true` และ (1) `null > 0` เป็น `false`

ในทางกลับกัน การตรวจสอบความเท่าเทียม `==` สำหรับ `undefined` และ `null` ถูกกำหนดไว้ในลักษณะที่ ไม่ต้องแปลงใดๆ ก็เท่ากัน และไม่เท่ากับอะไรอื่น นั่นคือเหตุผลที่ (2) `null == 0` เป็น `false`

## undefined จอมไม่เข้าใครออกใคร

เจ้า `undefined` นี่มันไม่ชอบเปรียบเทียบกับใครเลยจริงๆ:

```js run
alert( undefined > 0 ); // false (1)
alert( undefined < 0 ); // false (2)
alert( undefined == 0 ); // false (3)
```

ทำไมมันถึงไม่ชอบเลข 0 ขนาดนั้น? เจออะไรก็ `false`

เหตุผลที่เราได้ผลลัพธ์เหล่านี้ก็คือ:

- การเปรียบเทียบ `(1)` และ `(2)` ส่งคืน `false` เพราะ `undefined` ถูกแปลงเป็น `NaN` และ `NaN` เป็นค่าตัวเลขพิเศษที่ส่งคืน `false` สำหรับการเปรียบเทียบทั้งหมด
- การตรวจสอบความเท่าเทียม `(3)` ส่งคืน `false` เพราะ `undefined` เท่ากับ `null`, `undefined` และไม่มีค่าอื่นใด

##  ข้อควรระวัง

เราเรียนรู้เรื่องพวกนี้ไปทำไม? เราต้องจำไว้ทุกอย่างเลยเหรอ? ไม่จำเป็นหรอก! ยิ่งใช้ JavaScript ไปเรื่อยๆ เดี๋ยวก็ชินกับความแปลกๆ เหล่านี้เอง แต่มีวิธีที่แน่นอนในการหลีกเลี่ยงปัญหา:

- ระมัดระวังเป็นพิเศษเมื่อเปรียบเทียบค่าอะไรก็ตามกับ `undefined/null` ยกเว้นการเปรียบเทียบแบบเข้มงวด `===`
- อย่าใช้การเปรียบเทียบ `>= > < <=` กับตัวแปรที่อาจเป็น `null/undefined` เว้นแต่คุณจะมั่นใจจริงๆ ว่าคุณกำลังทำอะไรอยู่ ถ้าตัวแปรอาจมีค่าเหล่านี้ ให้ตรวจสอบแยกต่างหาก

## สรุป

- ตัวดำเนินการเปรียบเทียบจะส่งคืนค่าบูลีน
- สตริงจะถูกเปรียบเทียบทีละตัวอักษรตามลำดับ "พจนานุกรม"
- เมื่อเปรียบเทียบค่าที่มีประเภทข้อมูลต่างกัน ค่าเหล่านั้นจะถูกแปลงเป็นตัวเลข (ยกเว้นการเปรียบเทียบแบบเข้มงวด)
- ค่า `null` และ `undefined` เท่ากัน `==` กันเองและไม่เท่ากับค่าอื่นใด
- ระมัดระวังเมื่อใช้การเปรียบเทียบ เช่น `>` หรือ `<` กับตัวแปรที่อาจเป็น `null/undefined` เป็นครั้งคราว การตรวจสอบ `null/undefined` แยกต่างหากเป็นแนวคิดที่ดี
