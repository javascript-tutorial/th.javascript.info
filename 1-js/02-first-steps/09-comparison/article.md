# การเปรียบเทียบ

เรารู้จักเครื่องหมายเปรียบเทียบ9y;อย่างจากคณิตศาสตร์

ใน JavaScript เขียนได้ดังนี้:

- มากกว่า/น้อยกว่า: <code>a &gt; b</code>, <code>a &lt; b</code>
- มากกว่าหรือเท่ากับ/น้อยกว่าหรือเท่ากับ: <code>a &gt;= b</code>, <code>a &lt;= b</code>
- เท่ากับ: `a == b` สังเกตว่าต้องใช้เครื่องหมายเท่ากับสองตัว `==` สำหรับการเช็คความเท่ากัน ส่วนเครื่องหมายเดียว `a = b` ใช้สำหรับการกำหนดค่า
- ไม่เท่ากับ: ในเชิงคณิตศาสตร์ใช้สัญลักษณ์ <code>&ne;</code> แต่ใน JavaScript เขียนเป็น <code>a != b</code>

ในบทความนี้ เราจะเรียนรู้เพิ่มเติมเกี่ยวกับการเปรียบเทียบแบบต่างๆ วิธีที่ JavaScript เปรียบเทียบ รวมถึงข้อควรระวังสำคัญ 

ท้ายบทความมีเคล็ดลับดีๆ ในการหลีกเลี่ยงปัญหาที่มักพบใน JavaScript

## ผลลัพธ์เป็น Boolean

ผลการเปรียบเทียบทั้งหมดจะให้ค่า boolean:

- `true` หมายถึง "ใช่" "ถูกต้อง" หรือ "จริง"
- `false` หมายถึง "ไม่" "ไม่ถูกต้อง" หรือ "ไม่จริง" 

ตัวอย่างเช่น:

```js run
alert( 2 > 1 );  // true (ถูก)
alert( 2 == 1 ); // false (ไม่ถูก)
alert( 2 != 1 ); // true (ถูก)
```

ผลการเปรียบเทียบสามารถเก็บในตัวแปรได้ เหมือนกับค่าอื่นๆ:

```js run
let result = 5 > 4; // เก็บผลการเปรียบเทียบ
alert( result ); // true
```

## การเปรียบเทียบ string

ในการเช็คว่า string อันหนึ่งมากกว่าอีกอันหรือไม่ JavaScript ใช้การเรียงลำดับแบบ "พจนานุกรม" หรือ "ตามตัวอักษร"

หรือพูดง่ายๆ คือเปรียบเทียบ string ทีละตัวอักษร

ตัวอย่างเช่น:

```js run
alert( 'Z' > 'A' ); // true
alert( 'Glow' > 'Glee' ); // true
alert( 'Bee' > 'Be' ); // true 
```

ขั้นตอนในการเปรียบเทียบ string สองอันมีดังนี้:

1. เปรียบเทียบตัวอักษรตัวแรกของ string ทั้งสองอัน
2. ถ้าตัวอักษรตัวแรกจาก string แรกมากกว่า (หรือน้อยกว่า) string ที่สอง แสดงว่า string แรกมากกว่า (หรือน้อยกว่า) string ที่สอง จบการทำงาน
3. ถ้าตัวอักษรตัวแรกของ string ทั้งสองเหมือนกัน ให้เปรียบเทียบตัวอักษรที่สองแบบเดียวกัน  
4. ทำซ้ำไปเรื่อยๆ จนกว่าจะเจอตัวอักษรที่แตกต่างกันหรือจนหมด string
5. ถ้าหมด string พร้อมกันที่ความยาวเท่ากัน แปลว่าเท่ากัน ไม่อย่างนั้น string ที่ยาวกว่าจะมากกว่า

ในตัวอย่างแรกข้างบน การเปรียบเทียบ `'Z' > 'A'` ให้ผลลัพธ์ตั้งแต่ขั้นตอนแรก

การเปรียบเทียบที่สองระหว่าง `'Glow'` กับ `'Glee'` ต้องใช้หลายขั้นตอนมากกว่า โดยเปรียบเทียบตัวอักษรทีละตัว:

1. `G` เท่ากับ `G`
2. `l` เท่ากับ `l`
3. `o` มากกว่า `e` หยุดตรงนี้ string แรกมากกว่า

```smart header="ไม่ใช่พจนานุกรมจริงๆ แต่เป็นลำดับ Unicode"
ขั้นตอนการเปรียบเทียบข้างต้นคล้ายกับที่ใช้ในพจนานุกรมหรือสมุดโทรศัพท์ แต่ไม่เหมือนกันทีเดียว

เช่น ตัวพิมพ์ใหญ่เล็กมีผล `"A"` ไม่เท่ากับ `"a"` ตัวไหนมากกว่า? `"a"` เพราะมันมีค่าดัชนีที่สูงกว่าในตารางเข้ารหัสภายใน (Unicode) ที่ JavaScript ใช้ เราจะกลับมาดูรายละเอียดและผลที่ตามมาในบท <info:string>
```

## การเปรียบเทียบข้อมูลต่างชนิด

เมื่อเปรียบเทียบค่าที่มีชนิดต่างกัน JavaScript จะแปลงค่าเป็นตัวเลขก่อน

ตัวอย่างเช่น:

```js run
alert( '2' > 1 ); // true, string '2' จะถูกแปลงเป็นตัวเลข 2
alert( '01' == 1 ); // true, string '01' จะถูกแปลงเป็นตัวเลข 1
```

สำหรับค่า boolean `true` จะกลายเป็น `1` และ `false` จะกลายเป็น `0`

ตัวอย่างเช่น:

```js run
alert( true == 1 ); // true  
alert( false == 0 ); // true
```

````smart header="ผลลัพธ์ที่แปลกประหลาด"
มันเป็นไปได้ว่าในเวลาเดียวกัน:

- สองค่านั้นเท่ากัน
- แต่ค่าหนึ่งเป็น `true` เมื่อแปลงเป็น boolean ส่วนอีกค่าเป็น `false` เมื่อแปลงเป็น boolean

ตัวอย่างเช่น:

```js run
let a = 0;
alert( Boolean(a) ); // false

let b = "0"; 
alert( Boolean(b) ); // true

alert(a == b); // true!
```

จากมุมมองของ JavaScript ผลลัพธ์นี้ถือว่าปกติ การเช็คความเท่ากันจะแปลงค่าโดยใช้การแปลงเป็นตัวเลข (ทำให้ `"0"` เป็น `0`) ในขณะที่การแปลงเป็น `Boolean` โดยตรงใช้ชุดกฎที่แตกต่างกัน
````

## ความเท่าเทียมกันอย่างเข้มงวด

การตรวจสอบความเท่าเทียมกันแบบปกติด้วย `==` มีปัญหาคือไม่สามารถแยกแยะความแตกต่างระหว่าง `0` กับ `false` ได้:

```js run
alert( 0 == false ); // true
```

เหตุการณ์เดียวกันนี้เกิดขึ้นกับ string ว่างด้วย:

```js run 
alert( '' == false ); // true
```

สิ่งนี้เกิดขึ้นเพราะเมื่อเปรียบเทียบข้อมูลคนละชนิดด้วยเครื่องหมาย `==` JavaScript จะแปลงชนิดข้อมูลเป็นตัวเลขก่อน ทั้ง string ว่างและ `false` จะถูกแปลงเป็นศูนย์

แล้วถ้าเราอยากแยกแยะความแตกต่างระหว่าง `0` กับ `false` ล่ะ จะทำอย่างไร?

**เครื่องหมายเท่ากันอย่างเข้มงวด `===` จะเปรียบเทียบความเท่าเทียมกันโดยไม่แปลงชนิดข้อมูล**

อีกนัยหนึ่ง ถ้า `a` และ `b` เป็นคนละชนิดกัน `a === b` จะคืนค่า `false` ทันที โดยไม่พยายามแปลงชนิดข้อมูล

ลองดูตัวอย่าง:

```js run
alert( 0 === false ); // false เพราะเป็นคนละชนิดกัน  
```

นอกจากนี้ยังมีเครื่องหมาย "ไม่เท่ากันอย่างเข้มงวด" `!==` ที่คล้ายกับ `!=` ด้วย

การใช้เครื่องหมายเท่ากันแบบเข้มงวดอาจเขียนยาวขึ้นหน่อย แต่จะทำให้เห็นชัดเจนว่าเกิดอะไรขึ้นและลดโอกาสเกิดข้อผิดพลาดได้มากกว่า

## การเปรียบเทียบกับ null และ undefined

เมื่อ `null` หรือ `undefined` ถูกนำมาเปรียบเทียบกับค่าอื่นๆ อาจเกิดพฤติกรรมที่ไม่ตรงกับความคาดหมายเสมอไป

สำหรับการตรวจสอบความเท่ากันอย่างเข้มงวดด้วย `===`:
: ค่าเหล่านี้แตกต่างกัน เพราะแต่ละค่ามีประเภทข้อมูลต่างกัน

```js run
alert( null === undefined ); // false
```

สำหรับการตรวจสอบความเท่ากันแบบไม่เข้มงวดด้วย `==`:
: มีกฎพิเศษ ค่าทั้งสองนี้เป็น "คู่รักในฝัน" คือเท่ากันในแง่ของ `==` แต่ไม่เท่ากับค่าอื่นใด

```js run
alert( null == undefined ); // true
```  

สำหรับการคำนวณทางคณิตศาสตร์และการเปรียบเทียบอื่นๆ `< > <= >=`:
: `null/undefined` จะถูกแปลงเป็นตัวเลข โดย `null` เป็น `0` และ `undefined` เป็น `NaN` 

เรามาดูเหตุการณ์แปลกๆ ที่เกิดขึ้นเมื่อใช้กฎเหล่านี้ และที่สำคัญกว่านั้น คือเราจะหลีกเลี่ยงกับดักเหล่านี้ได้อย่างไร

### ผลลัพธ์ประหลาด: null เทียบกับ 0

ลองเปรียบเทียบ `null` กับศูนย์ดู:

```js run
alert( null > 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null >= 0 ); // (3) *!*true*/!*  
```

ทางคณิตศาสตร์แล้วมันแปลกมาก ผลลัพธ์สุดท้ายบอกว่า "`null` มากกว่าหรือเท่ากับศูนย์" ดังนั้นในการเปรียบเทียบข้างต้นต้องมีอย่างน้อยหนึ่งค่าเป็น `true` แต่กลับเป็น false ทั้งคู่

สาเหตุคือ การตรวจสอบความเท่ากันด้วย `==` และการเปรียบเทียบ `> < >= <=` ทำงานต่างกัน การเปรียบเทียบจะแปลง `null` เป็นตัวเลขและถือว่าเป็น `0` นั่นเป็นเหตุผลที่ (3) `null >= 0` เป็น true และ (1) `null > 0` เป็น false

ในทางกลับกัน การตรวจสอบความเท่ากันด้วย `==` ระหว่าง `undefined` กับ `null` นั้นถูกกำหนดไว้ว่า หากไม่มีการแปลงประเภท มันจะเท่ากันเองเท่านั้นและไม่เท่ากับค่าอื่นใด นั่นเป็นเหตุผลที่ (2) `null == 0` เป็น false

### undefined ไม่สามารถเปรียบเทียบได้

เราไม่ควรนำค่า `undefined` ไปเปรียบเทียบกับค่าอื่นๆ:

```js run
alert( undefined > 0 ); // false (1)
alert( undefined < 0 ); // false (2) 
alert( undefined == 0 ); // false (3)
```

ทำไม `undefined` ถึงเกลียดศูนย์ขนาดนั้น จนเป็น false ตลอด!

เพราะว่า:

- การเปรียบเทียบ `(1)` และ `(2)` ให้ค่า `false` เพราะ `undefined` ถูกแปลงเป็น `NaN` ซึ่ง `NaN` เป็นค่าตัวเลขพิเศษที่ให้ผลเป็น `false` เสมอเมื่อเปรียบเทียบ
- การตรวจสอบความเท่ากัน `(3)` ให้ค่า `false` เพราะ `undefined` จะเท่ากับ `null` และ `undefined` เท่านั้น ไม่เท่ากับค่าอื่น

### หลีกเลี่ยงปัญหา

ทำไมเราถึงยกตัวอย่างเหล่านี้? เราจำเป็นต้องจำความพิเศษเหล่านี้ตลอดเวลาหรือ? ไม่จำเป็นหรอก จริงๆ แล้วสิ่งที่ดูยุ่งยากเหล่านี้จะค่อยๆ คุ้นเคยไปเองตามเวลา แต่มีวิธีที่ดีกว่าในการหลีกเลี่ยงปัญหาพวกนี้:

- ระมัดระวังเป็นพิเศษเมื่อเปรียบเทียบกับ `undefined/null` ยกเว้นการตรวจสอบความเท่ากันแบบเข้มงวดด้วย `===`
- อย่าใช้การเปรียบเทียบ `>= > < <=` กับตัวแปรที่อาจเป็น `null/undefined` เว้นแต่คุณจะมั่นใจว่าตัวเองกำลังทำอะไร ถ้าตัวแปรอาจมีค่าเหล่านี้ได้ ให้ตรวจสอบ `null/undefined` แยกต่างหาก

## สรุป

- ตัวดำเนินการเปรียบเทียบให้ค่าเป็น boolean
- การเปรียบเทียบ string จะเปรียบเทียบทีละตัวอักษรตามลำดับ "พจนานุกรม"
- เมื่อเปรียบเทียบค่าต่างประเภทกัน ค่าจะถูกแปลงเป็นตัวเลข (ยกเว้นการตรวจสอบความเท่ากันอย่างเข้มงวด) 
- ค่า `null` และ `undefined` เท่ากันเฉพาะเมื่อใช้ `==` และไม่เท่ากับค่าอื่นใดทั้งสิ้น
- ระมัดระวังเมื่อใช้การเปรียบเทียบ เช่น `>` หรือ `<` กับตัวแปรที่อาจเป็น `null/undefined` ได้ บางครั้งการตรวจสอบ `null/undefined` แยกต่างหากถือเป็นแนวทางที่ดี