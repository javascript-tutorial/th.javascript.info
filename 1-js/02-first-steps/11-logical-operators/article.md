# ตัวดำเนินการตรรกะ 

ใน JavaScript มีตัวดำเนินการตรรกะ 4 ตัว ได้แก่ `||` (OR), `&&` (AND), `!` (NOT) และ `??` (Nullish Coalescing) ในที่นี้จะอธิบายเฉพาะ 3 ตัวแรก ส่วนตัว `??` จะอยู่ในบทความถัดไป

แม้จะเรียกว่า "ตรรกะ" แต่ก็สามารถใช้กับค่าประเภทอื่นๆ นอกเหนือจาก boolean ได้ และผลลัพธ์ที่ออกมาก็เป็นประเภทอะไรก็ได้เช่นกัน

มาดูรายละเอียดกัน

## || (OR)

เครื่องหมาย "OR" จะแทนด้วยสัญลักษณ์เส้นตั้งคู่ `||` แบบนี้:

```js
result = a || b;
```

โดยทั่วไปแล้ว OR ตรรกะมีไว้ใช้กับค่า boolean เท่านั้น ถ้ามี argument ตัวใดเป็น `true` ก็จะคืนค่า `true` ถ้าไม่มีเลยจะคืนค่า `false`

แต่ใน JavaScript นั้นตัวดำเนินการ OR มีความซับซ้อนและมีพลังมากกว่านั้นหน่อย แต่ก่อนอื่นมาดูว่าเกิดอะไรขึ้นกับค่า boolean ก่อน

จะมีเคสที่เป็นไปได้ 4 แบบ:

```js run
alert( true || true );   // true
alert( false || true );  // true
alert( true || false );  // true
alert( false || false ); // false  
```

จะเห็นว่าผลลัพธ์จะเป็น `true` เสมอ ยกเว้นกรณีที่ operand ทั้งสองข้างเป็น `false`

ถ้า operand ไม่ใช่ boolean จะถูกแปลงเป็น boolean ก่อนแล้วค่อยประเมิน

เช่น ตัวเลข `1` จะถือเป็น `true` ส่วนตัวเลข `0` จะเป็น `false`:

```js run
if (1 || 0) { // จะทำงานเหมือน if (true || false)
  alert('truthy!');
}
```

ส่วนใหญ่แล้ว OR `||` จะใช้ในคำสั่ง `if` เพื่อตรวจว่ามีเงื่อนไขใดเป็น `true` บ้าง

ตัวอย่างเช่น:

```js run
let hour = 9;

*!*
if (hour < 10 || hour > 18) {
*/!*
  alert('ออฟฟิศปิดแล้ว');  
}
```

เราสามารถเพิ่มเงื่อนไขได้อีก:

```js run
let hour = 12;
let isWeekend = true;

if (hour < 10 || hour > 18 || isWeekend) {
  alert('ออฟฟิศปิดแล้ว'); // เพราะเป็นวันหยุดสุดสัปดาห์  
}
```

## OR "||" จะหาค่า truthy ตัวแรก

ตรรกะที่อธิบายไว้ข้างต้นค่อนข้างเป็นแบบดั้งเดิม ทีนี้มาดูความสามารถ "พิเศษ" ของ JavaScript กัน

อัลกอริทึมที่ขยายออกไปจะทำงานดังนี้

เมื่อมีหลายค่ามา OR กัน:

```js
result = value1 || value2 || value3;
```

ตัวดำเนินการ OR `||` จะทำดังนี้:

- ประเมิน operand จากซ้ายไปขวา
- สำหรับแต่ละ operand จะแปลงเป็น boolean ถ้าผลลัพธ์เป็น `true` จะหยุดและคืนค่าเดิมของ operand นั้นทันที
- ถ้าประเมิน operand ทั้งหมดแล้ว (คือทุกตัวเป็น `false`) จะคืนค่า operand ตัวสุดท้าย

จะคืนค่าในรูปแบบเดิม โดยไม่มีการแปลงใดๆ

อีกนัยหนึ่ง การเชื่อม OR `||` หลายตัวจะคืนค่า truthy ตัวแรกเสมอ หรือถ้าไม่เจอค่า truthy เลยจะคืนตัวสุดท้าย

ตัวอย่างเช่น:

```js run
alert( 1 || 0 ); // 1 (1 เป็น truthy)

alert( null || 1 ); // 1 (1 เป็นค่า truthy ตัวแรก)
alert( null || 0 || 1 ); // 1 (ค่า truthy ตัวแรก)

alert( undefined || null || 0 ); // 0 (ทั้งหมดเป็น falsy จึงคืนค่าตัวสุดท้าย)
```

พฤติกรรมนี้ทำให้มีวิธีใช้ OR ที่น่าสนใจเมื่อเทียบกับการใช้ OR แบบบูลีนอย่างเดียวทั่วไป

1. **การหาค่า truthy ตัวแรกจาก list ของตัวแปรหรือนิพจน์ต่างๆ**

   เช่น สมมติเรามีตัวแปร `firstName`, `lastName` และ `nickName` ซึ่งล้วนแต่เป็นออปชันที่อาจจะเป็น undefined หรือมีค่า falsy ได้

   เราสามารถใช้ OR `||` เพื่อเลือกเอาค่าที่เซ็ตข้อมูลแล้วมาแสดง (หรือถ้าไม่มีจะแสดง `"Anonymous"`):

   ```js run
   let firstName = "";
   let lastName = "";
   let nickName = "SuperCoder";

   *!*
   alert( firstName || lastName || nickName || "Anonymous"); // SuperCoder
   */!*
   ```

   ถ้าทุกตัวแปรเป็น falsy ก็จะแสดง `"Anonymous"`

2. **การประเมินแบบตัดตอนสั้น (short-circuit)**

   อีกความสามารถของตัวดำเนินการ OR `||` คือเรียกว่า "short-circuit evaluation" 
   
   มันหมายความว่า `||` จะประมวลผลอาร์กิวเมนต์จนกว่าจะเจอค่า truthy ตัวแรก แล้วจะคืนค่านั้นทันทีเลย โดยไม่แตะอาร์กิวเมนต์ตัวถัดไปเลย

   ความสำคัญของความสามารถนี้จะเห็นได้ชัดเจน ถ้า operand ไม่ใช่แค่ค่าธรรมดา แต่เป็นนิพจน์ที่มี side-effect อย่างเช่นการกำหนดค่าตัวแปรหรือเรียกใช้ฟังก์ชัน

   ในตัวอย่างด้านล่าง จะพิมพ์แค่ข้อความที่สองเท่านั้น:
   
   ```js run no-beautify
   *!*true*/!* || alert("จะไม่พิมพ์");
   *!*false*/!* || alert("จะพิมพ์");
   ```

   ในบรรทัดแรก ตัว OR `||` จะหยุดประเมินทันทีที่เจอ `true` ดังนั้น `alert` จึงไม่ถูกเรียก

   บางครั้งก็มีคนใช้ความสามารถนี้เพื่อรันคำสั่งก็ต่อเมื่อเงื่อนไขทางซ้ายมือเป็น falsy ด้วย

## && (AND)

เครื่องหมาย AND ใช้สัญลักษณ์ & สองตัวติดกัน `&&` แบบนี้:

```js
result = a && b;
```

โดยปกติในการเขียนโปรแกรม AND จะคืนค่า `true` ถ้า operand ทั้งสองเป็น truthy และคืน `false` ในกรณีอื่นๆ:

```js run
alert( true && true );   // true
alert( false && true );  // false
alert( true && false );  // false
alert( false && false ); // false
```

ตัวอย่างการใช้กับ `if`:

```js run
let hour = 12;
let minute = 30;

if (hour == 12 && minute == 30) {
  alert( 'ขณะนี้เวลา 12:30 น.' );
}  
```

เหมือนกับ OR นั่นคือ operand ของ AND จะเป็นค่าอะไรก็ได้:

```js run
if (1 && 0) { // ประเมินเป็น true && false
  alert( "จะไม่ทำงาน เพราะผลลัพธ์เป็น falsy" );
}
```

## AND "&&" จะหาค่า falsy ตัวแรก

ถ้ามีหลายค่ามา AND กัน:

```js
result = value1 && value2 && value3;
```

ตัวดำเนินการ AND `&&` จะทำงานดังนี้:

- ประเมิน operand จากซ้ายไปขวา
- สำหรับแต่ละ operand จะแปลงเป็น boolean ถ้าผลลัพธ์เป็น `false` จะหยุดและคืนค่าเดิมของ operand นั้นทันที
- ถ้าประเมิน operand ทั้งหมดแล้ว (คือทุกตัวเป็น truthy) จะคืนค่า operand ตัวสุดท้าย

อีกนัยหนึ่ง AND จะคืนค่า falsy ตัวแรกที่เจอ หรือถ้าไม่เจอเลยจะคืนค่าตัวสุดท้าย

กฎข้างต้นคล้ายกับ OR ต่างกันตรงที่ AND คืนค่า *falsy* ตัวแรก ส่วน OR คืนค่า *truthy* ตัวแรก

ตัวอย่าง:

```js run
// ถ้า operand ตัวแรกเป็น truthy
// AND จะคืนค่า operand ตัวที่สอง:
alert( 1 && 0 ); // 0
alert( 1 && 5 ); // 5

// ถ้า operand ตัวแรกเป็น falsy 
// AND จะคืนค่านั้นเลย โดยไม่สนใจ operand ตัวที่สอง
alert( null && 5 ); // null
alert( 0 && "ไม่สำคัญ" ); // 0
```

เราสามารถส่งหลายค่าต่อกันได้ ลองดูว่าค่า falsy ตัวแรกจะถูกคืนออกมา:

```js run
alert( 1 && 2 && null && 3 ); // null
```

ถ้าค่าทั้งหมดเป็น truthy ค่าตัวสุดท้ายจะถูกคืน:

```js run
alert( 1 && 2 && 3 ); // 3, ตัวสุดท้าย  
```

````smart header="AND `&&` มีลำดับความสำคัญสูงกว่า OR `||`"
ตัวดำเนินการ AND `&&` จะมี precedence สูงกว่า OR `||`

ดังนั้นโค้ด `a && b || c && d` ก็เหมือนกับการเขียนนิพจน์ `&&` อยู่ในวงเล็บ: `(a && b) || (c && d)`
````

````warn header="อย่าใช้ `||` หรือ `&&` แทนคำสั่ง `if`"
บางครั้งมีคนใช้ตัวดำเนินการ AND `&&` เพื่อ "เขียน `if` ให้สั้นลง"

เช่น:

```js run
let x = 1;

(x > 0) && alert( 'มากกว่าศูนย์!' );
```

การกระทำทางขวาของ `&&` จะรันก็ต่อเมื่อการประเมินทำไปถึงจุดนั้น ซึ่งก็คือเมื่อ `(x > 0)` เป็นจริง

ดังนั้นมันจะเหมือนกับการเขียนแบบนี้:

```js run
let x = 1;

if (x > 0) alert( 'มากกว่าศูนย์!' );  
```

ถึงแม้การใช้ `&&` จะดูสั้นกว่า แต่ `if` จะชัดเจนและอ่านเข้าใจง่ายกว่า แนะนำให้ใช้แต่ละแบบตามวัตถุประสงค์ที่มันถูกสร้างมา ใช้ `if` ถ้าต้องการเงื่อนไข if และใช้ `&&` ถ้าต้องการตรรกะ AND
````

## ! (NOT)

ตัวดำเนินการตรรกะ NOT ใช้สัญลักษณ์อัศเจรีย์ `!` 

รูปแบบการใช้งานค่อนข้างง่าย:

```js
result = !value;
```

โดยตัวดำเนินการจะรับ operand เดียว และทำงานดังนี้:

1. แปลง operand ให้เป็นประเภท boolean: `true/false`
2. คืนค่าตรงข้าม (invert)

ตัวอย่างเช่น:

```js run
alert( !true ); // false
alert( !0 ); // true
```

การใช้ NOT สองตัวติดกัน `!!` บางครั้งใช้เพื่อแปลงค่าให้เป็นประเภท boolean:

```js run
alert( !!"non-empty string" ); // true
alert( !!null ); // false  
```

นั่นคือ NOT ตัวแรกจะแปลงค่าเป็น boolean และคืนค่าตรงข้าม จากนั้น NOT ตัวที่สองก็จะ invert อีกครั้ง ในท้ายที่สุดเราจะได้การแปลงค่าเป็น boolean อย่างง่ายๆ

มีอีกวิธีที่อ่านเข้าใจง่ายกว่าในการทำแบบเดียวกัน คือใช้ฟังก์ชันในตัว `Boolean`:

```js run
alert( Boolean("non-empty string") ); // true
alert( Boolean(null) ); // false
```

ตัวดำเนินการ NOT `!` จะมีลำดับความสำคัญ (precedence) สูงสุดในบรรดาตัวดำเนินการตรรกะทั้งหมด ดังนั้นมันจะถูกประมวลผลก่อนเสมอ ก่อนที่จะไปประมวลผล `&&` หรือ `||`