# ตัวดำเนินการพื้นฐานและคณิตศาสตร์

หลายคนคุ้นเคยกับตัวดำเนินการทางคณิตศาสตร์มาตั้งแต่สมัยเรียนแล้ว ไม่ว่าจะเป็นการบวก `+` การคูณ `*` การลบ `-` และอื่นๆ อีกมากมาย 

ในบทนี้ เราจะเริ่มต้นด้วยตัวดำเนินการพื้นฐาน จากนั้นจะเจาะลึกไปที่ลักษณะเฉพาะของ JavaScript ซึ่งไม่ได้เรียนกันในวิชาคณิตศาสตร์ทั่วไป

## ศัพท์น่ารู้: "unary", "binary", "operand" 

ก่อนจะเริ่มเรื่องต่อไป เรามาทำความเข้าใจศัพท์ที่ใช้กันทั่วไปเสียก่อน

- _ตัวถูกดำเนินการ (operand)_ คือสิ่งที่ถูกนำไปคำนวณด้วยตัวดำเนินการนั่นเอง ยกตัวอย่างเช่น ในการคูณ `5 * 2` จะมีตัวถูกดำเนินการสองตัว ได้แก่ `5` ที่อยู่ทางซ้าย และ `2` ที่อยู่ทางขวา บางครั้งอาจเรียกตัวถูกดำเนินการว่า "อาร์กิวเมนต์ (argument)" แทนก็ได้

- ตัวดำเนินการจะเป็นแบบ _unary_ หากมีตัวถูกดำเนินการเพียงตัวเดียว อย่างเช่น การกลับเครื่องหมาย `-` ที่จะกลับเครื่องหมายของตัวเลข:

```js run
let x = 1;

*!*
x = -x;
*/!*

alert( x ); // -1, มีการใช้ unary negation
```

- ตัวดำเนินการจะเป็นแบบ _binary_ หากมีตัวถูกดำเนินการสองตัว เครื่องหมายลบก็มีในรูปแบบ binary ด้วยเช่นกัน:

```js run no-beautify
let x = 1, y = 3;
alert( y - x ); // 2, binary minus ใช้ลบค่าทั้งสองออกจากกัน  
```

ถ้าพูดอย่างเป็นทางการ ในตัวอย่างด้านบนมีตัวดำเนินการสองตัวที่ใช้สัญลักษณ์เดียวกัน นั่นคือ ตัวดำเนินการ negation ซึ่งเป็น unary ที่กลับเครื่องหมาย และตัวดำเนินการลบ ซึ่งเป็น binary ที่ลบจำนวนหนึ่งออกจากอีกจำนวนหนึ่ง

## คณิตศาสตร์

ใน JavaScript เราใช้ตัวดำเนินการทางคณิตศาสตร์แบบเดียวกับที่เราเรียนกันมา ได้แก่:

- บวก `+`
- ลบ `-`
- คูณ `*`
- หาร `/`
- เศษ `%`
- ยกกำลัง `**`

สี่ตัวแรกคงไม่ต้องอธิบายอะไรมาก แต่เศษ `%` กับ ยกกำลัง `**` อาจต้องอธิบายเพิ่มเติมอยู่หน่อย

### เศษ %

ตัวดำเนินการเศษ `%` ถึงแม้จะดูเหมือนเปอร์เซ็นต์ แต่ไม่ได้เกี่ยวข้องอะไรกับเปอร์เซ็นต์เลยนะเออ

ผลลัพธ์ของ `a % b` คือ เศษ: [https://en.wikipedia.org/wiki/Remainder](https://en.wikipedia.org/wiki/Remainder) ที่เหลือจากการหาร `a` ด้วย `b` แบบลงตัว

ตัวอย่างเช่น:

```js run
alert( 5 % 2 ); // 1, เศษของ 5 หารด้วย 2
alert( 8 % 3 ); // 2, เศษของ 8 หารด้วย 3
alert( 8 % 4 ); // 0, เศษของ 8 หารด้วย 4
```

## ยกกำลัง **

ตัวดำเนินการยกกำลัง `a ** b` คือการเอา `a` มาคูณตัวเอง `b` ครั้ง

ในวิชาคณิตศาสตร์ เราเขียนแบบนี้ a<sup>b</sup>

ตัวอย่างเช่น:

```js run
alert( 2 ** 2 ); // 2² = 4
alert( 2 ** 3 ); // 2³ = 8
alert( 2 ** 4 ); // 2⁴ = 16
```

เหมือนกับที่เรียนมา ตัวดำเนินการยกกำลังสามารถใช้กับตัวเลขที่ไม่ใช่จำนวนเต็มได้เช่นกัน

ตัวอย่างเช่น การหารากที่สองก็คือการยกกำลังด้วย ½:

```js run
alert( 4 ** (1/2) ); // 2 (ยกกำลัง 1/2 เหมือนกับการหารากที่สอง)
alert( 8 ** (1/3) ); // 2 (ยกกำลัง 1/3 เหมือนกับการหารากที่สาม)
```

## ต่อคำ (Concatenation) กับ +

ตอนนี้เรามาเจอฟีเจอร์ของตัวดำเนินการ JavaScript ที่นอกเหนือจากการบวกเลขแบบเบสิคที่เรียนกันมาแล้ว

ปกติแล้ว ตัวดำเนินการบวก `+` จะใช้บวกตัวเลข

แต่ถ้าเราบวกสตริงด้วย `+` มันจะกลายเป็นการต่อคำ (concatenate) กัน

```js run
let s = "my" + "string";
alert(s); // mystring
```

ท่องไว้เลยว่าถ้ามีสตริงเป็นตัวดำเนินการ ตัวดำเนินการอีกตัวจะถูกแปลงเป็นสตริงด้วย

ตัวอย่าง:

```js run
alert( '1' + 2 ); // "12"
alert( 2 + '1' ); // "21"
```

เห็นมั้ย ไม่ว่าสตริงจะอยู่ขวาหรือซ้าย ก็ได้ผลลัพธ์เหมือนกัน

นี่คือตัวอย่างที่ซับซ้อนขึ้นอีกหน่อย:

```js run
alert(2 + 2 + '1' ); // "41" ไม่ใช่ "221"
```

ในตัวอย่างนี้ ตัวดำเนินการทำงานทีละตัว `+` ตัวแรกบวกตัวเลขสองตัว ดังนั้นมันจะคืนค่า `4` จากนั้น `+` ตัวต่อไปจะเพิ่มสตริง `1` เข้าไป ดังนั้นมันเหมือนกับ `4 + '1' = '41'`.

```js run
alert('1' + 2 + 2); // "122" ไม่ใช่ "14"
```

ในตัวอย่างนี้ ตัวดำเนินการตัวแรกเป็นสตริง คอมไพเลอร์จะมองว่าตัวดำเนินการอีกสองตัวเป็นสตริงด้วยเช่นกัน `2` จะถูกต่อท้าย `'1'` ดังนั้นมันเหมือนกับ `'1' + 2 = "12"` และ `"12" + 2 = "122"`.

ตัวดำเนินการ `+` แบบ binary เป็นตัวดำเนินการเดียวที่รองรับสตริงในลักษณะนี้ ตัวดำเนินการทางคณิตศาสตร์อื่น ๆ ทำงานได้เฉพาะกับตัวเลขเท่านั้นและจะแปลงตัวดำเนินการเป็นตัวเลขเสมอ

นี่คือตัวอย่างสำหรับการลบและการหาร:

```js run
alert( 6 - '2' ); // 4, แปลง '2' เป็นตัวเลข
alert( '6' / '2' ); // 3, แปลงทั้งสองเป็นตัวเลข
```

## การแปลงเป็นตัวเลข, unary +

เจ้าตัวบวก `+` เนี่ย มันมีอยู่สองแบบ แบบไบนารีที่เราใช้ไปข้างบนแล้ว กับแบบ unary

แบบ unary plus หรือเรียกง่ายๆ ว่า เอาบวก `+` มาแปะกับตัวแปรตัวเดียว มันไม่มีผลอะไรกับตัวเลขหรอกนะ แต่ถ้าตัวแปรไม่ใช่ตัวเลข unary plus จะแปลงมันให้เป็นตัวเลขซะเลย

ตัวอย่าง:

```js run
// ไม่มีผลกับตัวเลข
let x = 1;
alert( +x ); // 1

let y = -2;
alert( +y ); // -2

*!*
// แปลงสิ่งที่ไม่ใช่ตัวเลข
alert( +true ); // 1
alert( +"" );   // 0
*/!*
```

จริงๆ มันก็ทำหน้าที่เหมือนกับ `Number(...)` นั่นแหละ แต่สั้นกว่า

การแปลงสตริงเป็นตัวเลขเป็นเรื่องที่พบได้บ่อยมาก ตัวอย่างเช่น ถ้าเราได้ค่าจากฟิลด์ฟอร์ม HTML มันก็มักจะเป็นสตริง แล้วถ้าเราอยากบวกมันล่ะ?

แบบไบนารีจะบวกมันเป็นสตริง:

```js run
let apples = "2";
let oranges = "3";

alert( apples + oranges ); // "23", the binary plus concatenates strings
```

ถ้าเราอยากให้มันเป็นตัวเลข เราก็ต้องแปลงก่อน แล้วค่อยบวก:

```js run
let apples = "2";
let oranges = "3";

*!*
// ทั้งสองค่าถูกแปลงเป็นตัวเลขก่อนที่จะใช้ binary plus
alert( +apples + +oranges ); // 5
*/!*

// แบบยาว
// alert( Number(apples) + Number(oranges) ); // 5
```

สำหรับนักคณิตศาสตร์ การใช้บวกเยอะๆแบบนี้ อาจดูแปลก แต่สำหรับโปรแกรมเมอร์ มันก็ไม่มีอะไรพิเศษ: unary pluses จะถูกใช้ก่อน มันแปลงสตริงเป็นตัวเลข แล้ว binary plus ก็เอาตัวเลขเหล่านั้นมาบวกกัน

ทำไม unary pluses ถึงถูกนำไปใช้ก่อน binary pluses? แน่นอนว่าเป็นเพราะ "ระดับความสำคัญ" ที่สูงกว่าของมัน ซึ่งเราจะได้เจอกันในบทต่อไป

## ลำดับความสำคัญของตัวดำเนินการ (Operator precedence)

ถ้านิพจน์มีตัวดำเนินการมากกว่าหนึ่งตัว ลำดับการคำนวณจะถูกกำหนดโดย *ลำดับความสำคัญ* หรือก็คือลำดับความสำคัญของตัวดำเนินการนั่นเอง

จากที่เรียนกันมา เราทุกคนรู้ว่าการคูณในสูตร `1 + 2 * 2` จะต้องคำนวณก่อนการบวก นั่นก็คือเรื่องของลำดับความสำคัญ ตัวคูณมี *ลำดับความสำคัญสูงกว่า* การบวก

เครื่องหมายวงเล็บ ( ) จะข้ามลำดับความสำคัญใดๆ ก็ตาม ดังนั้นถ้าเราไม่พอใจกับลำดับเริ่มต้น เราสามารถใช้มันเพื่อเปลี่ยนมันได้ ตัวอย่างเช่น เขียน `(1 + 2) * 2`

มีตัวดำเนินการมากมายใน JavaScript ตัวดำเนินการแต่ละตัวมีหมายเลขลำดับความสำคัญที่สอดคล้องกัน ตัวเลขที่มากที่สุดจะถูกดำเนินการก่อน หากลำดับความสำคัญเท่ากัน ลำดับการดำเนินการจะเป็นจากซ้ายไปขวา

นี่คือตัวอย่างจาก ตารางลำดับความสำคัญ: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence) (คุณไม่จำเป็นต้องจำสิ่งนี้ แต่โปรดทราบว่าตัวดำเนินการแบบ unary มีลำดับความสำคัญสูงกว่าตัวดำเนินการแบบ binary ที่สอดคล้องกัน):

| ลำดับความสำคัญ | ชื่อ | สัญลักษณ์ |
|---|---|---|
| ... | ... | ... |
| 14 | unary plus | `+` |
| 14 | unary negation | `-` |
| 13 | ยกกำลัง | `**` |
| 12 | คูณ | `*` |
| 12 | หาร | `/` |
| 11 | บวก | `+` |
| 11 | ลบ | `-` |
| ... | ... | ... |
| 2 | กำหนดค่า | `=` |
| ... | ... | ... |

อย่างที่เราเห็น "unary plus" มีลำดับความสำคัญ `14` ซึ่งสูงกว่า `11` ของ "addition" (binary plus) นั่นคือเหตุผลว่าทำไมในสูตร `"+apples + +oranges"`, unary pluses จะทำงานก่อนการบวก

## การกำหนดค่า (Assignment)

โปรดทราบว่าการกำหนดค่า `=` ก็เป็นตัวดำเนินการเช่นกัน มันอยู่ในตารางลำดับความสำคัญด้วยลำดับความสำคัญต่ำมาก คือ `2`

นั่นคือเหตุผลว่าทำไมเมื่อเรากำหนดค่าให้ตัวแปร เช่น `x = 2 * 2 + 1` การคำนวณจะเสร็จสิ้นก่อน จากนั้น `=` จะได้รับการประเมิน ผลลัพธ์จะถูกเก็บไว้ใน `x`

```js
let x = 2 * 2 + 1;

alert( x ); // 5
```

### การกำหนดค่า = ส่งคืนค่า

ข้อเท็จจริงที่ว่า `=` เป็นตัวดำเนินการ ไม่ใช่ "โครงสร้างภาษาแบบมหัศจรรย์" มีนัยที่น่าสนใจ

ตัวดำเนินการทั้งหมดใน JavaScript ส่งคืนค่า นั่นเห็นได้ชัดสำหรับ `+` และ `-` แต่ก็เป็นจริงสำหรับ `=` ด้วย

การเรียก `x = value` จะเขียน `value` ลงใน `x` *และส่งคืน*

นี่คือตัวอย่างที่ใช้การกำหนดค่าเป็นส่วนหนึ่งของนิพจน์ที่ซับซ้อนยิ่งขึ้น:

```js run
let a = 1;
let b = 2;

*!*
let c = 3 - (a = b + 1);
*/!*

alert( a ); // 3
alert( c ); // 0
```

ในตัวอย่างข้างต้น ผลลัพธ์ของนิพจน์ `(a = b + 1)` คือค่าที่กำหนดให้กับ `a` (ซึ่งก็คือ `3`) จากนั้นจะถูกนำไปใช้ในการประเมินผลต่อไป

โค้ดแปลกๆ ใช่มั้ย? เราควรเข้าใจว่ามันทำงานอย่างไร เพราะบางครั้งเราเห็นมันในไลบรารี JavaScript

อย่างไรก็ตาม อย่าเขียนโค้ดแบบนั้นเลยนะ เทคนิคแบบนี้ไม่ได้ทำให้โค้ดชัดเจนหรืออ่านง่ายขึ้นเลย

### การกำหนดค่าแบบลูกโซ่

อีกหนึ่งฟีเจอร์ที่น่าสนใจคือความสามารถในการเชื่อมโยงการกำหนดค่า:

```js run
let a, b, c;

*!*
a = b = c = 2 + 2;
*/!*

alert( a ); // 4
alert( b ); // 4
alert( c ); // 4
```

การกำหนดค่าแบบลูกโซ่จะประเมินผลจากขวาไปซ้าย ก่อนอื่นนิพจน์ที่อยู่ขวามือสุด `2 + 2` จะถูกประเมินผล จากนั้นจึงกำหนดให้กับตัวแปรทางซ้าย: `c`, `b` และ `a` ในท้ายที่สุด ตัวแปรทั้งหมดจะมีค่าเดียวกัน

อีกครั้ง เพื่อความสะดวกในการอ่าน ควรแบ่งโค้ดดังกล่าวออกเป็นสองสามบรรทัด:

```js
c = 2 + 2;
b = c;
a = c;
```
แบบนี้จะอ่านง่ายกว่าเยอะ โดยเฉพาะอย่างยิ่งเมื่อมองผ่านโค้ดอย่างรวดเร็ว

## แก้ไขค่าเดิม

เราต้องใช้ตัวดำเนินการกับตัวแปรและเก็บผลลัพธ์ใหม่ไว้ในตัวแปรนั้นบ่อยครั้ง

ตัวอย่างเช่น:

```js
let n = 2;
n = n + 5;
n = n * 2;
```

รูปแบบนี้สามารถย่อให้สั้นลงได้โดยใช้ตัวดำเนินการ `+=` และ `*=`:

```js run
let n = 2;
n += 5; // ตอนนี้ n = 7 (เหมือนกับ n = n + 5)
n *= 2; // ตอนนี้ n = 14 (เหมือนกับ n = n * 2)

alert( n ); // 14
```

มีตัวดำเนินการ "modify-and-assign" แบบย่อสำหรับตัวดำเนินการทางคณิตศาสตร์และ bitwise ทั้งหมด: `/=`, `-=` เป็นต้น

ตัวดำเนินการดังกล่าวมีลำดับความสำคัญเดียวกับการกำหนดค่าปกติ ดังนั้นจึงทำงานหลังจากการคำนวณอื่น ๆ ส่วนใหญ่:

```js run
let n = 2;

n *= 3 + 5; // ส่วนขวาถูกประเมินผลก่อน เหมือนกับ n *= 8

alert( n ); // 16
```

## เพิ่ม/ลด (Increment/decrement)

การเพิ่มหรือลดตัวเลขทีละ 1 เป็นหนึ่งในคำสั่งทางคณิตศาสตร์ที่ใช้บ่อยที่สุด

ดังนั้น มีตัวดำเนินการพิเศษสำหรับมัน:

- **เพิ่ม (Increment)** `++` จะเพิ่มตัวแปร 1:

```js run no-beautify
let counter = 2;
counter++;        // ทำงานเหมือน counter = counter + 1 แต่สั้นกว่า
alert( counter ); // 3
```

- **ลด (Decrement)** `--` จะลดตัวแปร 1:

```js run no-beautify
let counter = 2;
counter--;        // ทำงานเหมือน counter = counter - 1 แต่สั้นกว่า
alert( counter ); // 1
```

```warn
Increment/decrement ใช้ได้เฉพาะกับตัวแปรเท่านั้น การพยายามใช้กับค่าอื่น เช่น `5++` จะทำให้เกิดข้อผิดพลาด
```

ตัวดำเนินการ `++` และ `--` สามารถวางไว้ก่อนหรือหลังตัวแปรได้

- เมื่อตัวดำเนินการอยู่หลังตัวแปร จะอยู่ในรูปแบบ "postfix": `counter++`
- รูปแบบ "prefix" คือเมื่อตัวดำเนินการอยู่หน้าตัวแปร: `++counter`

คำสั่งทั้งสองนี้ทำสิ่งเดียวกัน: เพิ่ม `counter` ขึ้น 1

มีความแตกต่างกันหรือไม่? ใช่ แต่เราจะเห็นมันได้ก็ต่อเมื่อเราใช้ค่าที่ได้จาก `++/--`

ขออธิบายเพิ่มเติม อย่างที่เรารู้กันว่า ตัวดำเนินการทุกตัวส่งคืนค่า Increment/decrement ไม่มีข้อยกเว้น รูปแบบ prefix จะส่งคืนค่าใหม่ ในขณะที่รูปแบบ postfix จะส่งคืนค่าเดิม (ก่อนการเพิ่ม/ลด)

เพื่อดูความแตกต่าง นี่คือตัวอย่าง:

```js run
let counter = 1;
let a = ++counter; // (*)

alert(a); // *!*2*/!*
```

ในบรรทัด `(*)` ฟอร์ม *prefix* `++counter` เพิ่ม `counter` และส่งคืนค่าใหม่ `2` ดังนั้น `alert` จะแสดงผล `2`

ลองใช้รูปแบบ postfix ดู:

```js run
let counter = 1;
let a = counter++; // (*) เปลี่ยน ++counter เป็น counter++

alert(a); // *!*1*/!*
```

ในบรรทัด `(*)` ฟอร์ม *postfix* `counter++` ยังเพิ่ม `counter` แต่ส่งคืนค่า *เดิม* (ก่อนการเพิ่ม) ดังนั้น `alert` จะแสดงผล `1`

สรุป:

- ถ้าผลลัพธ์ของ increment/decrement ไม่ถูกนำไปใช้ จะไม่มีความแตกต่างว่าจะใช้รูปแบบใด:

```js run
let counter = 0;
counter++;
++counter;
alert( counter ); // 2 บรรทัดข้างต้นทำสิ่งเดียวกัน
```

- ถ้าเราต้องการเพิ่มค่า *และ* ใช้ผลลัพธ์ของตัวดำเนินการทันที เราต้องใช้รูปแบบ prefix:

```js run
let counter = 0;
alert( ++counter ); // 1
```

- ถ้าเราต้องการเพิ่มค่า แต่ใช้ค่าเดิม เราต้องใช้รูปแบบ postfix:

```js run
let counter = 0;
alert( counter++ ); // 0
```

````smart header="Increment/decrement กับตัวดำเนินการอื่นๆ"
ตัวดำเนินการ `++/--` สามารถใช้ภายในนิพจน์ได้เช่นกัน ลำดับความสำคัญของพวกมันสูงกว่าการดำเนินการทางคณิตศาสตร์ส่วนใหญ่

ตัวอย่างเช่น:

```js run
let counter = 1;
alert( 2 * ++counter ); // 4
```

เปรียบเทียบกับ:

```js run
let counter = 1;
alert( 2 * counter++ ); // 2 เพราะ counter++ ส่งคืนค่า "เก่า"


แม้ว่าจะถูกต้องทางเทคนิค แต่การเขียนแบบนี้มักทำให้โค้ดอ่านยากขึ้น บรรทัดเดียวทำหลายอย่าง -- ไม่ดี

ขณะอ่านโค้ด การมองผ่านแบบ "แนวตั้ง" อย่างรวดเร็วอาจพลาดสิ่งต่างๆ เช่น `counter++` และจะไม่เห็นชัดเจนว่าตัวแปรเพิ่มขึ้น

เราแนะนำให้เขียนแบบ "หนึ่งบรรทัด -- หนึ่งคำสั่ง":

js run
let counter = 1;
alert( 2 * counter );
counter++;
```
````

```js run
let counter = 1;
alert( 2 * counter );
counter++;
```
````

## ตัวดำเนินการแบบบิต (Bitwise Operators)

ตัวดำเนินการแบบบิตถืออาร์กิวเมนต์เป็นตัวเลขจำนวนเต็ม 32 บิต และทำงานในระดับการแสดงค่าแบบเลขฐานสอง

ตัวดำเนินการเหล่านี้ไม่ได้เฉพาะเจาะจงกับ JavaScript พวกมันรองรับในภาษาการเขียนโปรแกรมส่วนใหญ่

รายการของตัวดำเนินการ:

- AND ( `&` )
- OR ( `|` )
- XOR ( `^` )
- NOT ( `~` )
- LEFT SHIFT ( `<<` )
- RIGHT SHIFT ( `>>` )
- ZERO-FILL RIGHT SHIFT ( `>>>` )

ตัวดำเนินการเหล่านี้ใช้ไม่บ่อยนัก เมื่อเราต้องการปรับแต่งตัวเลขที่ระดับต่ำสุด (ระดับบิต) เราไม่จำเป็นต้องใช้ตัวดำเนินการเหล่านี้ในเร็วๆ นี้ เนื่องจากการพัฒนาเว็บใช้ประโยชน์จากมันน้อยมาก แต่ในบางพื้นที่พิเศษ เช่น การเข้ารหัส ตัวดำเนินการเหล่านี้มีประโยชน์ คุณสามารถอ่านบท Bitwise Operators: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#bitwise_operators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#bitwise_operators) บน MDN เมื่อจำเป็น

## เครื่องหมายจุลภาค (Comma)

เครื่องหมายจุลภาค `,` เป็นหนึ่งในตัวดำเนินการที่หายากและแปลกประหลาดที่สุด บางครั้งใช้เพื่อเขียนโค้ดให้สั้นลง ดังนั้นเราต้องรู้จักมันเพื่อให้เข้าใจว่าเกิดอะไรขึ้น

ตัวดำเนินการจุลภาคช่วยให้เราประเมินนิพจน์หลายนิพจน์ โดยใช้เครื่องหมายจุลภาค `,` คั่นระหว่างกัน แต่ละนิพจน์จะถูกประเมิน แต่ผลลัพธ์ของนิพจน์สุดท้ายเท่านั้นที่จะถูกส่งคืน

ตัวอย่างเช่น:

```js run
*!*
let a = (1 + 2, 3 + 4);
*/!*

alert( a ); // 7 (ผลลัพธ์ของ 3 + 4)
```

ในที่นี้ นิพจน์แรก `1 + 2` จะถูกประเมินและผลลัพธ์จะถูกทิ้ง จากนั้น `3 + 4` จะถูกประเมินและส่งคืนเป็นผลลัพธ์

```smart header="เครื่องหมายจุลภาคมีลำดับความสำคัญต่ำมาก"
โปรดทราบว่าตัวดำเนินการจุลภาคมีลำดับความสำคัญต่ำมาก ต่ำกว่า `=` ดังนั้นวงเล็บจึงสำคัญในตัวอย่างด้านบน

หากไม่มีวงเล็บ: `a = 1 + 2, 3 + 4` จะประเมิน `+` ก่อน บวกตัวเลขเป็น `a = 3, 7` จากนั้นตัวดำเนินการกำหนดค่า `=` จะกำหนด `a = 3` และส่วนที่เหลือจะถูกละเว้น เหมือนกับ `(a = 1 + 2), 3 + 4`.
```

แล้วทำไมเราถึงต้องการตัวดำเนินการที่ทิ้งทุกอย่างยกเว้นนิพจน์สุดท้ายล่ะ?

บางครั้ง คนใช้มันในโครงสร้างที่ซับซ้อนมากขึ้นเพื่อใส่หลายอย่างลงในบรรทัดเดียว

ตัวอย่างเช่น:

```js
// สามารถทำได้สามอย่างในหนึ่งบรรทัด
for (*!*a = 1, b = 3, c = a * b*/!*; a < 10; a++) {
 ...
}
```

เทคนิคแบบนี้ใช้กันในหลายเฟรมเวิร์ก JavaScript นั่นเป็นเหตุผลว่าทำไมเราถึงพูดถึงมัน แต่โดยปกติแล้ว มันไม่ช่วยให้โค้ดอ่านง่ายขึ้น ดังนั้นเราควรคิดให้ดีก่อนใช้มัน
