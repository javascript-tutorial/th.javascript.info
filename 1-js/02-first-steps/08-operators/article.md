# ตัวดำเนินการพื้นฐานและคณิตศาสตร์

หลายคนคุ้นเคยกับตัวดำเนินการทางคณิตศาสตร์มาตั้งแต่สมัยเรียนแล้ว ไม่ว่าจะเป็นการบวก `+` การคูณ `*` การลบ `-` และอื่นๆ อีกมากมาย 

ในบทนี้ เราจะเริ่มต้นด้วยตัวดำเนินการพื้นฐาน จากนั้นจะเจาะลึกไปที่ลักษณะเฉพาะของ JavaScript ซึ่งไม่ได้เรียนกันในวิชาคณิตศาสตร์ทั่วไป

## ศัพท์น่ารู้: "unary", "binary", "operand" 

ก่อนจะเริ่มเรื่องต่อไป เรามาทำความเข้าใจศัพท์ที่ใช้กันทั่วไปเสียก่อน

- _ตัวถูกดำเนินการ (operand)_ คือสิ่งที่ถูกนำไปคำนวณด้วยตัวดำเนินการนั่นเอง ยกตัวอย่างเช่น ในการคูณ `5 * 2` จะมีตัวถูกดำเนินการสองตัว ได้แก่ `5` ที่อยู่ทางซ้าย และ `2` ที่อยู่ทางขวา บางครั้งอาจเรียกตัวถูกดำเนินการว่า "อาร์กิวเมนต์ (argument)" แทนก็ได้

- ตัวดำเนินการจะเป็นแบบ _unary_ หากมีตัวถูกดำเนินการเพียงตัวเดียว อย่างเช่น การกลับเครื่องหมาย `-` ที่จะกลับเครื่องหมายของตัวเลข:

```js run
let x = 1;

*!*
x = -x;
*/!*

alert( x ); // -1, มีการใช้ unary negation
```

- ตัวดำเนินการจะเป็นแบบ _binary_ หากมีตัวถูกดำเนินการสองตัว เครื่องหมายลบก็มีในรูปแบบ binary ด้วยเช่นกัน:

```js run no-beautify
let x = 1, y = 3;
alert( y - x ); // 2, binary minus ใช้ลบค่าทั้งสองออกจากกัน  
```

ถ้าพูดอย่างเป็นทางการ ในตัวอย่างด้านบนมีตัวดำเนินการสองตัวที่ใช้สัญลักษณ์เดียวกัน นั่นคือ ตัวดำเนินการ negation ซึ่งเป็น unary ที่กลับเครื่องหมาย และตัวดำเนินการลบ ซึ่งเป็น binary ที่ลบจำนวนหนึ่งออกจากอีกจำนวนหนึ่ง

## คณิตศาสตร์

JavaScript รองรับการดำเนินการทางคณิตศาสตร์ต่อไปนี้

- บวก `+`
- ลบ `-`
- คูณ `*` 
- หาร `/`
- หารเอาเศษ `%`
- ยกกำลัง `**`

สี่ตัวดำเนินการแรกนั้นไม่ต้องอธิบายอะไรมาก ส่วน `%` และ `**` ขออธิบายเพิ่มเติมสักนิด

### การหารเอาเศษ %

แม้จะดูคล้ายเปอร์เซ็นต์ แต่ตัวดำเนินการ `%` ไม่ได้เกี่ยวข้องกับเปอร์เซ็นต์เลย 

ผลลัพธ์ของ `a % b` คือ [เศษ](https://en.wikipedia.org/wiki/Remainder) ที่ได้จากการหาร `a` ด้วย `b` แบบจำนวนเต็ม

ยกตัวอย่างเช่น

```js run
alert( 5 % 2 ); // 1, เศษของ 5 หาร 2
alert( 8 % 3 ); // 2, เศษของ 8 หาร 3
alert( 8 % 4 ); // 0, เศษของ 8 หาร 4
```

### การยกกำลัง **

ตัวดำเนินการยกกำลัง `a ** b` จะยกค่า `a` ด้วยเลขชี้กำลัง `b`

ในวิชาคณิตศาสตร์ เราจะเขียนสิ่งนี้เป็น a<sup>b</sup>

ยกตัวอย่างเช่น

```js run
alert( 2 ** 2 ); // 2² = 4
alert( 2 ** 3 ); // 2³ = 8
alert( 2 ** 4 ); // 2⁴ = 16 
```

เหมือนในคณิตศาสตร์ ตัวดำเนินการยกกำลังใช้กับจำนวนที่ไม่ใช่จำนวนเต็มได้ด้วย

อย่างเช่น การหารากกำลังสองก็คือการยกกำลังด้วย ½

```js run
alert( 4 ** (1/2) ); // 2 (ยกกำลัง 1/2 เท่ากับหารากกำลังสอง)
alert( 8 ** (1/3) ); // 2 (ยกกำลัง 1/3 เท่ากับหารากกำลังสาม)
```

## การต่อสตริงด้วย binary +

ลองมาดูคุณสมบัติของตัวดำเนินการใน JavaScript ที่นอกเหนือจากคณิตศาสตร์ในห้องเรียนกันหน่อย

ปกติแล้ว ตัวดำเนินการบวก `+` ใช้สำหรับบวกตัวเลข

แต่ถ้าใช้ `+` แบบ binary กับสตริง มันจะเชื่อม (ต่อ) สตริงเข้าด้วยกัน

```js
let s = "my" + "string";
alert(s); // mystring
```

ข้อสังเกตคือ ถ้าตัวถูกดำเนินการตัวใดตัวหนึ่งเป็นสตริง ตัวอื่นก็จะถูกแปลงเป็นสตริงเช่นกัน

ยกตัวอย่างเช่น

```js run
alert( '1' + 2 ); // "12"
alert( 2 + '1' ); // "21"
```

จะเห็นว่าไม่สำคัญว่าสตริงจะอยู่ตัวถูกดำเนินการตัวแรกหรือตัวที่สองก็ตาม

ลองดูตัวอย่างที่ซับซ้อนขึ้นอีกนิด

```js run
alert(2 + 2 + '1' ); // "41" ไม่ใช่ "221"
```

ในที่นี้ ตัวดำเนินการจะทำงานทีละตัว `+` ตัวแรกจะบวกเลขสองจำนวน ได้ผลเป็น `4`, จากนั้น `+` ตัวถัดไปก็นำ `4` ไปต่อกับสตริง `'1'` เหมือนกับการเขียน `4 + '1' = '41'`

```js run
alert('1' + 2 + 2); // "122" ไม่ใช่ "14"
```

ในตัวอย่างนี้ ตัวถูกดำเนินการตัวแรกเป็นสตริง ตัวแปลภาษาจึงมองว่าตัวถูกดำเนินการอีกสองตัวเป็นสตริงด้วย `2` จะถูกเชื่อมต่อท้าย `'1'` เหมือนการเขียน `'1' + 2 = "12"` และ `"12" + 2 = "122"`

`+` แบบ binary เป็นตัวดำเนินการตัวเดียวที่รองรับการทำงานกับสตริงในลักษณะนี้ ส่วนตัวดำเนินการคณิตศาสตร์อื่นๆ จะทำงานกับตัวเลขเท่านั้น และจะแปลงค่าตัวถูกดำเนินการเป็นตัวเลขเสมอ

ต่อไปนี้คือตัวอย่างของการลบและการหาร

```js run
alert( 6 - '2' ); // 4, แปลง '2' เป็นตัวเลข
alert( '6' / '2' ); // 3, แปลงตัวถูกดำเนินการทั้งสองตัวเป็นตัวเลข
```

## การแปลงเป็นตัวเลข, unary +

เครื่องหมาย `+` มีสองรูปแบบคือ แบบ binary ที่ใช้ข้างบน และแบบ unary

unary plus หรือพูดอีกอย่างคือ ตัวดำเนินการบวก `+` ที่ใช้กับค่าเดี่ยว จะไม่ส่งผลอะไรกับตัวเลข แต่ถ้าตัวถูกดำเนินการไม่ใช่ตัวเลข unary plus จะแปลงให้เป็นตัวเลข

ตัวอย่างเช่น

```js run
// ไม่มีผลกับตัวเลข
let x = 1;
alert( +x ); // 1

let y = -2;
alert( +y ); // -2

*!*
// แปลงสิ่งที่ไม่ใช่ตัวเลข
alert( +true ); // 1
alert( +"" );   // 0
*/!*
```

โดยทำงานเหมือนกับ `Number(...)` เลย แต่เขียนได้สั้นกว่า

เรามักจำเป็นต้องแปลงสตริงเป็นตัวเลขอยู่บ่อยๆ เช่น เวลารับค่าจากช่องกรอกข้อมูลใน HTML ค่าเหล่านั้นมักอยู่ในรูปสตริง แล้วถ้าเราต้องการบวกมันเข้าด้วยกันล่ะ?

binary plus จะเอาสตริงมาต่อกัน

```js run
let apples = "2";
let oranges = "3";

alert( apples + oranges ); // "23", binary plus ต่อสตริงเข้าด้วยกัน
```

หากต้องการให้เป็นตัวเลข ต้องแปลงค่าก่อนแล้วจึงบวกกัน

```js run
let apples = "2";
let oranges = "3";

*!*
// ค่าทั้งสองถูกแปลงเป็นตัวเลขก่อนใช้ binary plus
alert( +apples + +oranges ); // 5
*/!*

// หรือเขียนแบบยาวๆ ก็ได้
// alert( Number(apples) + Number(oranges) ); // 5
```

มองในแง่ของนักคณิตศาสตร์ เครื่องหมายบวกที่เยอะแยะอาจดูแปลกๆ แต่สำหรับโปรแกรมเมอร์แล้วไม่มีอะไรพิเศษ unary plus จะถูกใช้กับค่าก่อน เพื่อแปลงสตริงเป็นตัวเลข จากนั้น binary plus จึงเอาตัวเลขมาบวกกัน

ทำไม unary plus ถึงถูกใช้กับค่าก่อน binary plus? อย่างที่เราจะได้เห็นต่อไป นั่นเป็นเพราะว่ามันมี *ลำดับความสำคัญ (precedence) ที่สูงกว่า*

## ลำดับความสำคัญของตัวดำเนินการ

หากนิพจน์มีตัวดำเนินการมากกว่าหนึ่งตัว ลำดับการประมวลผลจะถูกกำหนดโดย *ลำดับความสำคัญ* หรือพูดอีกนัยหนึ่งคือ ลำดับความสำคัญเริ่มต้นของตัวดำเนินการนั่นเอง

พวกเราทุกคนเรียนรู้ตั้งแต่สมัยอยู่ในโรงเรียนแล้วว่าในนิพจน์ `1 + 2 * 2` ต้องคำนวณการคูณก่อนการบวก นั่นแหละคือสิ่งที่เรียกว่าลำดับความสำคัญ การคูณถือว่ามี *ลำดับความสำคัญสูงกว่า* การบวก

วงเล็บสามารถแทนที่ลำดับความสำคัญใดๆ ก็ได้ ดังนั้นหากเราไม่พอใจกับลำดับเริ่มต้น เราก็สามารถใช้วงเล็บเพื่อเปลี่ยนแปลงได้ เช่น เขียนเป็น `(1 + 2) * 2`

JavaScript มีตัวดำเนินการอยู่มากมาย แต่ละตัวจะมีตัวเลขลำดับความสำคัญของตัวเอง ตัวที่มีค่ามากกว่าจะถูกประมวลผลก่อน หากลำดับความสำคัญเท่ากัน ลำดับการประมวลผลจะเป็นจากซ้ายไปขวา

ต่อไปนี้คือข้อมูลบางส่วนจาก[ตารางลำดับความสำคัญ](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence) (คุณไม่จำเป็นต้องจำ แต่ให้สังเกตว่า unary operator จะสูงกว่า binary operator ที่เทียบเท่ากัน):

| ลำดับความสำคัญ | ชื่อ | เครื่องหมาย |
|------------|------|------|
| ... | ... | ... |
| 14 | unary plus | `+` |
| 14 | unary negation | `-` |
| 13 | exponentiation | `**` |  
| 12 | multiplication | `*` |
| 12 | division | `/` |
| 11 | addition | `+` |
| 11 | subtraction | `-` |
| ... | ... | ... |
| 2 | assignment | `=` |
| ... | ... | ... |

ดังที่เห็น "unary plus" มีลำดับความสำคัญ `14` ซึ่งสูงกว่า "addition" (binary plus) ที่มีค่า `11` นั่นจึงเป็นเหตุผลว่าทำไมในนิพจน์ `"+apples + +oranges"` unary plus จึงทำงานก่อน addition

## การกำหนดค่า (Assignment)

เราขอเน้นย้ำว่า assignment `=` ก็ถือเป็นตัวดำเนินการเช่นกัน มันปรากฏอยู่ในตารางลำดับความสำคัญด้วยค่าที่ต่ำมากคือ `2`

นั่นจึงเป็นเหตุผลว่าทำไมเวลาที่เรากำหนดค่าให้กับตัวแปร เช่น `x = 2 * 2 + 1` การคำนวณจะเสร็จสิ้นก่อน แล้วจึงเริ่มประเมิน `=` และเก็บผลลัพธ์ไว้ใน `x`

```js
let x = 2 * 2 + 1;

alert( x ); // 5
```

### Assignment = คืนค่ากลับ

ข้อเท็จจริงที่ว่า `=` เป็นตัวดำเนินการ ไม่ใช่ส่วนประกอบ "วิเศษ" ของภาษา มีนัยยะบางอย่างที่น่าสนใจ

ตัวดำเนินการทุกตัวใน JavaScript จะคืนค่ากลับเสมอ ซึ่งชัดเจนสำหรับ `+` และ `-` รวมถึงเป็นความจริงสำหรับ `=` ด้วย

การเรียก `x = value` จะเขียน `value` ลงใน `x` *แล้วคืนค่านั้นกลับมา*

นี่คือตัวอย่างที่ใช้ assignment เป็นส่วนหนึ่งของนิพจน์ที่ซับซ้อนกว่า:

```js run
let a = 1;
let b = 2;

*!*
let c = 3 - (a = b + 1);
*/!*

alert( a ); // 3
alert( c ); // 0
```  

ในตัวอย่างข้างต้น ผลลัพธ์ของนิพจน์ `(a = b + 1)` คือค่าที่ถูก assign ให้ `a` (นั่นก็คือ `3`) ซึ่งถูกนำไปใช้ในการประเมินค่าต่อไป

โค้ดนี้ดูตลกไปหน่อยนะ เราควรเข้าใจว่ามันทำงานอย่างไร เพราะบางครั้งเราจะเห็นมันในไลบรารี JavaScript

อย่างไรก็ตาม โปรดอย่าเขียนโค้ดแบบนั้นเลย เล่ห์เหลี่ยมเช่นนี้ไม่ได้ช่วยให้โค้ดชัดเจนหรืออ่านง่ายขึ้นแน่นอน

### การต่อ assignment แบบลูกโซ่

อีกฟีเจอร์ที่น่าสนใจคือความสามารถในการต่อ assignment แบบลูกโซ่:  

```js run
let a, b, c;

*!*
a = b = c = 2 + 2;
*/!*

alert( a ); // 4
alert( b ); // 4
alert( c ); // 4
```

assignment แบบลูกโซ่จะถูกประเมินจากขวาไปซ้าย แรกสุด นิพจน์ `2 + 2` ทางขวาสุดจะถูกประเมิน แล้วจึง assign ให้กับตัวแปรทางซ้าย ได้แก่ `c`, `b` และ `a` ตามลำดับ ในท้ายที่สุด ตัวแปรทุกตัวจะมีค่าเดียวกัน

อีกครั้ง เพื่อความง่ายต่อการอ่าน เราควรแยกโค้ดแบบนี้ออกเป็นสองสามบรรทัด:

```js
c = 2 + 2;
b = c;
a = c;
```

แบบนี้อ่านง่ายกว่า โดยเฉพาะเวลาที่เรากวาดตามองโค้ดอย่างเร็วๆ

## การปรับค่าในตัวแปรโดยตรง

เรามักจะต้องนำตัวดำเนินการไปใช้กับตัวแปรและเก็บผลลัพธ์ใหม่ลงในตัวแปรนั้นเอง

ตัวอย่างเช่น:

```js
let n = 2;
n = n + 5;
n = n * 2;  
```

เราสามารถเขียนโค้ดข้างต้นให้สั้นลงได้โดยใช้ตัวดำเนินการ `+=` และ `*=`:

```js run
let n = 2;
n += 5; // ตอนนี้ n = 7 (เหมือนกับการเขียน n = n + 5)
n *= 2; // ตอนนี้ n = 14 (เหมือนกับการเขียน n = n * 2)

alert( n ); // 14  
```

ตัวดำเนินการ "ปรับค่าและกำหนดค่า" แบบสั้นๆ นี้มีให้ใช้งานสำหรับตัวดำเนินการทางคณิตศาสตร์และบิตไวส์ทุกตัว เช่น `/=`, `-=` เป็นต้น

ตัวดำเนินการเหล่านี้จะมีลำดับความสำคัญเท่ากับการกำหนดค่าปกติ ดังนั้นพวกมันจะทำงานหลังจากการคำนวณส่วนอื่นๆ เสร็จสิ้นแล้ว:

```js run
let n = 2;

n *= 3 + 5; // คำนวณทางด้านขวาก่อน เหมือนกับการเขียน n *= 8

alert( n ); // 16
```

## การเพิ่ม/ลดค่า

การเพิ่มหรือลดค่าตัวเลขทีละ 1 ถือเป็นหนึ่งในการดำเนินการทางตัวเลขที่ใช้บ่อยที่สุด 

ดังนั้น จึงมีตัวดำเนินการพิเศษสำหรับกรณีนี้:

- **Increment** `++` ใช้เพิ่มค่าตัวแปรขึ้นทีละ 1:

    ```js run no-beautify
    let counter = 2;
    counter++;        // ทำงานเหมือนกับ counter = counter + 1 แต่เขียนสั้นกว่า
    alert( counter ); // 3
    ```

- **Decrement** `--` ใช้ลดค่าตัวแปรลงทีละ 1:

    ```js run no-beautify
    let counter = 2;
    counter--;        // ทำงานเหมือนกับ counter = counter - 1 แต่เขียนสั้นกว่า  
    alert( counter ); // 1
    ```

```warn
Increment/decrement สามารถใช้ได้กับตัวแปรเท่านั้น หากพยายามใช้กับค่าตรงๆ เช่น `5++` จะทำให้เกิด error
```

ตัวดำเนินการ `++` และ `--` สามารถวางไว้ด้านหน้าหรือด้านหลังตัวแปรก็ได้

- เมื่อตัวดำเนินการอยู่หลังตัวแปร เรียกว่ารูปแบบ "postfix": `counter++`
- รูปแบบ "prefix" คือเมื่อตัวดำเนินการอยู่หน้าตัวแปร: `++counter` 

ทั้งสองแบบทำงานเหมือนกันคือเพิ่มค่า `counter` ขึ้น `1`

แล้วมีความแตกต่างกันไหม? มี แต่เราจะเห็นได้ก็ต่อเมื่อนำค่าที่ส่งกลับจาก `++/--` ไปใช้เท่านั้น

เรามาทำความเข้าใจให้ชัดเจนกัน อย่างที่ทราบกันว่าตัวดำเนินการทุกตัวจะส่งค่ากลับ Increment/decrement ก็เช่นกัน รูปแบบ prefix จะส่งค่าใหม่กลับ ส่วนรูปแบบ postfix จะส่งค่าเดิมก่อนการเพิ่ม/ลดค่ากลับ

ลองดูตัวอย่างนี้เพื่อให้เห็นความแตกต่าง:

```js run
let counter = 1;
let a = ++counter; // (*)

alert(a); // *!*2*/!*
```

ในบรรทัด `(*)` รูปแบบ *prefix* `++counter` จะเพิ่มค่า `counter` ก่อนแล้วส่งค่าใหม่ `2` กลับ ดังนั้น `alert` จึงแสดงเลข `2`

ทีนี้ลองใช้รูปแบบ postfix ดูบ้าง:

```js run
let counter = 1;
let a = counter++; // (*) เปลี่ยนจาก ++counter เป็น counter++

alert(a); // *!*1*/!*
```

ในบรรทัด `(*)` รูปแบบ *postfix* `counter++` ก็เพิ่มค่า `counter` เหมือนกัน แต่จะส่งค่า *เดิม* ก่อนการเพิ่มค่ากลับ ดังนั้น `alert` จึงแสดงเลข `1`

สรุปได้ดังนี้:

- ถ้าไม่ได้นำผลลัพธ์ของ increment/decrement ไปใช้ต่อ ไม่ว่าจะใช้รูปแบบไหนก็ไม่ต่างกัน:

    ```js run
    let counter = 0;
    counter++;
    ++counter;
    alert( counter ); // 2, บรรทัดข้างบนให้ผลเหมือนกัน
    ```

- ถ้าต้องการเพิ่มค่า *และ* นำผลลัพธ์ของตัวดำเนินการไปใช้ทันที ต้องใช้รูปแบบ prefix:

    ```js run  
    let counter = 0;
    alert( ++counter ); // 1
    ```

- ถ้าต้องการเพิ่มค่า แต่นำค่าก่อนหน้าไปใช้ ต้องใช้รูปแบบ postfix:

    ```js run
    let counter = 0;
    alert( counter++ ); // 0  
    ```

```smart header="Increment/decrement ท่ามกลางตัวดำเนินการอื่นๆ"
ตัวดำเนินการ `++/--` สามารถใช้ภายในนิพจน์ได้ด้วย ลำดับความสำคัญของมันสูงกว่าการดำเนินการทางคณิตศาสตร์ส่วนใหญ่

ตัวอย่างเช่น:

```js run
let counter = 1;
alert( 2 * ++counter ); // 4
```

เปรียบเทียบกับ:

```js run
let counter = 1;
alert( 2 * counter++ ); // 2, เพราะ counter++ ส่งค่า "เดิม" กลับ  
```

ถึงแม้ในแง่เทคนิคจะใช้ได้ แต่การเขียนแบบนี้มักจะทำให้โค้ดอ่านเข้าใจยากขึ้น เพราะทำหลายอย่างในบรรทัดเดียว ซึ่งไม่ค่อยดีนัก

ระหว่างอ่านโค้ด การสแกนตามแนวดิ่งอย่างรวดเร็วอาจมองข้าม `counter++` ไปได้ง่าย และมันก็ไม่ชัดเจนว่าค่าตัวแปรเพิ่มขึ้น

เราแนะนำให้เขียนแบบ "หนึ่งบรรทัด -- หนึ่งการกระทำ":

```js run
let counter = 1;
alert( 2 * counter );
counter++;
```
````

## ตัวดำเนินการแบบบิต (Bitwise Operators)

ตัวดำเนินการแบบบิตถืออาร์กิวเมนต์เป็นตัวเลขจำนวนเต็ม 32 บิต และทำงานในระดับการแสดงค่าแบบเลขฐานสอง

ตัวดำเนินการเหล่านี้ไม่ได้เฉพาะเจาะจงกับ JavaScript พวกมันรองรับในภาษาการเขียนโปรแกรมส่วนใหญ่

รายการของตัวดำเนินการ:

- AND ( `&` )
- OR ( `|` )
- XOR ( `^` )
- NOT ( `~` )
- LEFT SHIFT ( `<<` )
- RIGHT SHIFT ( `>>` )
- ZERO-FILL RIGHT SHIFT ( `>>>` )

ตัวดำเนินการเหล่านี้ใช้ไม่บ่อยนัก เมื่อเราต้องการปรับแต่งตัวเลขที่ระดับต่ำสุด (ระดับบิต) เราไม่จำเป็นต้องใช้ตัวดำเนินการเหล่านี้ในเร็วๆ นี้ เนื่องจากการพัฒนาเว็บใช้ประโยชน์จากมันน้อยมาก แต่ในบางพื้นที่พิเศษ เช่น การเข้ารหัส ตัวดำเนินการเหล่านี้มีประโยชน์ คุณสามารถอ่านบท Bitwise Operators: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#bitwise_operators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#bitwise_operators) บน MDN เมื่อจำเป็น

## เครื่องหมายจุลภาค (Comma)

เครื่องหมายจุลภาค `,` เป็นหนึ่งในตัวดำเนินการที่หายากและแปลกประหลาดที่สุด บางครั้งใช้เพื่อเขียนโค้ดให้สั้นลง ดังนั้นเราต้องรู้จักมันเพื่อให้เข้าใจว่าเกิดอะไรขึ้น

ตัวดำเนินการจุลภาคช่วยให้เราประเมินนิพจน์หลายนิพจน์ โดยใช้เครื่องหมายจุลภาค `,` คั่นระหว่างกัน แต่ละนิพจน์จะถูกประเมิน แต่ผลลัพธ์ของนิพจน์สุดท้ายเท่านั้นที่จะถูกส่งคืน

ตัวอย่างเช่น:

```js run
*!*
let a = (1 + 2, 3 + 4);
*/!*

alert( a ); // 7 (ผลลัพธ์ของ 3 + 4)
```

ในที่นี้ นิพจน์แรก `1 + 2` จะถูกประเมินและผลลัพธ์จะถูกทิ้ง จากนั้น `3 + 4` จะถูกประเมินและส่งคืนเป็นผลลัพธ์

```smart header="เครื่องหมายจุลภาคมีลำดับความสำคัญต่ำมาก"
โปรดทราบว่าตัวดำเนินการจุลภาคมีลำดับความสำคัญต่ำมาก ต่ำกว่า `=` ดังนั้นวงเล็บจึงสำคัญในตัวอย่างด้านบน

หากไม่มีวงเล็บ: `a = 1 + 2, 3 + 4` จะประเมิน `+` ก่อน บวกตัวเลขเป็น `a = 3, 7` จากนั้นตัวดำเนินการกำหนดค่า `=` จะกำหนด `a = 3` และส่วนที่เหลือจะถูกละเว้น เหมือนกับ `(a = 1 + 2), 3 + 4`.
```

แล้วทำไมเราถึงต้องการตัวดำเนินการที่ทิ้งทุกอย่างยกเว้นนิพจน์สุดท้ายล่ะ?

บางครั้ง คนใช้มันในโครงสร้างที่ซับซ้อนมากขึ้นเพื่อใส่หลายอย่างลงในบรรทัดเดียว

ตัวอย่างเช่น:

```js
// สามารถทำได้สามอย่างในหนึ่งบรรทัด
for (*!*a = 1, b = 3, c = a * b*/!*; a < 10; a++) {
 ...
}
```

เทคนิคแบบนี้ใช้กันในหลายเฟรมเวิร์ก JavaScript นั่นเป็นเหตุผลว่าทำไมเราถึงพูดถึงมัน แต่โดยปกติแล้ว มันไม่ช่วยให้โค้ดอ่านง่ายขึ้น ดังนั้นเราควรคิดให้ดีก่อนใช้มัน
