# ชนิดข้อมูล

ค่าใน JavaScript จะมีชนิดข้อมูลเฉพาะเสมอ เช่น `string` หรือ `number`

ใน JavaScript มีชนิดข้อมูลพื้นฐาน 8 ประเภท ในที่นี้เราจะกล่าวถึงภาพรวมของแต่ละประเภท และในบทต่อๆ ไปจะอธิบายแต่ละประเภทอย่างละเอียด

เราสามารถใส่ค่าชนิดใดก็ได้ลงในตัวแปร ยกตัวอย่างเช่น ตัวแปรหนึ่งอาจเป็น `string` ได้ในขณะหนึ่ง แล้วเก็บ `number` ในอีกขณะหนึ่ง:

```js
// ไม่มี error
let message = "hello";
message = 123456;
```

ภาษาโปรแกรมที่อนุญาตให้ทำเช่นนี้ได้ เช่น JavaScript จะเรียกว่า "dynamically typed" ซึ่งหมายความว่ามีชนิดข้อมูลหลากหลาย แต่ตัวแปรไม่จำเป็นต้องถูกผูกไว้กับชนิดข้อมูลใดชนิดหนึ่งตายตัว

## Number

```js
let n = 123;
n = 12.345;
```

ชนิดข้อมูล *number* ใช้แทนได้ทั้งจำนวนเต็มและจำนวนทศนิยม

มีตัวดำเนินการหลายอย่างสำหรับจำนวน เช่น การคูณ `*`, การหาร `/`, การบวก `+`, การลบ `-` และอื่นๆ

นอกเหนือจากตัวเลขทั่วไปแล้ว ยังมีค่าที่เรียกว่า "ค่าตัวเลขพิเศษ" ซึ่งก็จัดอยู่ในชนิดข้อมูลนี้ด้วย ได้แก่ `Infinity`, `-Infinity` และ `NaN`

- `Infinity` หมายถึง [อนันต์](https://en.wikipedia.org/wiki/Infinity) ∞ ในเชิงคณิตศาสตร์ เป็นค่าพิเศษที่มากกว่าตัวเลขใดๆ 

    เราอาจได้ค่านี้จากการหารด้วยศูนย์:

    ```js run
    alert( 1 / 0 ); // Infinity
    ```

    หรืออ้างอิงถึงโดยตรง:

    ```js run
    alert( Infinity ); // Infinity
    ```

- `NaN` หมายถึงความผิดพลาดในการคำนวณ เป็นผลลัพธ์จากการดำเนินการทางคณิตศาสตร์ที่ไม่ถูกต้องหรือไม่ได้กำหนดไว้ เช่น:

    ```js run
    alert( "not a number" / 2 ); // NaN เพราะการหารแบบนี้ผิด  
    ```

    `NaN` มีคุณสมบัติเหนียว การดำเนินการทางคณิตศาสตร์ใดๆ กับ `NaN` จะให้ผลลัพธ์เป็น `NaN` เสมอ:

    ```js run
    alert( NaN + 1 ); // NaN
    alert( 3 * NaN ); // NaN
    alert( "not a number" / 2 - 1 ); // NaN
    ```

    ดังนั้นถ้ามี `NaN` อยู่ในนิพจน์ทางคณิตศาสตร์ตรงไหน มันจะแผ่ขยายไปทั่วผลลัพธ์ทั้งหมด (มีข้อยกเว้นเพียงอย่างเดียวคือ `NaN ** 0` จะเป็น `1`)

```smart header="การดำเนินการทางคณิตศาสตร์มีความปลอดภัย"
การคำนวณทางคณิตศาสตร์ใน JavaScript นั้น "ปลอดภัย" เราสามารถทำอะไรก็ได้ เช่น หารด้วยศูนย์ หรือดำเนินการกับสตริงที่ไม่ใช่ตัวเลขเหมือนเป็นตัวเลข เป็นต้น 

สคริปต์จะไม่มีวันหยุดทำงานด้วย fatal error ("ตาย") ในกรณีที่แย่ที่สุด ผลลัพธ์ที่ได้จะเป็น `NaN`
```

อย่างเป็นทางการแล้วค่าตัวเลขพิเศษเหล่านี้จัดอยู่ในชนิดข้อมูล "number" แต่แน่นอนว่ามันไม่ใช่ตัวเลขในความหมายทั่วไปของคำนี้

เราจะเรียนรู้เพิ่มเติมเกี่ยวกับการใช้งานตัวเลขในบทเรียน <info:number>

## BigInt [#bigint-type]

ในภาษา JavaScript ชนิดข้อมูล "number" ไม่สามารถแสดงค่าจำนวนเต็มที่มากกว่า <code>(2<sup>53</sup>-1)</code> (ซึ่งก็คือ `9007199254740991`) หรือน้อยกว่า <code>-(2<sup>53</sup>-1)</code> สำหรับจำนวนลบได้อย่างปลอดภัย

ถ้าจะให้พูดให้ถูกต้องจริงๆ ชนิดข้อมูล "number" จะเก็บจำนวนเต็มที่ใหญ่กว่านั้นได้ (สูงสุดถึง <code>1.7976931348623157 * 10<sup>308</sup></code>) แต่นอกเหนือจากช่วงจำนวนเต็มที่ปลอดภัยคือ <code>±(2<sup>53</sup>-1)</code> แล้ว จะมีข้อผิดพลาดในการแสดงตัวเลขที่ละเอียด เพราะไม่สามารถเก็บตัวเลขได้ทุกหลักในพื้นที่จัดเก็บแบบคงที่ขนาด 64 บิต ดังนั้นค่าที่เก็บอาจจะเป็นค่า "โดยประมาณ"

ยกตัวอย่างเช่น จำนวนสองตัวนี้ (ที่อยู่เหนือช่วงปลอดภัยเล็กน้อย) จะมีค่าเท่ากัน:

```js
console.log(9007199254740991 + 1); // 9007199254740992
console.log(9007199254740991 + 2); // 9007199254740992
```

หรือพูดได้ว่า จำนวนเต็มคี่ทุกตัวที่มากกว่า <code>(2<sup>53</sup>-1)</code> จะไม่สามารถเก็บในชนิดข้อมูล "number" ได้เลย

ในการใช้งานส่วนใหญ่ ช่วง <code>±(2<sup>53</sup>-1)</code> ก็เพียงพอแล้ว แต่บางครั้งเราอาจต้องการช่วงของจำนวนเต็มที่ใหญ่จริงๆ เช่น สำหรับการเข้ารหัสลับหรือการระบุเวลาแบบละเอียดถึงระดับไมโครวินาที

ชนิดข้อมูล `BigInt` ได้ถูกเพิ่มเข้ามาในภาษาเมื่อไม่นานมานี้ เพื่อใช้แสดงจำนวนเต็มที่มีความยาวเท่าใดก็ได้

สร้างค่า `BigInt` ได้โดยใส่ `n` ต่อท้ายจำนวนเต็ม:

```js
// ตัว "n" ท้ายสุดหมายความว่าเป็น BigInt
const bigInt = 1234567890123456789012345678901234567890n;
```

เนื่องจากไม่ค่อยได้ใช้ตัวเลข `BigInt` บ่อยนัก เราจึงไม่ขอลงรายละเอียดในที่นี้ แต่จะแยกอธิบายไว้ในบทเรียน <info:bigint> อ่านได้เมื่อคุณต้องการใช้จำนวนขนาดใหญ่มากๆ นะ


```smart header="ปัญหาความเข้ากันได้"
ปัจจุบัน `BigInt` รองรับใน Firefox/Chrome/Edge/Safari แต่ยังไม่รองรับใน IE 
```

คุณสามารถดูได้จาก [ตารางความเข้ากันได้ของ BigInt บน *MDN*](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt#Browser_compatibility) ว่ารองรับในเบราว์เซอร์เวอร์ชันใดบ้าง

## String

ใน JavaScript string ต้องถูกล้อมรอบด้วยเครื่องหมายคำพูด

```js
let str = "Hello";
let str2 = 'ใช้เครื่องหมายคำพูดเดี่ยวก็ได้';
let phrase = `สามารถฝัง ${str} ได้ด้วย`;
```

ใน JavaScript มีเครื่องหมายคำพูด 3 แบบ

1. เครื่องหมายคำพูดคู่: `"สวัสดี"`
2. เครื่องหมายคำพูดเดี่ยว: `'สวัสดี'`
3. แบ็กติก (Backticks): <code>&#96;สวัสดี&#96;</code>

เครื่องหมายคำพูดคู่และเดี่ยวเป็นแบบ "ธรรมดา" ในทางปฏิบัติแล้วไม่มีความแตกต่างระหว่างสองแบบนี้ใน JavaScript

ส่วนแบ็กติกเป็นเครื่องหมายคำพูดที่มี "ฟังก์ชันเพิ่มเติม" มันช่วยให้เราสามารถแทรกตัวแปรและนิพจน์ลงใน string ได้ โดยครอบด้วย `${…}` เช่น:

```js run
let name = "สมชาย";

// แทรกตัวแปร
alert( `สวัสดี *!*${name}*/!*!` ); // สวัสดี สมชาย!

// แทรกนิพจน์
alert( `ผลลัพธ์คือ *!*${1 + 2}*/!*` ); // ผลลัพธ์คือ 3
```

นิพจน์ภายใน `${…}` จะถูกประเมินค่า และผลลัพธ์จะกลายเป็นส่วนหนึ่งของ string เราสามารถใส่อะไรก็ได้ลงไปในนั้น ไม่ว่าจะเป็นตัวแปรอย่าง `name` หรือนิพจน์ทางคณิตศาสตร์อย่าง `1 + 2` หรือสิ่งที่ซับซ้อนกว่านั้น

โปรดจำไว้ว่า การแทรกเช่นนี้ทำได้เฉพาะในแบ็กติกเท่านั้น เครื่องหมายคำพูดรูปแบบอื่นไม่มีความสามารถในการแทรกแบบนี้!

```js run
alert( "ผลลัพธ์คือ ${1 + 2}" ); // ผลลัพธ์คือ ${1 + 2} (เครื่องหมายคำพูดคู่ไม่ได้แทรกอะไร)
```

เราจะพูดถึง string อย่างละเอียดอีกครั้งในบทเรียน <info:string>

```smart header="ไม่มีชนิดข้อมูล *ตัวอักษร*"
ในบางภาษา จะมีชนิดข้อมูลพิเศษ "ตัวอักษร" ไว้แทนอักขระตัวเดียว เช่นในภาษา C และ Java จะเรียกว่า "char"

แต่ใน JavaScript ไม่มีชนิดข้อมูลเช่นนั้น มีเพียงชนิด `string` เท่านั้น ซึ่ง string อาจเป็นอักขระศูนย์ตัว (ว่างเปล่า), หนึ่งตัว หรือหลายตัวก็ได้
```

## Boolean (ชนิดข้อมูลตรรกะ)

ชนิดข้อมูล boolean มีค่าได้เพียงสองค่าเท่านั้น คือ `true` และ `false`

ชนิดข้อมูลนี้มักใช้สำหรับเก็บค่าแบบ ใช่/ไม่ใช่ โดย `true` หมายถึง "ใช่ ถูกต้อง" ส่วน `false` หมายถึง "ไม่ใช่ ไม่ถูกต้อง" 

ยกตัวอย่างเช่น:

```js
let nameFieldChecked = true; // ใช่ ช่องชื่อถูกเลือก
let ageFieldChecked = false; // ไม่ใช่ ช่องอายุไม่ได้ถูกเลือก
```

นอกจากนี้ ค่า boolean ยังเป็นผลลัพธ์ที่ได้จากการเปรียบเทียบด้วย:

```js run
let isGreater = 4 > 1;

alert( isGreater ); // true (ผลการเปรียบเทียบคือ "ใช่")
```

เราจะกล่าวถึง boolean โดยละเอียดอีกครั้งในบทเรียน <info:logical-operators>

## ค่า "null" 

ค่าพิเศษ `null` ไม่ได้จัดอยู่ในชนิดข้อมูลที่กล่าวมาข้างต้นเลย

มันเป็นชนิดข้อมูลแยกต่างหาก ที่มีเพียงค่า `null` เท่านั้น:

```js
let age = null;
```

ใน JavaScript `null` ไม่ใช่ "การอ้างอิงถึงออบเจ็กต์ที่ไม่มีอยู่จริง" หรือ "null pointer" เหมือนในบางภาษา

แต่เป็นค่าพิเศษ ที่ใช้แทนความหมาย "ไม่มีอะไร", "ว่างเปล่า" หรือ "ไม่ทราบค่า"

ในตัวอย่างโค้ดข้างต้น หมายความว่า `age` เป็นค่าที่ไม่ทราบ

## ค่า "undefined"

ค่าพิเศษ `undefined` นั้นมีลักษณะเฉพาะตัว โดยจัดเป็นชนิดข้อมูลแยกออกมาต่างหาก เช่นเดียวกับ `null`

ความหมายของ `undefined` คือ "ยังไม่ได้กำหนดค่า"

หากตัวแปรถูกประกาศแต่ยังไม่ได้กำหนดค่า ค่าของตัวแปรนั้นจะเป็น `undefined`:

```js run
let age;

alert(age); // แสดงผลเป็น "undefined"
```

ในทางเทคนิค เราสามารถกำหนดค่า `undefined` ให้กับตัวแปรได้อย่างชัดเจน:

```js run
let age = 100;

// เปลี่ยนค่าเป็น undefined
age = undefined;

alert(age); // แสดงผลเป็น "undefined"
```

อย่างไรก็ตาม เราไม่แนะนำให้ทำเช่นนั้น โดยทั่วไปแล้ว นิยมใช้ `null` เพื่อกำหนดค่า "ว่างเปล่า" หรือ "ไม่ทราบค่า" ให้กับตัวแปร ส่วน `undefined` จะถูกสงวนไว้ใช้เป็นค่าเริ่มต้นสำหรับสิ่งที่ยังไม่ได้รับการกำหนดค่า

## Object และ Symbol

ชนิดข้อมูล `object` นั้นมีความพิเศษ

ชนิดข้อมูลอื่นๆ ทั้งหมดเรียกว่า "primitive" เนื่องจากค่าของชนิดข้อมูลเหล่านั้นสามารถเก็บได้เพียงสิ่งเดียว (ไม่ว่าจะเป็น string, number หรืออย่างอื่น) ในทางตรงกันข้าม object ใช้สำหรับเก็บชุดของข้อมูลและสิ่งที่มีโครงสร้างซับซ้อนกว่า

ด้วยความสำคัญดังกล่าว object จึงสมควรได้รับการจัดการเป็นพิเศษ เราจะกล่าวถึงรายละเอียดเกี่ยวกับ object ในบท <info:object> หลังจากที่เราได้เรียนรู้เพิ่มเติมเกี่ยวกับ primitive แล้ว

ชนิดข้อมูล `symbol` ใช้สำหรับสร้างตัวระบุ (identifier) ที่ไม่ซ้ำกันสำหรับ object เราจำเป็นต้องกล่าวถึงมันที่นี่เพื่อให้ครบถ้วน แต่จะเลื่อนรายละเอียดไปจนกว่าเราจะเข้าใจเรื่อง object

## typeof operator [#type-typeof]

`typeof` operator จะคืนค่าชนิดข้อมูลของ operand มันมีประโยชน์เมื่อเราต้องการประมวลผลค่าที่มีชนิดข้อมูลแตกต่างกัน หรือเพียงแค่ต้องการตรวจสอบแบบรวดเร็ว

การเรียกใช้ `typeof x` จะคืนค่าเป็น string ที่ระบุชื่อชนิดข้อมูล:

```js
typeof undefined // "undefined"

typeof 0 // "number"

typeof 10n // "bigint"

typeof true // "boolean"

typeof "foo" // "string"

typeof Symbol("id") // "symbol"

*!*
typeof Math // "object"  (1)
*/!*

*!*
typeof null // "object"  (2)
*/!*

*!*
typeof alert // "function"  (3)
*/!*
```

สามบรรทัดสุดท้ายอาจต้องมีคำอธิบายเพิ่มเติม:

1. `Math` เป็น built-in object ที่มีฟังก์ชันทางคณิตศาสตร์ให้ใช้งาน เราจะเรียนรู้เพิ่มเติมในบท <info:number> ที่นี่ใช้เพียงเป็นตัวอย่างของ object เท่านั้น
2. ผลลัพธ์ของ `typeof null` คือ `"object"` ซึ่งเป็นข้อผิดพลาดที่ยอมรับอย่างเป็นทางการใน `typeof` โดยมีมาตั้งแต่ยุคแรกเริ่มของ JavaScript และคงไว้เพื่อให้เข้ากันได้กับโค้ดเก่า อันที่จริง `null` ไม่ใช่ object แต่เป็นค่าพิเศษที่มีชนิดข้อมูลเป็นของตัวเอง การทำงานของ `typeof` ในกรณีนี้จึงไม่ถูกต้อง
3. ผลลัพธ์ของ `typeof alert` คือ `"function"` เพราะ `alert` เป็นฟังก์ชัน เราจะศึกษาเกี่ยวกับฟังก์ชันในบทถัดๆ ไป โดยจะเห็นว่าไม่มีชนิดข้อมูล "function" โดยเฉพาะใน JavaScript ฟังก์ชันจัดเป็นส่วนหนึ่งของชนิดข้อมูล object แต่ `typeof` ปฏิบัติต่อฟังก์ชันแตกต่างออกไป โดยคืนค่าเป็น `"function"` ซึ่งก็เป็นพฤติกรรมที่มีมาตั้งแต่ยุคแรกเริ่มของ JavaScript ในทางเทคนิคแล้ว พฤติกรรมดังกล่าวไม่ถูกต้อง แต่ในทางปฏิบัติอาจสะดวกกว่า

```smart header="ไวยากรณ์ `typeof(x)`"
คุณอาจเจอไวยากรณ์รูปแบบอื่นด้วย เช่น `typeof(x)` ซึ่งมีความหมายเหมือนกับ `typeof x` 

เพื่อให้ชัดเจน: `typeof` เป็น operator ไม่ใช่ฟังก์ชัน วงเล็บที่เห็นไม่ใช่ส่วนหนึ่งของ `typeof` แต่เป็นวงเล็บที่ใช้เพื่อจัดกลุ่มในเชิงคณิตศาสตร์

โดยปกติวงเล็บแบบนี้จะใช้ครอบนิพจน์ทางคณิตศาสตร์ เช่น `(2 + 2)` แต่ในที่นี้มีเพียงอาร์กิวเมนต์เดียวคือ `(x)` ในแง่ของไวยากรณ์ มันช่วยให้ไม่ต้องเว้นวรรคระหว่าง operator `typeof` กับอาร์กิวเมนต์ และบางคนชอบใช้แบบนี้

อย่างไรก็ตาม ไวยากรณ์ `typeof x` ยังคงเป็นที่นิยมใช้กันมากกว่า `typeof(x)` แม้ว่าบางคนจะชอบใช้รูปแบบหลังก็ตาม  
```

## สรุป

ใน JavaScript มีชนิดข้อมูลพื้นฐาน 8 ชนิด ได้แก่

- ชนิดข้อมูล primitive 7 ชนิด:
    - `number` สำหรับตัวเลขทุกประเภท ทั้งจำนวนเต็มและทศนิยม โดยจำนวนเต็มจะมีขอบเขตอยู่ที่ <code>±(2<sup>53</sup>-1)</code>
    - `bigint` สำหรับจำนวนเต็มที่มีความยาวเท่าใดก็ได้
    - `string` สำหรับข้อความ โดยข้อความอาจมีตัวอักษรตั้งแต่ศูนย์ตัวขึ้นไป และไม่มีชนิดข้อมูลแยกต่างหากสำหรับตัวอักษรเพียงหนึ่งตัว
    - `boolean` สำหรับค่า `true` หรือ `false`
    - `null` สำหรับค่าที่ไม่ทราบ เป็นชนิดข้อมูลแยกต่างหากที่มีค่าเพียงค่าเดียวคือ `null`
    - `undefined` สำหรับค่าที่ยังไม่ได้กำหนด เป็นชนิดข้อมูลแยกต่างหากที่มีค่าเพียงค่าเดียวคือ `undefined`
    - `symbol` สำหรับการสร้างตัวระบุที่ไม่ซ้ำกัน
- และชนิดข้อมูลที่ไม่ใช่ primitive 1 ชนิด:
    - `object` สำหรับโครงสร้างข้อมูลที่มีความซับซ้อนมากขึ้น

`typeof` operator ช่วยให้เราสามารถตรวจสอบชนิดข้อมูลที่ถูกเก็บอยู่ในตัวแปรได้

- โดยทั่วไปใช้ในรูปแบบ `typeof x` แต่ `typeof(x)` ก็สามารถใช้ได้เช่นกัน
- คืนค่าเป็น string ที่ระบุชื่อชนิดข้อมูล เช่น `"string"`
- สำหรับ `null` จะคืนค่าเป็น `"object"` ซึ่งถือเป็นข้อผิดพลาดในภาษา เพราะจริง ๆ แล้ว `null` ไม่ใช่ object

ในบทต่อ ๆ ไป เราจะมุ่งเน้นไปที่ค่า primitive และเมื่อเราคุ้นเคยกับมันแล้ว เราจะเริ่มศึกษาเกี่ยวกับ object ต่อไป