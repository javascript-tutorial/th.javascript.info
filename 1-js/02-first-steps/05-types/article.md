## ประเภทข้อมูล

ค่าใน JavaScript มักจะมีประเภทข้อมูลเสมอ ตัวอย่างเช่น สตริงหรือตัวเลข

มีแปดประเภทข้อมูลพื้นฐานใน JavaScript ในบทนี้เราจะกล่าวถึงพวกมันโดยทั่วไปและในบทต่อไปเราจะพูดถึงแต่ละประเภทโดยละเอียด

เราสามารถใส่ข้อมูลประเภทใดก็ได้ลงในตัวแปร ตัวอย่างเช่น ตัวแปรตัวหนึ่งอาจเป็นสตริงชั่วขณะหนึ่งแล้วเปลี่ยนเป็นตัวเลข:

```js
// ไม่มีข้อผิดพลาด
let message = "สวัสดี";
message = 123456;
```

ภาษาโปรแกรมที่อนุญาตให้ทำสิ่งเหล่านี้ เช่น JavaScript เราเรียกว่า "แบบไดนามิก" หมายความว่าตัวแปรไม่ผูกกับประเภทข้อมูลใดประเภทหนึ่ง

## ตัวเลข

```js
let n = 123;
n = 12.345;
```

ประเภท *number* แสดงทั้งเลขจำนวนเต็มและเลขจุดทศนิยม

มีการดำเนินการต่างๆ สำหรับตัวเลข เช่น การคูณ `*` การหาร `/` การบวก `+` การลบ `-` เป็นต้น

นอกเหนือจากตัวเลขปกติแล้วยังมี "ค่าตัวเลขพิเศษ" ซึ่งอยู่ในประเภทข้อมูลนี้ด้วย: `Infinity`, `-Infinity` และ `NaN`

- `Infinity` แสดงถึงอินฟินิตี้ทางคณิตศาสตร์ อินฟินิตี้: [https://th.wikipedia.org/wiki/](https://th.wikipedia.org/wiki/)อินฟินิตี้ ∞ มันเป็นค่าพิเศษที่มากกว่าจำนวนใดๆ

  เราสามารถรับมันเป็นผลลัพธ์ของการหารด้วยศูนย์:

    ```js run
    alert( 1 / 0 ); // Infinity
    ```

  หรือง่ายๆ ก็คืออ้างอิงโดยตรง:

    ```js run
    alert( Infinity ); // Infinity
    ```
- `NaN` แสดงถึงข้อผิดพลาดในการคำนวณ เป็นผลลัพธ์ของการดำเนินการทางคณิตศาสตร์ที่ไม่ถูกต้อง ตัวอย่างเช่น:

    ```js run
    alert( "ไม่ใช่ตัวเลข" / 2 ); // NaN การหารดังกล่าวไม่ถูกต้อง
    ```

  สำหรับ `NaN` การดำเนินการทางคณิตศาสตร์เพิ่มเติมใดๆ กับ `NaN` จะส่งคืน `NaN`:

    ```js run
    alert( NaN + 1 ); // NaN
    alert( 3 * NaN ); // NaN
    alert( "ไม่ใช่ตัวเลข" / 2 - 1 ); // NaN
    ```

  ดังนั้น หากมี `NaN` อยู่ที่ใดก็ตามในนิพจน์ทางคณิตศาสตร์ มันจะแพร่กระจายไปยังผลลัพธ์ทั้งหมด (มีเพียงข้อเดียวที่ยกเว้น: `NaN ** 0` คือ `1`)

```smart header="การดำเนินการทางคณิตศาสตร์มีความปลอดภัย"
การทำคณิตศาสตร์ "ปลอดภัย" ใน JavaScript เราสามารถทำอะไรก็ได้: หารด้วยศูนย์ ปฏิบัติต่อสตริงที่ไม่ใช่ตัวเลขเป็นตัวเลข ฯลฯ

สคริปต์จะไม่หยุดทำงานด้วยข้อผิดพลาดร้ายแรง ("ตาย") อย่างแย่ที่สุด เราจะได้รับ `NaN` เป็นผลลัพธ์
```

ค่าตัวเลขพิเศษโดยทางการเป็นส่วนหนึ่งของประเภท "number" แน่นอนว่าพวกมันไม่ใช่ตัวเลขในความหมายทั่วไปของคำนี้

เราจะเห็นเพิ่มเติมเกี่ยวกับการทำงานกับตัวเลขในบท <info:number>.

## BigInt [#bigint-type]

ใน JavaScript ประเภท "number" ไม่สามารถแสดงค่าจำนวนเต็มที่มากกว่า `(2<sup>53</sup>-1)` (นั่นคือ `9007199254740991`) หรือ น้อยกว่า `-(2<sup>53</sup>-1)` สำหรับค่าลบ

เพื่อให้อ่านง่าย ประเภท "number" สามารถเก็บจำนวนเต็มที่ใหญ่กว่า (สูงสุดถึง <code>1.7976931348623157 * 10<sup>308</sup></code>) แต่ภายนอกช่วงจำนวนเต็มที่ปลอดภัย <code>±(2<sup>53</sup>-1)</code> จะมีข้อผิดพลาดเรื่องความแม่นยำ เนื่องจากไม่สามารถใส่ตัวเลขทั้งหมดลงในที่เก็บข้อมูล 64 บิตที่ไว้ได้ ดังนั้นจึงเก็บค่า "โดยประมาณ" ไว้แทน

ตัวอย่างเช่น สองตัวเลขนี้ (อยู่เหนือช่วงที่ปลอดภัย) จะเท่ากัน:

```js
console.log(9007199254740991 + 1); // 9007199254740992
console.log(9007199254740991 + 2); // 9007199254740992
```

หมายความว่า จำนวนเต็มคี่ทั้งหมดที่มากกว่า `(2^53-1)` ไม่สามารถเก็บไว้ในประเภท "number" ได้เลย

สำหรับการใช้งานส่วนใหญ่ ช่วง `±(2^53-1)` ก็เพียงพอแล้ว แต่บางครั้งเราต้องการช่วงทั้งหมดของจำนวนเต็มขนาดใหญ่มาก เช่น สำหรับการเข้ารหัสหรือการประทับเวลาความแม่นยำระดับไมโครวินาที

ประเภท `BigInt` เพิ่งถูกเพิ่มเข้ามาในภาษาเพื่อแทนจำนวนเต็มที่มีความยาวไม่จำกัด

ค่า `BigInt` ถูกสร้างขึ้นโดยการต่อ "n" ที่ท้ายของจำนวนเต็ม:

```js
// "n" ที่ท้ายหมายถึงเป็น BigInt
const bigInt = 1234567890123456789012345678901234567890n;
```

เนื่องจากตัวเลข `BigInt` นั้นไม่ค่อยจำเป็น เราจึงไม่ได้เจาะลึกลงไปในบทนี้ แต่ได้อุทิศบทแยกต่างหากให้กับพวกเขา <info:bigint> อ่านเมื่อคุณต้องการตัวเลขขนาดใหญ่เช่นนี้

```smart header="ปัญหาความเข้ากันได้"
ตอนนี้ `BigInt` รองรับใน Firefox/Chrome/Edge/Safari แต่ไม่รองรับใน IE
```

คุณสามารถตรวจสอบ *ตารางความเข้ากันได้ MDN BigInt*: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt#Browser_compatibility](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt#Browser_compatibility) เพื่อทราบว่าเวอร์ชันใดของเบราว์เซอร์ที่รองรับ

## สตริง (String)

สตริงใน JavaScript ต้องล้อมรอบด้วยเครื่องหมายอัญประกาศ

```javascript
let str = "สวัสดี";
let str2 = 'อัญประกาศเดี่ยวก็ใช้ได้เช่นกัน';
let phrase = `สามารถฝังตัวแปรอื่นได้ ${str}`;
```

ใน JavaScript มีเครื่องหมายอัญประกาศ 3 ประเภท

1. อัญประกาศคู่: `"สวัสดี"`
2. อัญประกาศเดี่ยว: `'สวัสดี'`.
3. แบ็คทิก: `<code>&#96;สวัสดี&#96;</code>`.

อัญประกาศคู่และเดี่ยวเป็นอัญประกาศแบบ "ธรรมดา" ใน JavaScript แทบไม่มีความแตกต่างกัน

แบ็คทิกเป็นอัญประกาศแบบ "ฟังก์ชันขยาย" อนุญาตให้เราฝังตัวแปรและนิพจน์ลงในสตริงได้โดยการห่อด้วย `${…}` ตัวอย่างเช่น:

```javascript
let name = "จอห์น";

// ฝังตัวแปร
alert( `สวัสดี, *!*${name}*/!*!` ); // สวัสดี, จอห์น!

// ฝังนิพจน์
alert( `ผลลัพธ์คือ *!*${1 + 2}*/!*` ); // ผลลัพธ์คือ 3
```

นิพจน์ภายใน `${…}` จะถูกประเมินและผลลัพธ์จะกลายเป็นส่วนหนึ่งของสตริง เราสามารถใส่อะไรก็ได้ในนั้น: ตัวแปรเช่น `name` หรือนิพจน์เลขคณิตเช่น `1 + 2` หรือสิ่งที่ซับซ้อนกว่านั้น

โปรดทราบว่าสิ่งนี้ทำได้เฉพาะในแบ็คทิกเท่านั้น อัญประกาศอื่นไม่มีฟังก์ชันฝังตัวนี้!
```javascript
alert( "ผลลัพธ์คือ ${1 + 2}" ); // ผลลัพธ์คือ ${1 + 2} (อัญประกาศคู่ไม่ทำงาน)
```

เราจะครอบคลุมสตริงเพิ่มเติมในบท <info:string>

```smart header="ไม่มีประเภทตัวอักษร (Character)"
ในบางภาษา มีประเภท "character" พิเศษสำหรับตัวอักษรตัวเดียว ตัวอย่างเช่น ในภาษา C และ Java เรียกว่า "char"

ใน JavaScript ไม่มีประเภทดังกล่าว มีเพียงประเภทเดียวเท่านั้น: string สตริงอาจประกอบด้วยตัวอักษรศูนย์ตัว (ว่างเปล่า) หนึ่งตัว หรือหลายตัว
```

## บูลีน (ประเภทตรรกะ)

ประเภทบูลีนมีค่าเพียงสองค่าเท่านั้น: `true` และ `false`

ประเภทนี้มักใช้ในการเก็บค่าใช่/ไม่ใช่: `true` หมายถึง "ใช่, ถูกต้อง" และ `false` หมายถึง "ไม่, ไม่ถูกต้อง"

ตัวอย่างเช่น:

```js
let nameFieldChecked = true; // ใช่ ช่องชื่อถูกเลือก
let ageFieldChecked = false; // ไม่ ช่องอายุยังไม่ถูกเลือก
```

ค่าบูลีนยังเป็นผลลัพธ์ของการเปรียบเทียบ:

```js run
let isGreater = 4 > 1;

alert( isGreater ); // true (ผลลัพธ์การเปรียบเทียบคือ "ใช่")
```

เราจะเจาะลึกเกี่ยวกับบูลีนเพิ่มเติมในบท <info:logical-operators>

## ค่า "null"

ค่าพิเศษ `null` ไม่ใช่หนึ่งในประเภทที่อธิบายไว้ข้างต้น

มันก่อให้เกิดประเภทแยกต่างหากของตัวเองซึ่งมีเพียงค่า `null`:

```js
let age = null;
```

ใน JavaScript, `null` ไม่ใช่ "การอ้างอิงถึงอ็อบเจ็กต์ที่ไม่มีอยู่" หรือ "null pointer" เช่นเดียวกับภาษาอื่นๆ

มันเป็นเพียงค่าพิเศษที่แสดงถึง "ไม่มีอะไร", "ว่างเปล่า" หรือ "ค่าไม่ทราบ"

โค้ดข้างต้นระบุว่าไม่ทราบ `age`

## ค่า "undefined"

ค่าพิเศษ `undefined` ก็โดดเด่นเช่นกัน มันสร้างประเภทของตัวเอง เช่นเดียวกับ `null`

ความหมายของ `undefined` คือ "ยังไม่ได้กำหนดค่า"

ถ้าตัวแปรถูกประกาศ แต่ไม่ได้กำหนดค่า ค่าของมันจะเป็น `undefined`:

```js run
let age;

alert(age); // แสดง "undefined"
```

ในทางเทคนิค คุณสามารถกำหนด `undefined` ให้กับตัวแปรไปตรงๆเลยก็ได้:

```js run
let age = 100;

// เปลี่ยนค่าเป็น undefined
age = undefined;

alert(age); // "undefined"
```

...แต่เราไม่แนะนำให้ทำเช่นนั้น โดยปกติ เราใช้ `null` เพื่อกำหนดค่า "ว่างเปล่า" หรือ "ไม่ทราบ" ให้กับตัวแปร ในขณะที่ `undefined` ถูกสงวนไว้เป็นค่าเริ่มต้นสำหรับสิ่งที่ยังไม่ได้กำหนดค่า

## อ็อบเจ็กต์และสัญลักษณ์ (Symbols)

ประเภท `object` มีความพิเศษ

ประเภทอื่นๆ ทั้งหมดเรียกว่า "primitive" เนื่องจากค่าของพวกมันสามารถมีเพียงสิ่งเดียวได้ (ไม่ว่าจะเป็นสตริง ตัวเลข หรืออะไรก็ตาม) ในทางตรงกันข้าม อ็อบเจ็กต์ใช้สำหรับจัดเก็บคอลเลกชันของข้อมูลและเอนทิตีที่ซับซ้อนมากขึ้น

เนื่องจากมีความสำคัญ อ็อบเจ็กต์จึงควรได้รับการพิจารณาเป็นพิเศษ เราจะจัดการกับอ็อบเจ็กต์ในบทต่อไป <info:object> หลังจากที่เราเรียนรู้เพิ่มเติมเกี่ยวกับ primitive

ประเภท `symbol` ใช้เพื่อสร้างตัวระบุที่ไม่ซ้ำกันสำหรับอ็อบเจ็กต์ เราต้องกล่าวถึงเรื่องนี้ที่นี่เพื่อความสมบูรณ์ แต่ยังคงเลื่อนรายละเอียดออกไปจนกว่าเราจะรู้จักอ็อบเจ็กต์

## ตัวดำเนินการ typeof [#type-typeof]

ตัวดำเนินการ `typeof` ใช้เพื่อตรวจสอบประเภทของข้อมูล โดยจะส่งคืนสตริงที่ระบุประเภทของข้อมูลนั้น ตัวดำเนินการนี้นำไปใช้ประโยชน์ได้มากมาย เช่น ประมวลผลข้อมูลประเภทต่างๆ ต่างกัน หรือเพียงแค่ต้องการตรวจสอบประเภทอย่างง่ายๆ

การเรียกใช้ `typeof x` จะส่งคืนสตริงที่ระบุประเภทของข้อมูลนั้น ตัวอย่างเช่น:

```js
typeof undefined // "undefined"

typeof 0 // "number"

typeof 10n // "bigint"

typeof true // "boolean"

typeof "สวัสดี" // "string"

typeof Symbol("id") // "symbol"

*!*
typeof Math // "object"  (1)
*/!*

*!*
typeof null // "object"  (2)
*/!*

*!*
typeof alert // "function"  (3)
*/!*
```

โค้ดสามบรรทัดสุดท้ายอาจต้องการคำอธิบายเพิ่มเติม:

1. `Math` เป็นอ็อบเจ็กต์ในตัวที่ให้บริการเกี่ยวกับการคำนวณทางคณิตศาสตร์ เราจะเรียนรู้เพิ่มเติมเกี่ยวกับอ็อบเจ็กต์นี้ในบท <info:number> ที่นี่ เป็นเพียงตัวอย่างของอ็อบเจ็กต์เท่านั้น
2. ผลลัพธ์ของ `typeof null` คือ `"object"` นี่คือข้อผิดพลาดที่ยอมรับกันอย่างเป็นทางการใน `typeof` ซึ่งมาจากยุคแรกของ JavaScript และยังคงอยู่เพื่อความเข้ากันได้ แน่นอนว่า `null` ไม่ใช่อ็อบเจ็กต์ มันเป็นค่าพิเศษที่มีประเภทแยกต่างหากของตัวเอง พฤติกรรมของ `typeof` นั้นผิดพลาดในกรณีนี้
3. ผลลัพธ์ของ `typeof alert` คือ `"function"` เนื่องจาก `alert` เป็นฟังก์ชัน เราจะศึกษาฟังก์ชันในบทถัดไป ซึ่งเราจะเห็นว่าไม่มีข้อมูลประเภท "function" ใน JavaScript ฟังก์ชันเป็นส่วนหนึ่งของประเภทอ็อบเจ็กต์ แต่ `typeof` ปฏิบัติต่อฟังก์ชันแตกต่างกัน โดยส่งคืน `"function"` ซึ่งเป็นพฤติกรรมที่สืบทอดมาจากยุคแรกของ JavaScript เช่นกัน ในทางเทคนิค พฤติกรรมดังกล่าวไม่ถูกต้อง แต่สามารถนำไปใช้ได้อย่างสะดวกในทางปฏิบัติ

```smart header="ไวยากรณ์ `typeof(x)`"
บางทีคุณอาจพบเห็นไวยากรณ์อีกแบบหนึ่ง: `typeof(x)` มันเหมือนกับ `typeof x`

เพื่อให้ชัดเจน: `typeof` เป็นตัวดำเนินการ ไม่ใช่ฟังก์ชัน วงเล็บในที่นี้ไม่ใช่ส่วนหนึ่งของ `typeof` มันเป็นประเภทของวงเล็บที่ใช้สำหรับการจัดกลุ่มทางคณิตศาสตร์

โดยปกติ วงเล็บดังกล่าวจะประกอบด้วยนิพจน์ทางคณิตศาสตร์ เช่น `(2 + 2)` แต่ที่นี่มีเพียงอาร์กิวเมนต์เดียว `(x)` ไวยากรณ์นี้ช่วยให้หลีกเลี่ยงช่องว่างระหว่างตัวดำเนินการ `typeof` และอาร์กิวเมนต์ของมัน ซึ่งบางคนชอบใช้

บางคนชอบ `typeof(x)` แม้ว่าในทางไวยากรณ์ `typeof x` จะพบเห็นได้ทั่วไปกว่ามาก
```

## บทสรุป

มี 8 ประเภทข้อมูลพื้นฐานใน JavaScript

- เจ็ดประเภทข้อมูลแบบพื้นฐาน:
    - `number` สำหรับตัวเลขทุกชนิด: จำนวนเต็มหรือจำนวนทศนิยม โดยจำนวนเต็มจำกัดอยู่ที่ <code>±(2^53-1)</code>
    - `bigint` สำหรับจำนวนเต็มความยาวไม่จำกัด
    - `string` สำหรับสตริง สตริงอาจมีตัวอักษร 0 ตัวหรือมากกว่า
    - `boolean` สำหรับ `true`/`false`
    - `null` สำหรับค่าที่ไม่รู้จัก -- ประเภทแยกต่างหากที่มีค่าเดียว คือ `null`
    - `undefined` สำหรับค่าที่ไม่ได้กำหนด -- ประเภทแยกต่างหากที่มีค่าเดียว คือ `undefined`
    - `symbol` สำหรับตัวระบุเฉพาะที่ไม่ซ้ำกัน
- และหนึ่งประเภทข้อมูลที่ไม่ใช่แบบพื้นฐาน:
    - `object` สำหรับโครงสร้างข้อมูลที่ซับซ้อนมากขึ้น

ตัวดำเนินการ `typeof` ช่วยให้เราสามารถดูได้ว่าข้อมูลประเภทใดถูกเก็บไว้ในตัวแปร

- โดยทั่วไปใช้เป็น `typeof x` แต่ `typeof(x)` ก็ใช้ได้เช่นกัน
- ส่งคืนสตริงที่มีชื่อของประเภท เช่น `"string"`
- สำหรับ `null` จะส่งคืน `"object"` -- นี่เป็นข้อผิดพลาดในภาษา มันไม่ใช่อ็อบเจ็กต์จริงๆ

ในบทต่อๆไป เราจะมุ่งเน้นไปที่ค่าพื้นฐาน (primitive) ก่อน และเมื่อเราคุ้นเคยกับพวกมันแล้ว เราจะย้ายไปยังอ็อบเจ็กต์
