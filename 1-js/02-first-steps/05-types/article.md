# ชนิดของข้อมูล


ค่าในจาวาสคริปต์จะเป็นมีชนิดของข้อมูลหนึ่งอย่างเสมอ อย่างเช่น สตริงหรืือตัวเลข

ชนิดของข้อมูลในจาวาสคริปต์มีทั้งหมด 8 อย่าง ในบทเรียนนี้เราจะพูดถึงที่ใช้กันทั่วไปก่อนจะลงรายละเอียดในบทถัดไป

เราสามารถเก็บข้อมูลชนิดใดก็ได้ในตัวแปร ตัวอย่างเช่น ตัวแปรเก็บสตริงไว้ และก็เปลี่ยนมาเก็บตัวเลขแทน

```js
// ไม่มี error
let message = "hello";
message = 123456;
```
ภาษาโปรแกรมมิ่งที่อนุญาตให้เปลี่ยนชนิดเปลี่ยนได้แบบง่ายๆแบบนี้ เรียกว่า "dynamically typed" หมายถึง ตัวแปรไม่ผูกอยู่กับชนิดข้อมูลใดๆ แบบในบางภาษาจะมีระบุว่าให้ตัวแปรเก็บข้อมูลชนิดใด แล้วตัวแปรนี้ต้องเป็นข้อมูลชนิดนั้นไปตลอด

## ตัวเลข (Number)

```js
let n = 123;
n = 12.345;
```

ตัวแปรชนิด *number* คือตัวเลขนั่นเอง สามารถเป็นได้ทั้งจำนวนเต็ม (Integer) และทศนิยม (Floating Point)

เราสามารถนำตัวเลข 2 ตัวมาทำการบวก (addition) ด้วยเครื่องหมาย `+` ลบ (subtraction) `-` คูณ (multiplication) `*` หรือหาร (division) `/` และอื่นๆ

นอกจากตัวเลขปกติแล้ว ในจาวาสคริปต์ ยังมีจำนวนพิเศษอีก ได้แก่ `Infinity`, `-Infinity` และ `NaN`

- `Infinity` คือ [อนันต์](https://th.wikipedia.org/wiki/อนันต์)(∞) ในทางคณิตศาสตร์ เป็นค่าพิเศษที่มีค่ามากกว่าตัวเลขใดๆก็คาม

    เราจะได้ค่านี้ก็ต่อเมื่อ เราหารตัวเลขอะไรก็ตามด้วยศูนย์

    ```js run
    alert( 1 / 0 ); // Infinity
    ```

    หรือจะพิมพ์ไปตรงๆเลยก็ได้

    ```js run
    alert( Infinity ); // Infinity
    ```
- `NaN` คือ ค่าที่เกิดขึ้นจากข้อผิดพลาดทางการคำนวณ เป็นผลมาจากการดำเนินการทางคณิตศาสตร์ที่ไม่ถูกต้อง ตัวอย่างเช่น

    ```js run
    alert( "not a number" / 2 ); // NaN, สตริงหารตัวเลขไม่ได้
    ```

<<<<<<< HEAD
    `NaN` เป็นค่าที่ติดหนึบ เพราะไม่ว่าเราจะทำอะไรกับค่า `NaN` มันก็จะเป็น `NaN` เสมอ
=======
    `NaN` is sticky. Any further mathematical operation on `NaN` returns `NaN`:
>>>>>>> 29216730a877be28d0a75a459676db6e7f5c4834

    ```js run
    alert( NaN + 1 ); // NaN
    alert( 3 * NaN ); // NaN
    alert( "not a number" / 2 - 1 ); // NaN
    ```

<<<<<<< HEAD
    ดังนั้น หากเกิด `NaN` ขึ้นมาในโค้ดของเรา มันก็อาจจะลามไปที่อื่นในโค้ดของเราด้วย
=======
    So, if there's a `NaN` somewhere in a mathematical expression, it propagates to the whole result (there's only one exception to that: `NaN ** 0` is `1`).
>>>>>>> 29216730a877be28d0a75a459676db6e7f5c4834

```smart header="การดำเนินการทางคณิตศาสตร์นั้นปลอดภัย"
การกระทำใดๆที่เกี่ยวกับตัวเลขนั้นปลอดภัย ต่อไปเราจะ หารอะไรด้วยศูนย์ เอาข้อมูลชนิดอื่นมาบวกตัวเลข และอื่นๆ

สคริปต์ของเราจะไม่หยุดทำงาน (fatal error) หรือตาย อย่างแย่ที่สุดก็คือ ได้ผลลัพธ์เป็น `NaN`
```

จำนวนพิเศษเหล่านั้นจัดอยู่ในข้อมูลชนิด `number` แต่เป็นจำนวนทางโปรแกรมมิ่ง ที่ขัดกับหลักสามัญสำนึกของเรา

หากต้องการทราบรายละเอียดเกี่ยวกับตัวเลขที่เยอะขึ้น ให้คลิกที่บทนี้ <info:number>.

## BigInt [#bigint-type]

ในจาวาสคริปต์ ตัวเลขจะมีจำนวนเป็นบวกต้องไม่เกิน <code>(2<sup>53</sup>-1)</code> และ หากเป็นลบต้องไม่น้อยกว่า <code>-(2<sup>53</sup>-1)</code> เนื่องจากเป็นข้อจำกัดทางเทคนิคของภาษา

สำหรับการใช้งานทั่วไปแล้ว ช่วงตัวเลขดังกล่าวก็ใช้เพียงพอ แต่มีบางกรณีเราก็ต้องใช้ตัวเลขจำนวนมาก (big numbers) เพื่อการเข้ารหัส (cryptography) หรืือ การเก็บ timestamps ในระดับมิลลิวินาที

ข้อมูลชนิด `BigInt` เพิ่งจะถูกเพิ่มเข้ามาในจาวาสคริปต์ไม่นานนี้ เพื่อให้ตัวแปรสามารถเก็บข้อมูล เป็นตัวเลขทีมีความยาวเกิน 16 หลักได้

เราจะสร้างข้อมูลชนิด `BigInt` ได้ด้วยการเติม `n` ไว้ข้างหลังเลขจำนวนเต็ม

```js
// the "n" at the end means it's a BigInt
const bigInt = 1234567890123456789012345678901234567890n;
```

จำนวน `BigInt` เป็น rare care ฉะนั้นเราจึงอยากแยกไว้เป็นอีกบท <info:bigint> เผืื่อสักวันเราจะได้ใช้


```smart header="Compatibility issues"
ตอนนี้, `BigInt` สามารถใช้ได้บน Firefox/Chrome/Edge/Safari, ยกเว้นใน IE.
```

เราสามารถเปิด [*MDN* BigInt compatibility table](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt#Browser_compatibility) เพื่อดูว่าเบราเซอร์เวอร์ชั่นไหนใช้ได้บ้าง

## สตริง

สตริงในจาวาสคริปต์จะต้องล้อมรอบด้วยเครื่องหมาย quotes

```js
let str = "Hello";
let str2 = 'Single quotes are ok too';
let phrase = `can embed another ${str}`;
```

ในจาวาสคริปต์ เรามีสตริงทั้งหมด 3 ประเภท

1. แบบ Double quotes: `"Hello"`.
2. แบบ Single quotes: `'Hello'`.
3. แบบ Backticks: <code>&#96;Hello&#96;</code>.

Double และ single quotes เป็นสตริงที่ไม่มีอะไรซับซ้อน และไม่มีความแตกต่างระหว่างกัน

Backticks จะพิเศษออกไป เพราะมีความสามารถ ในการฝังตัวแปรหรือนิพจน์ (expression) ลงในสตริงได้ด้วยการล้อมรอบด้วย `${…}` ดั่งตัวอย่าง

```js run
let name = "John";

// ฝังตัวแปร
alert( `Hello, *!*${name}*/!*!` ); // Hello, John!

// ฝังนิพจน์ (expression)
alert( `the result is *!*${1 + 2}*/!*` ); // จะได้ผลลัพธ์เป็น 3
```

ตัว `${…}` จะหาค่าตัวนิพจน์ (expression) ที่อยู่ภายใน และผลลัพธ์จาการดำเนินการ จะกลายเป็นส่วนหนึ่งของสตริง เราจะใส่อะไรลงไปภายใน `${…}` ก็ได้ทั้ง ตัวแปร นิพจน์ (expression) หรืออะไรที่ซับซ้อนกว่านี้

โปรดอย่าลืมว่าความสามารถนี้มีเฉพาะ Backticks เท่านั้น เครื่องหมาย quotes อื่นๆ ไม่มีความสามารถนี้
```js run
alert( "the result is ${1 + 2}" ); // ผลลัพธ์ก็คือ ${1 + 2} (double quote ไม่ได้มีผลอะไร)
```

รายละเอียดเกี่ยวกับสตริงเชิงลึกสามารถคลิกดูที่บทนี้ได้เลย<info:string>.

```smart header="ไม่มีข้อมูลชนิด *อักขระ (character)*"
ในบางภาษาโปรแกรมม่ิง จะมีข้อมูลชนิดอักขระ (character) คือเก็บตัวอักษรจำนวน 1 ตัว ตัวอย่างเช่น ภาษาซีหรือจาวา

ในจาวาสคริปต์ จะไม่มีข้อมูลชนิด อักขระนี้ ทุกอย่างที่ใส่ quote ล้วนเก็บเป็นสตริง ดังนั้นจะไม่มีอักขระสักตัวเลย ใส่หนึ่งตัว หรือ ใส่มากกว่าหนึ่งก็ได้
```

## บูลีน (Boolean - logical type)

ข้อมูลชนิดบูลีนมีค่าเพียงสองแบบคือ `true` และ `false`

โดยปกติค่าบูลีน จะเหมือนกับเก็บค่า ใช่/ไม่ใช่ เอาไว้ `true` หมายถึง ใช่ และ `false` หมายถึง ไม่ใช่

For instance:

```js
let nameFieldChecked = true; // ใช่ ช่องชื่อถูกติ๊ก
let ageFieldChecked = false; // ไมใช่ ช่องอายุไม่ได้ถูกติ๊ก 
```

ค่าบูลีนสามารถเกิดจาก ผลลัพธ์ของการเปรียบเทียบกัน เช่นในตัวอย่าง

```js run
let isGreater = 4 > 1;

alert( isGreater ); // true (หมายถึงว่าใช่ 4 มากกว่า 1)
```

รายละเอียดเกี่ยวกับบูลีนเชิงลึกสามารถดูได้ที่บทนี้ <info:logical-operators>.

## ค่า "null"

ค่า "null" เป็นค่าชนิดพิเศษ ที่ไม่ได้อยู่ในข้อมูลชนิดใดๆเลย

ค่า "null" เป็นชนิดข้อมูลที่แยกออกมาตะหาก ซึ่งมีเพียงค่าเดียวนั่นคือ `null`

```js
let age = null;
```

ในจาวาสคริปต์ค่า `null` ไม่ได้หมายถึง "การอ้างถึงออบเจ็กต์ที่ไม่มีอยู่" หรือ "ตัวที่ชี้ดันไม่มีค่า (null pointer)" เหมือนภาษาโปรแกรมมิ่งบางภาษา

เป็นเพียงค่าพิเศษที่แสดงถึง ความว่างเปล่า ไม่มีค่า หรือ ไม่ทราบค่า

โค้ดด้านบนสื่อว่า ยังไม่รู้ว่า `age` จะเป็นอะไร

## ค่า "undefined"

ค่า undefined ก็เป็นชนิดข้อมูลอีกประเภท ไม่เหมือนกับ `null`

ความหมายของ `undefined` คือ "ค่ายังไม่ได้ถูกกำหนด"

หากเราสร้างตัวแปรขึ้นมา แต่ไม่ได้กำหนดค่าให้ตัวแปร ค่าที่ได้จะเป็น `undefined`:

```js run
let age;

alert(age); // แสดง "undefined"
```

ในทางเทคนิค ตัวภาษาจะกำหนดค่า `undefined` ให้ตัวแปรที่ไม่มีค่าโดยอัตโนมัติ

```js run
let age = 100;

// เปลี่ยนจาก 100 เป็น undefined
age = undefined;

alert(age); // "undefined"
```

...แต่เราไม่แนะนำให้ทำแบบนั้น ปกติแล้ว จะใช้ `null` assign แทนสำหรับตัวแปรที่ เป็นค่าว่าง หรือ ยังไม่รู้ ขณะที่ `undefined` คือย้อนกลับไปค่าเริ่มต้นคือ ไม่ได้ assign ค่าใดๆให้ตัวแปรนี้

## ออบเจ็กต์ (Objects) และซิมโบล (Symbols)

ข้อมูลชนิด `object` ก็เป็นชนิดพิเศษ

ชนิดข้อมูลที่กล่าวมาทั้งหมดเรียกว่า "primitive" เพราะว่าชนิดข้อมูลนี้เก็บค่าเพียงค่าเดียว (จะเก็บสตริงหรือตัวเลขก็ตามแต่) แต่เรายังมี objects ที่ไว้ใช้เก็บข้อมูลเป็น collections มีความซับซ้อนทางโครงสร้างอีก

เนื่องจาก objects สำคัญมาก เหมาะแก่การแยกไว้เป้นบทพิเศษ เราจะจัดเต็มกับ objects ในบท <info:object> เมื่ือเราเรียนรู้เกี่ยวกับ primitives มากกว่านี้แล้ว

ข้อมูลชนิด `symbol` ถูกใช้เพื่อสร้างเอกลักษณ์สำหรับ objects เราจะขอแค่เกริ่นๆให้ครบก่อน จะพูดถึงรายละเอียดอีกทีหลังจากเรียนเรื่อง objects แล้ว

## typeof operator [#type-typeof]

ตัวโอเปอเรเตอร์ `typeof` จะส่งคืนชนิดของข้อมูลนั้นๆออกมา โอเปอเรเตอร์ตัวนี้มีประโยชน์อย่างมาก เมื่อเราต้องประมวลผลชนิดข้อมูลที่ต่างกัน หรือ เช็คชนิดของชนิดข้อมูลนั้นๆ

การเรียก `typeof x` จะได้สตริงที่ระบุชนิดของข้อมูลนั้นออกมา:

```js
typeof undefined // "undefined"

typeof 0 // "number"

typeof 10n // "bigint"

typeof true // "boolean"

typeof "foo" // "string"

typeof Symbol("id") // "symbol"

*!*
typeof Math // "object"  (1)
*/!*

*!*
typeof null // "object"  (2)
*/!*

*!*
typeof alert // "function"  (3)
*/!*
```

คำอธิบายเพิ่มเติมเกี่ยวกับสามบรรทัดสุดท้าย

1. `Math` เป็น built-in object (ออบเจ็กต์ที่ภาษาให้มา) ที่มีฟีเจอร์เรื่องการคำนวณ เดี๋ยวเราจะได้เรียนในบท <info:number> ทีนี้จะบอกว่ามันก็เป็น object เหมือนกันนะ
2. ผลลัพธ์จาก `typeof null` คือ `"object"` แต่นี่เป็นข้อผิดพลาดของภาษา มาจากในตอนที่จาวาสคริปต์เกิดแรกๆ และต้องการความ compatibility แต่แน่นอนว่า `null` ไม่ใช่ object และมันควรเป็นข้อมูลชนิดพิเศษ แยกไปเป้นของตัวเองต่างหาก
3. ผลลัพธ์จาก `typeof alert` คือ `"function"` เพราะ `alert` เป็นฟังก์ชัน ซึ่งเราจะก็เห็นว่าไม่มีข้อมูลชนิดฟังก์ชันอยู่ในจาวาสคริปต์ อันที่จริงฟังก์ชันเป็นหนึ่งใน object แต่ `typeof` จะมองเป็นฟังก์ชัน แล้ว return "function" ออกมาแทน ในทางเทคนิคแล้ว พฤติกรรมแบบนี้ถือว่าเป็นบัคของภาษา แต่บัคตัวนี้กลับทำให้ชีวิตเราง่ายขึ้น

```smart header="The `typeof(x)` syntax"
บางทีเราอาจจะไปเจอประโยตแบบนี้ `typeof(x)` โปรดจำไว้ว่ามันเหมือนกับ `typeof x`

เพื่อให้ชัดเจน: `typeof` เป็นโอเปอเรเตอร์ ไม่ใช่ฟังก์ชัน วงเล็บที่นี่ไม่ได้เป็นส่วนหนึ่งของ `typeof` แต่เป็นวงเล็บประเภทหนึ่งที่ใช้สำหรับการจัดกลุ่มทางคณิตศาสตร์

โดยปกติ วงเล็บดังกล่าวจะใช้กับนิพจน์ทางคณิตศาสตร์ เช่น `(2 + 2)` แต่ในที่นี้มีอาร์กิวเมนต์ `(x)` เพียงหนึ่งอาร์กิวเมนต์ ในทางภาษามันอนุญาตให้มีช่องว่างระหว่างโอเปอเรเตอร์ `typeof` กับอาร์กิวเม้นต์ได้ และหลายคนชอบแบบนี้

แต่บางคนก็ชอบเขียนแบบนี้ `typeof(x)` แต่ที่เห็นบ่อยที่สุดก็คือรูปประโยคแบบ `typeof x`
```

## สรุป

มีข้อมูลอยู่ 8 ชนิดในจาวาสคริปต์

- `number` คือตัวเลขอะไรก็ตาม ไม่ว่าจะเป็น จำนวนเต็ม หรือ ทศนิยม โดยที่จำนวนเต็มจะจำกัดอยู่แค่ ±2<sup>53</sup>
- `bigint` คือตัวเลขที่เป็นจำนวนเต็ม และจะมีกี่หลักก็ได้
- `string` คือสตริงหรือข้อความ จะมีอักขระกี่ตัวก็ได้ โดยไม่แยกระหว่างอักขระตัวเดียวกับ ชุดอักขระเหมือนภาษาอื่น
- `boolean` คือค่า `true` และ `false`
- `null` คือค่าว่าง เป็นทั้งค่า และ ชนิดของข้อมูล
- `undefined` คือค่าที่ยังไม่ถูกกำหนด เป็นทั้งค่า และ ชนิดของข้อมูล
- `object` สำหรับ เก็บข้อมูลมากกว่าหนึ่งค่า มีความซับซ้อนในเรื่องโครงสร้างข้อมูล
- `symbol` สำหรับ เป็นตัวระบุเอกลักษณ์ใน object

ตัว `typeof` สามารถช่วยเราดูชนิดข้อมูลเก็บอยู่ในตัวแปรได้

- เขียนได้แบบสอง `typeof x` หรือ `typeof(x)`
- ส่งคืนเป็นสตริง บอกชนิดของข้อมูลออกมา อย่าง `"string"`.
- แต่กับ `null` จะส่งค่าเป็น `"object"` -- เป็นข้อผิดพลาดทางภาษา เพราะมันไม่ใช่ออบเจ็กต์

ในบทหน้า เราจะเน้นไปที่ข้อมูลประเภท "primitive" พอคุ้นเคยแล้ว จะไปเน้นที่ออบเจ็กต์กันต่อ
