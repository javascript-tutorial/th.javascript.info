# ฟังก์ชัน

บ่อยครั้งที่เราต้องการทำการกระทำที่คล้ายกันในหลาย ๆ ที่ของสคริปต์

ยกตัวอย่างเช่น เราต้องการแสดงข้อความที่ดูดีเมื่อผู้ใช้เข้าสู่ระบบ ออกจากระบบ หรืออาจจะที่อื่นๆ อีก

ฟังก์ชันเป็น "building blocks" หลักของโปรแกรม มันช่วยให้โค้ดถูกเรียกใช้ซ้ำได้หลายครั้งโดยไม่ต้องเขียนซ้ำๆ กัน

เราได้เห็นตัวอย่างของฟังก์ชันที่มีอยู่แล้วในภาษา เช่น `alert(message)`, `prompt(message, default)` และ `confirm(question)` แต่เราก็สามารถสร้างฟังก์ชันของเราเองได้เช่นกัน

## การประกาศฟังก์ชัน

เราสามารถสร้างฟังก์ชันโดยใช้ *function declaration*

มีรูปแบบดังนี้:

```js
function showMessage() {
  alert( 'สวัสดีทุกคน!' );
}
```

คำสำคัญ `function` มาก่อน ตามด้วย *ชื่อของฟังก์ชัน* จากนั้นเป็นรายการของ *พารามิเตอร์* ภายในวงเล็บ (คั่นด้วยเครื่องหมายจุลภาค ในตัวอย่างด้านบนไม่มี จะเห็นตัวอย่างในภายหลัง) และสุดท้ายคือโค้ดของฟังก์ชัน หรือเรียกว่า "function body" ซึ่งอยู่ในวงเล็บปีกกา

```js
function ชื่อ(parameter1, parameter2, ... parameterN) {
  // body
}
```

ฟังก์ชันใหม่ของเราสามารถเรียกใช้ได้โดยระบุชื่อของมัน: `showMessage()`

ตัวอย่างเช่น:

```js run
function showMessage() {
  alert( 'สวัสดีทุกคน!' );
}

*!*
showMessage();
showMessage();
*/!*
```

การเรียก `showMessage()` จะทำให้โค้ดในฟังก์ชันทำงาน ในที่นี้เราจะเห็นข้อความสองครั้ง

ตัวอย่างนี้แสดงถึงจุดประสงค์หลักอย่างหนึ่งของฟังก์ชันได้อย่างชัดเจน นั่นคือการหลีกเลี่ยงการซ้ำซ้อนของโค้ด

ถ้าเราต้องการเปลี่ยนข้อความหรือวิธีการแสดงผล เราแค่แก้โค้ดในที่เดียว นั่นคือฟังก์ชันที่ใช้แสดงผลข้อความ

## ตัวแปรภายในฟังก์ชัน

ตัวแปรที่ประกาศภายในฟังก์ชันจะมองเห็นได้เฉพาะภายในฟังก์ชันนั้นๆ

ตัวอย่างเช่น:

```js run
function showMessage() {
*!*
  let message = "สวัสดี ผมคือ JavaScript!"; // ตัวแปรภายใน
*/!*

  alert( message );
}

showMessage(); // สวัสดี ผมคือ JavaScript!

alert( message ); // <-- เกิด Error! ตัวแปรอยู่เฉพาะในฟังก์ชัน
```

## ตัวแปรภายนอก

ฟังก์ชันสามารถเข้าถึงตัวแปรภายนอกได้ด้วย ตัวอย่างเช่น:

```js run no-beautify
let *!*userName*/!* = 'John';

function showMessage() {
  let message = 'สวัสดี ' + *!*userName*/!*;
  alert(message);
}

showMessage(); // สวัสดี John
```

ฟังก์ชันมีการเข้าถึงตัวแปรภายนอกได้อย่างเต็มที่ มันสามารถแก้ไขค่าได้ด้วย

ตัวอย่างเช่น:

```js run
let *!*userName*/!* = 'John';

function showMessage() {
  *!*userName*/!* = "Bob"; // (1) เปลี่ยนตัวแปรภายนอก

  let message = 'สวัสดี ' + *!*userName*/!*;
  alert(message);
}

alert( userName ); // *!*John*/!* ก่อนเรียกฟังก์ชัน

showMessage();

alert( userName ); // *!*Bob*/!*, ค่าถูกแก้ไขโดยฟังก์ชัน
```

ตัวแปรภายนอกจะถูกใช้ก็ต่อเมื่อไม่มีตัวแปรภายในที่ชื่อซ้ำกัน

ถ้ามีตัวแปรที่ชื่อเหมือนกันถูกประกาศภายในฟังก์ชัน มันจะ *บดบัง* ตัวแปรภายนอก ตัวอย่างเช่น ในโค้ดด้านล่าง ฟังก์ชันจะใช้ `userName` ภายในฟังก์ชัน ส่วน `userName` ภายนอกจะถูกเพิกเฉย:

```js run
let userName = 'John';

function showMessage() {
*!*
  let userName = "Bob"; // ประกาศตัวแปรภายใน
*/!*

  let message = 'สวัสดี ' + userName; // *!*Bob*/!*
  alert(message);
}

// ฟังก์ชันจะสร้างและใช้ userName ของตัวเอง
showMessage();

alert( userName ); // *!*John*/!*, ไม่เปลี่ยนแปลง เพราะฟังก์ชันไม่ได้เข้าถึงตัวแปรภายนอก
```

```smart header="ตัวแปรส่วนกลาง (Global variables)"
ตัวแปรที่ประกาศนอกฟังก์ชัน เช่น `userName` ภายนอกในตัวอย่างด้านบน เรียกว่า *global*

ตัวแปร global จะมองเห็นได้จากทุกฟังก์ชัน (ยกเว้นว่ามันจะถูกบดบังโดยตัวแปรภายใน)

แนวทางที่ดีคือการลดการใช้ตัวแปร global การเขียนโค้ดสมัยใหม่มีการใช้ตัวแปร global น้อยมากหรือไม่มีเลย ตัวแปรส่วนใหญ่อยู่ภายในฟังก์ชัน แต่บางครั้งก็อาจจะมีประโยชน์ในการเก็บข้อมูลระดับโครงการ
```

## พารามิเตอร์

เราสามารถส่งค่าแบบใดๆ ก็ได้ไปยังฟังก์ชันโดยใช้พารามิเตอร์

ในตัวอย่างด้านล่าง ฟังก์ชันมีพารามิเตอร์สองตัวคือ: `from` และ `text`

```js run
function showMessage(*!*from, text*/!*) { // พารามิเตอร์: from, text
  alert(from + ': ' + text);
}

*!*showMessage('แอน', 'สวัสดี!');*/!* // แอน: สวัสดี! (*)
*!*showMessage('แอน', 'เป็นยังไงบ้าง?');*/!* // แอน: เป็นยังไงบ้าง? (**)
```

เมื่อฟังก์ชันถูกเรียกใช้ในบรรทัด `(*)` และ `(**)` ค่าที่ส่งเข้าไปจะถูกคัดลอกไปยังตัวแปรภายในฟังก์ชันคือ `from` และ `text` จากนั้นฟังก์ชันก็จะใช้ค่าเหล่านั้น

ต่อไปนี้เป็นอีกตัวอย่างหนึ่ง: เรามีตัวแปร `from` และส่งมันเข้าไปในฟังก์ชัน ข้อสังเกต: ฟังก์ชันเปลี่ยนค่า `from` แต่การเปลี่ยนแปลงนี้จะไม่มีผลต่อ `from` ภายนอก เพราะฟังก์ชันจะได้รับสำเนาของค่านั้นเสมอ

```js run
function showMessage(from, text) {

*!*
  from = '*' + from + '*'; // ทำให้ "from" ดูดีขึ้น
*/!*

  alert( from + ': ' + text );
}

let from = "แอน";

showMessage(from, "สวัสดี"); // *แอน*: สวัสดี

// ค่าของ "from" เหมือนเดิม ฟังก์ชันแก้ไขสำเนาภายในเท่านั้น
alert( from ); // แอน
```

เมื่อมีการส่งค่าเข้าไปในฟังก์ชันในรูปแบบของพารามิเตอร์ เราจะเรียกค่านั้นว่า *อาร์กิวเมนต์ (argument)*

หรือพูดอีกอย่างคือ:

- พารามิเตอร์คือตัวแปรที่ระบุไว้ในวงเล็บในการประกาศฟังก์ชัน (เป็นคำที่ใช้ในช่วงประกาศ)
- อาร์กิวเมนต์คือค่าที่ถูกส่งเข้าไปในฟังก์ชันเมื่อมีการเรียกใช้ (เป็นคำที่ใช้ในช่วงเรียกใช้)

เราจะประกาศฟังก์ชันโดยระบุรายชื่อพารามิเตอร์ไว้ แล้วจึงเรียกใช้ฟังก์ชันโดยส่งอาร์กิวเมนต์เข้าไป

ในตัวอย่างด้านบน อาจพูดได้ว่า: "ฟังก์ชัน `showMessage` ถูกประกาศด้วยพารามิเตอร์สองตัว แล้วจึงถูกเรียกใช้ด้วยอาร์กิวเมนต์สองค่า: `from` และ `"สวัสดี"`"


## ค่าเริ่มต้น

ถ้าฟังก์ชันถูกเรียก แต่ไม่ได้รับอาร์กิวเมนต์ ค่าของพารามิเตอร์ที่ไม่ได้รับจะเป็น `undefined`

ตัวอย่างเช่น ฟังก์ชัน `showMessage(from, text)` ที่กล่าวถึงก่อนหน้าสามารถถูกเรียกด้วยอาร์กิวเมนต์เดียวได้:

```js
showMessage("แอน");
```

นั่นไม่ใช่ข้อผิดพลาด ฟังก์ชันจะแสดงผลออกมาเป็น `"*แอน*: undefined"` เนื่องจากไม่มีการส่งค่าให้กับ `text` พารามิเตอร์ `text` จะมีค่าเริ่มต้นเป็น `undefined`

เราสามารถระบุค่าเริ่มต้น (ที่จะใช้หากค่าไม่ถูกส่งเข้ามา) ให้กับพารามิเตอร์ในการประกาศฟังก์ชันได้ โดยใช้ `=`:

```js run
function showMessage(from, *!*text = "ไม่มีข้อความ"*/!*) {
  alert( from + ": " + text );
}

showMessage("แอน"); // แอน: ไม่มีข้อความ
```

ถ้าไม่มีการส่งค่าให้กับพารามิเตอร์ `text` ตอนนี้ พารามิเตอร์ `text` จะมีค่าเป็น `"ไม่มีข้อความ"`

ค่าเริ่มต้นก็จะถูกใช้เช่นกันถ้าพารามิเตอร์มีอยู่ แต่มีค่าเป็น `undefined` อย่างเคร่งครัด เช่นนี้:

```js
showMessage("แอน", undefined); // แอน: ไม่มีข้อความ 
```

ในที่นี้ `"ไม่มีข้อความ"` เป็นสตริง แต่มันสามารถเป็นนิพจน์ที่ซับซ้อนมากกว่านี้ได้ ซึ่งจะถูกประเมินและกำหนดค่าก็ต่อเมื่อพารามิเตอร์ไม่ถูกส่งเข้ามาเท่านั้น ดังนั้น นี่ก็เป็นไปได้เช่นกัน:

```js run
function showMessage(from, text = anotherFunction()) {
  // anotherFunction() จะทำงานก็ต่อเมื่อไม่มี text ถูกส่งมา
  // ผลลัพธ์จาก anotherFunction() จะกลายเป็นค่าของ text
}
```

```smart header="การประเมินค่าพารามิเตอร์เริ่มต้น"
ใน JavaScript พารามิเตอร์เริ่มต้นจะถูกประเมินทุกครั้งที่ฟังก์ชันถูกเรียกโดยไม่ส่งพารามิเตอร์ที่เกี่ยวข้องเข้ามา

ในตัวอย่างด้านบน `anotherFunction()` จะไม่ถูกเรียกเลย ถ้ามีการส่งพารามิเตอร์ `text` เข้ามา

ในทางกลับกัน มันจะถูกเรียกแยกต่างหากทุกครั้งเมื่อไม่มี `text` ถูกส่งมา
```

````smart header="พารามิเตอร์เริ่มต้นในโค้ด JavaScript เก่า"
หลายปีก่อน JavaScript ไม่ได้รองรับ syntax สำหรับพารามิเตอร์เริ่มต้น ดังนั้นผู้คนจึงใช้วิธีอื่นๆ ในการกำหนดค่าเริ่มต้น

ทุกวันนี้ เราอาจพบเจอวิธีเหล่านี้ในสคริปต์เก่าๆ

ตัวอย่างเช่น การตรวจสอบ `undefined` อย่างชัดเจน:

```js
function showMessage(from, text) {
*!*
  if (text === undefined) {
    text = 'ไม่มีข้อความ';
  }
*/!*

  alert( from + ": " + text );
}
```

...หรือใช้ตัวดำเนินการ `||`:

```js
function showMessage(from, text) {
  // ถ้าค่าของ text เป็น falsy ให้กำหนดค่าเริ่มต้น
  // นี่ถือว่า text == "" เท่ากับไม่ได้ส่ง text มาเลย
  text = text || 'ไม่มีข้อความ';
  ...
}
```
````


### ทางเลือกอื่นสำหรับพารามิเตอร์เริ่มต้น

บางครั้งก็สมเหตุสมผลที่จะกำหนดค่าเริ่มต้นให้กับพารามิเตอร์ในขั้นตอนถัดมาหลังจากประกาศฟังก์ชันแล้ว

เราสามารถตรวจสอบได้ว่าพารามิเตอร์ถูกส่งเข้ามาหรือไม่ระหว่างการทำงานของฟังก์ชัน โดยนำค่าไปเปรียบเทียบกับ `undefined`:

```js run
function showMessage(text) {
  // ...

*!*
  if (text === undefined) { // ถ้าไม่มีพารามิเตอร์
    text = 'ข้อความว่าง';
  }
*/!*

  alert(text);
}

showMessage(); // ข้อความว่าง
```

หรือเราสามารถใช้ตัวดำเนินการ `||`:

```js
function showMessage(text) {
  // ถ้า text เป็น undefined หรือ falsy อื่นๆ ให้กำหนดเป็น 'ว่าง'
  text = text || 'ว่าง';
  ...
}
```

JavaScript engine สมัยใหม่รองรับ[ตัวดำเนินการ nullish coalescing](info:nullish-coalescing-operator) `??` ซึ่งดีกว่าเมื่อค่า falsy ส่วนใหญ่ เช่น `0` ควรถือว่า "ปกติ":

```js run
function showCount(count) {
  // ถ้า count เป็น undefined หรือ null ให้แสดง "ไม่ทราบ"
  alert(count ?? "ไม่ทราบ");
}

showCount(0); // 0
showCount(null); // ไม่ทราบ 
showCount(); // ไม่ทราบ
```

## การส่งค่ากลับ

ฟังก์ชันสามารถส่งค่ากลับไปยังโค้ดที่เรียกมันในรูปแบบของผลลัพธ์ได้

ตัวอย่างง่ายๆ คือฟังก์ชันที่รวมค่าสองค่าเข้าด้วยกัน:

```js run no-beautify
function sum(a, b) {
  *!*return*/!* a + b;
}

let result = sum(1, 2);
alert( result ); // 3
```

คำสั่ง `return` สามารถอยู่ในตำแหน่งใดๆ ของฟังก์ชันก็ได้ เมื่อการทำงานมาถึงจุดนั้น ฟังก์ชันจะหยุด และค่าจะถูกส่งกลับไปยังโค้ดที่เรียกใช้ (กำหนดค่าให้กับ `result` ในตัวอย่างด้านบน)

ในฟังก์ชันเดียว อาจมีหลาย `return` ได้ ตัวอย่างเช่น:

```js run
function checkAge(age) {
  if (age >= 18) {
*!*
    return true;
*/!*
  } else {
*!*
    return confirm('คุณได้รับอนุญาตจากพ่อแม่แล้วหรือยัง?');
*/!*
  }
}

let age = prompt('คุณอายุเท่าไหร่?', 18);

if ( checkAge(age) ) {
  alert( 'อนุญาตให้เข้า' );
} else {
  alert( 'ไม่อนุญาตให้เข้า' );
}
```

สามารถใช้ `return` โดยไม่มีค่าได้ ซึ่งจะทำให้ฟังก์ชันหยุดทำงานทันที

ตัวอย่างเช่น:

```js
function showMovie(age) {
  if ( !checkAge(age) ) {
*!*
    return;
*/!*
  }

  alert( "กำลังแสดงหนังให้คุณดู" ); // (*)
  // ...
}
```

ในโค้ดด้านบน ถ้า `checkAge(age)` ส่งค่ากลับเป็น `false` `showMovie` จะไม่ไปถึงคำสั่ง `alert`

````smart header="ฟังก์ชันที่มี `return` ว่างๆ หรือไม่มี `return` เลยจะส่งค่ากลับเป็น `undefined`"
ถ้าฟังก์ชันไม่ส่งค่ากลับ ก็เหมือนกับว่ามันส่งค่า `undefined` กลับ:

```js run
function doNothing() { /* ว่างๆ */ }

alert( doNothing() === undefined ); // true
```

`return` ว่างๆ ก็เหมือนกับ `return undefined`:

```js run
function doNothing() {
  return;
}

alert( doNothing() === undefined ); // true
```
````

````warn header="ห้ามขึ้นบรรทัดใหม่ระหว่าง `return` กับค่าที่จะส่งกลับ"
สำหรับนิพจน์ยาวๆ ใน `return` มันอาจจะน่าลองขึ้นบรรทัดใหม่ เช่นนี้:

```js
return
 (some + long + expression + or + whatever * f(a) + f(b))
```
แต่นั่นไม่ทำงาน เพราะ JavaScript คิดว่ามีเครื่องหมายอัฒภาค (;) ต่อท้ายคำว่า `return` เสมอ มันจะทำงานเหมือนกับ:

```js
return*!*;*/!*
 (some + long + expression + or + whatever * f(a) + f(b))
```

ดังนั้น มันก็จะกลายเป็น return ว่างๆ ไป

ถ้าเราต้องการให้นิพจน์ที่ส่งกลับต่อเนื่องข้ามหลายบรรทัด เราควรเริ่มเขียนมันในบรรทัดเดียวกับคำว่า `return` หรืออย่างน้อยก็ต้องใส่วงเล็บเปิดไว้ที่นั่น ดังนี้:

```js
return (
  some + long + expression 
  + or +
  whatever * f(a) + f(b)
  )
```
แบบนี้ก็จะทำงานตามที่เราคาดหวัง
````

## การตั้งชื่อฟังก์ชัน [#function-naming]

ฟังก์ชันคือการกระทำ ดังนั้นชื่อของมันจึงมักจะเป็นคำกริยา ควรจะสั้นกระชับ แต่บอกได้แม่นยำมากที่สุดถึงสิ่งที่ฟังก์ชันทำ เพื่อคนที่อ่านโค้ดจะได้เข้าใจว่าฟังก์ชันนั้นทำอะไร

การตั้งชื่อฟังก์ชันโดยใช้คำนำหน้าที่บอกคร่าวๆ ถึงการกระทำนั้นเป็นแนวปฏิบัติที่ใช้กันอย่างแพร่หลาย ทีมงานควรมีข้อตกลงกันเกี่ยวกับความหมายของคำนำหน้าเหล่านั้น

ยกตัวอย่างเช่น ฟังก์ชันที่ขึ้นต้นด้วย `"show"` มักจะแสดงบางอย่าง

ฟังก์ชันที่ขึ้นต้นด้วย...

- `"get…"` -- ส่งค่ากลับ
- `"calc…"` -- คำนวณบางอย่าง
- `"create…"` -- สร้างบางอย่าง
- `"check…"` -- ตรวจสอบบางอย่างและส่งค่าบูลีนกลับ เป็นต้น

ตัวอย่างชื่อฟังก์ชันแบบนี้:

```js no-beautify
showMessage(..)     // แสดงข้อความ
getAge(..)          // ส่งค่าอายุกลับ (ไปเอามาจากไหนสักที่)
calcSum(..)         // คำนวณผลรวมและส่งผลลัพธ์กลับ 
createForm(..)      // สร้างฟอร์ม (และส่วนใหญ่จะส่งค่ากลับ)
checkPermission(..) // ตรวจสอบสิทธิ์ และส่งค่า true/false กลับ
```

ด้วยการใส่คำนำหน้าไว้ การมองชื่อฟังก์ชันผ่านๆ ก็ทำให้เข้าใจได้ว่ามันทำงานแบบใด และส่งค่าแบบใดกลับ

```smart header="ฟังก์ชันหนึ่งตัว -- การกระทำหนึ่งอย่าง"
ฟังก์ชันควรทำตามที่ชื่อของมันบอก ไม่ควรทำมากไปกว่านั้น  

สองการกระทำที่เป็นอิสระต่อกันมักควรแยกเป็นสองฟังก์ชัน แม้ว่าปกติจะถูกเรียกใช้ด้วยกันก็ตาม (ในกรณีนั้นเราอาจสร้างฟังก์ชันที่สามที่เรียกใช้ฟังก์ชันทั้งสองนั้น)

ตัวอย่างของการฝ่าฝืนกฎนี้:

- `getAge` -- จะไม่ดี ถ้ามันแสดง `alert` พร้อมอายุ (ควรเอาแค่อายุ)
- `createForm` -- จะไม่ดี ถ้ามันแก้ไข document โดยเพิ่มฟอร์มเข้าไป (ควรแค่สร้างและส่งฟอร์มกลับ)  
- `checkPermission` -- จะไม่ดี ถ้ามันแสดงข้อความ `access granted/denied` (ควรทำเพียงการตรวจสอบและส่งผลลัพธ์กลับ)

ตัวอย่างเหล่านี้สมมติความหมายทั่วไปของคำนำหน้า คุณและทีมของคุณอาจตกลงกันใช้ความหมายอื่นๆ ได้ แต่ปกติก็ไม่ค่อยแตกต่างกันมากนัก ไม่ว่ายังไง คุณควรมีความเข้าใจอย่างแน่นอนว่าคำนำหน้าแต่ละคำหมายถึงอะไร ฟังก์ชันที่มีคำนำหน้าสามารถทำอะไรได้บ้างและทำอะไรไม่ได้ ฟังก์ชันที่มีคำนำหน้าเดียวกันทั้งหมดควรทำตามกฎเดียวกัน และทีมควรแบ่งปันองค์ความรู้นี้กัน
```

```smart header="ชื่อฟังก์ชันที่สั้นมากๆ"
ฟังก์ชันที่ถูกใช้ *บ่อยมากๆ* บางครั้งอาจมีชื่อที่สั้นเป็นพิเศษ

ตัวอย่างเช่น framework [jQuery](https://jquery.com/) กำหนดฟังก์ชันชื่อ `$` ส่วนไลบรารี [Lodash](https://lodash.com/) เรียกฟังก์ชันหลักของมันว่า `_`

เหล่านี้เป็นข้อยกเว้น โดยทั่วไปแล้วชื่อฟังก์ชันควรจะกระชับและสื่อความหมาย
```

## ฟังก์ชัน == คอมเมนต์

ฟังก์ชันควรสั้นและทำสิ่งที่ต้องการอย่างเดียว ถ้าสิ่งนั้นใหญ่มาก อาจจะควรแยกฟังก์ชันออกเป็นฟังก์ชันเล็กๆ สองสามตัว บางทีการทำตามกฎนี้อาจจะไม่ง่ายนัก แต่มันเป็นสิ่งที่ดีอย่างแน่นอน

ฟังก์ชันแยกต่างหากไม่ใช่แค่ทำให้ทดสอบและดีบั๊กง่ายขึ้น -- การมีอยู่ของมันเองก็เป็นคอมเมนต์ที่ดีมากแล้ว!

ยกตัวอย่างเช่น ลองเปรียบเทียบฟังก์ชัน `showPrimes(n)` สองตัวด้านล่าง แต่ละตัวแสดงผล[จำนวนเฉพาะ](https://en.wikipedia.org/wiki/Prime_number)จนถึง `n`

ตัวแรกใช้ label:

```js
function showPrimes(n) {
  nextPrime: for (let i = 2; i < n; i++) {

    for (let j = 2; j < i; j++) {
      if (i % j == 0) continue nextPrime;
    }

    alert( i ); // จำนวนเฉพาะ
  }
}
```

ตัวที่สองใช้ฟังก์ชันเพิ่มเติม `isPrime(n)` เพื่อตรวจสอบว่าเป็นจำนวนเฉพาะหรือไม่:

```js
function showPrimes(n) {

  for (let i = 2; i < n; i++) {
    *!*if (!isPrime(i)) continue;*/!*

    alert(i);  // จำนวนเฉพาะ
  }
}

function isPrime(n) {
  for (let i = 2; i < n; i++) {
    if ( n % i == 0) return false;
  }
  return true;
}
```

ตัวที่สองเข้าใจง่ายกว่าใช่ไหม? แทนที่จะมีชิ้นส่วนของโค้ด เราเห็นเป็นชื่อของการกระทำ (`isPrime`) บางครั้งคนเรียกโค้ดแบบนี้ว่า *self-describing*

ดังนั้น ฟังก์ชันสามารถถูกสร้างขึ้นได้แม้ว่าเราจะไม่ต้องการเอามันไปใช้ซ้ำ มันช่วยจัดโครงสร้างโค้ดและทำให้โค้ดอ่านง่ายขึ้น

## สรุป

การประกาศฟังก์ชันมีหน้าตาดังนี้:

```js
function name(parameters, delimited, by, comma) {
  /* code */
}
```

- ค่าที่ส่งเข้าไปในฟังก์ชันในรูปแบบของพารามิเตอร์จะถูกคัดลอกไปยังตัวแปรภายในของฟังก์ชัน
- ฟังก์ชันสามารถเข้าถึงตัวแปรภายนอกได้ แต่มันทำได้เฉพาะจากด้านในออกไปเท่านั้น โค้ดภายนอกฟังก์ชันจะไม่เห็นตัวแปรภายในของฟังก์ชัน
- ฟังก์ชันสามารถส่งค่ากลับได้ ถ้าไม่ส่ง ผลลัพธ์ของมันจะเป็น `undefined`

เพื่อให้โค้ดสะอาดและเข้าใจง่าย แนะนำให้ใช้ตัวแปรภายในและพารามิเตอร์เป็นหลักในฟังก์ชัน ไม่ใช้ตัวแปรภายนอก

การเข้าใจฟังก์ชันที่รับพารามิเตอร์ ทำงานกับพารามิเตอร์เหล่านั้น และส่งผลลัพธ์กลับ จะง่ายกว่าการเข้าใจฟังก์ชันที่ไม่รับพารามิเตอร์ แต่ไปแก้ไขตัวแปรภายนอกเป็น side effect

การตั้งชื่อฟังก์ชัน:

- ชื่อควรอธิบายอย่างชัดเจนว่าฟังก์ชันทำอะไร เมื่อเราเห็นการเรียกฟังก์ชันในโค้ด ชื่อที่ดีควรบอกได้ทันทีว่ามันทำอะไรและส่งอะไรกลับ
- ฟังก์ชันคือการกระทำ ดังนั้นชื่อฟังก์ชันจึงมักจะเป็นคำกริยา
- มีคำนำหน้าของฟังก์ชันที่รู้จักกันดีมากมาย เช่น `create…`, `show…`, `get…`, `check…` เป็นต้น ใช้พวกนี้เพื่อบอกใบ้ว่าฟังก์ชันทำอะไร

ฟังก์ชันคือ building blocks หลักของสคริปต์ ตอนนี้เราได้ครอบคลุมพื้นฐานแล้ว ดังนั้นเรามีความรู้พอที่จะเริ่มสร้างและใช้ฟังก์ชันได้แล้ว แต่นั่นเป็นเพียงจุดเริ่มต้นของเส้นทางเท่านั้น เรายังจะย้อนกลับมาที่ฟังก์ชันอีกหลายครั้ง เพื่อเจาะลึกลงไปในฟีเจอร์ขั้นสูงของมัน