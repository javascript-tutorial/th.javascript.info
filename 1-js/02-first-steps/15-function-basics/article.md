# ฟังก์ชัน

บ่อยครั้งที่เราต้องทำการกระทำที่คล้ายๆ กันในหลายๆ ที่ของสคริปต์

เช่น เราอาจต้องแสดงข้อความที่ดูดีเมื่อผู้ใช้ล็อกอิน ล็อกเอาท์ หรือที่อื่นๆ

ฟังก์ชันคือ "บล็อกสร้าง" หลักของโปรแกรม มันทำให้เราเรียกใช้โค้ดได้หลายครั้งโดยไม่ต้องเขียนซ้ำ

เราเคยเห็นตัวอย่างฟังก์ชันที่มีมาในตัวแล้ว เช่น `alert(message)`, `prompt(message, default)` และ `confirm(question)` แต่เราก็สามารถสร้างฟังก์ชันของตัวเองได้ด้วย

## การประกาศฟังก์ชัน

ในการสร้างฟังก์ชัน เราสามารถใช้ *การประกาศฟังก์ชัน*

ซึ่งมีรูปแบบดังนี้:

```js
function showMessage() {
  alert( 'สวัสดีทุกคน!' );
}
```

ใช้คีย์เวิร์ด `function` ก่อน ตามด้วย*ชื่อฟังก์ชัน* แล้วก็รายการ *parameter* ในวงเล็บ (คั่นด้วยเครื่องหมายจุลภาค ในตัวอย่างข้างบนจะเว้นว่าง เดี๋ยวจะมีตัวอย่างอีกทีหลัง) สุดท้ายคือโค้ดของฟังก์ชันระหว่างปีกกาปิดเปิด ที่เรียกว่า "ตัวฟังก์ชัน" หรือ "function body" 

```js
function name(parameter1, parameter2, ... parameterN) {
  // ตัวฟังก์ชัน
}
```

ฟังก์ชันใหม่ของเราสามารถเรียกใช้ได้ด้วยชื่อของมัน เช่น: `showMessage()`

ดังตัวอย่าง:

```js run
function showMessage() {
  alert( 'สวัสดีทุกคน!' );
}

*!*
showMessage();
showMessage();
*/!*  
```

เมื่อเรียก `showMessage()` ก็จะรันโค้ดในตัวฟังก์ชัน ในที่นี้เราจะเห็นข้อความถูกแสดงสองครั้ง

ตัวอย่างนี้แสดงให้เห็นวัตถุประสงค์หลักอย่างหนึ่งของฟังก์ชัน นั่นคือเพื่อหลีกเลี่ยงการเขียนโค้ดซ้ำ

ถ้าเราต้องการเปลี่ยนข้อความหรือวิธีแสดงผล ก็แค่แก้ไขโค้ดในที่เดียว นั่นคือในตัวฟังก์ชันที่ทำการแสดงผลมัน

## ตัวแปรภายในฟังก์ชัน (Local variables)

ตัวแปรที่ประกาศภายในฟังก์ชัน จะมองเห็นได้เฉพาะภายในฟังก์ชันนั้นเท่านั้น

ตัวอย่างเช่น:

```js run
function showMessage() {
*!*
  let message = "Hello, I'm JavaScript!"; // ตัวแปรท้องถิ่น
*/!*

  alert( message );
}

showMessage(); // Hello, I'm JavaScript!

alert( message ); // <-- Error! ตัวแปรอยู่ภายในฟังก์ชัน ไม่สามารถเข้าถึงจากภายนอกได้
```

## ตัวแปรภายนอก (Outer variables)

ฟังก์ชันสามารถเข้าถึงตัวแปรภายนอกได้ด้วย เช่น:

```js run no-beautify
let *!*userName*/!* = 'John';

function showMessage() {
  let message = 'Hello, ' + *!*userName*/!*;
  alert(message);
}

showMessage(); // Hello, John
```

ฟังก์ชันสามารถเข้าถึงตัวแปรภายนอกได้อย่างเต็มที่ และยังสามารถแก้ไขค่าได้ด้วย

ตัวอย่างเช่น:

```js run
let *!*userName*/!* = 'John';

function showMessage() {
  *!*userName*/!* = "Bob"; // (1) เปลี่ยนค่าตัวแปรภายนอก

  let message = 'Hello, ' + *!*userName*/!*;
  alert(message);
}

alert( userName ); // *!*John*/!* ก่อนเรียกฟังก์ชัน

showMessage();

alert( userName ); // *!*Bob*/!*, ค่าถูกเปลี่ยนโดยฟังก์ชัน  
```

ตัวแปรภายนอกจะถูกใช้ก็ต่อเมื่อไม่มีตัวแปรภายในฟังก์ชั่นที่ชื่อเดียวกัน

ถ้ามีการประกาศตัวแปรที่ชื่อซ้ำกันภายในฟังก์ชัน มันจะ *บดบัง* ตัวแปรภายนอก เช่น ในโค้ดด้านล่าง ฟังก์ชันจะใช้ `userName` ภายในของตัวเอง ส่วนตัวภายนอกจะถูกมองข้าม:

```js run
let userName = 'John';

function showMessage() {
*!*
  let userName = "Bob"; // ประกาศตัวแปรท้องถิ่น 
*/!*

  let message = 'Hello, ' + userName; // *!*Bob*/!*
  alert(message);
}

// ฟังก์ชันจะสร้างและใช้ userName ของตัวเอง
showMessage();

alert( userName ); // *!*John*/!*, ไม่เปลี่ยนแปลง เพราะฟังก์ชันไม่ได้เข้าถึงตัวแปรภายนอก
```

```smart header="ตัวแปรโกลบอล (Global variables)"
ตัวแปรที่ประกาศนอกฟังก์ชันใดๆ เช่น `userName` ภายนอกในตัวอย่างข้างต้น เรียกว่า *ตัวแปรโกลบอล* 

ตัวแปรโกลบอลจะมองเห็นได้จากทุกฟังก์ชัน (ยกเว้นถูกบดบังโดยตัวแปรภายในฟังก์ชั่น)

เป็นแนวทางปฏิบัติที่ดีที่จะลดการใช้ตัวแปรโกลบอล โค้ดสมัยใหม่มักมีตัวแปรโกลบอลน้อยมากหรือไม่มีเลย ตัวแปรส่วนใหญ่จะอยู่ภายในฟังก์ชันของตัวเอง อย่างไรก็ตาม บางครั้งตัวแปรโกลบอลก็มีประโยชน์ในการเก็บข้อมูลระดับโปรเจกต์
```

## พารามิเตอร์ (Parameters)

เราสามารถส่งผ่านข้อมูลใดๆ ไปยังฟังก์ชันโดยใช้พารามิเตอร์ได้

ในตัวอย่างด้านล่าง ฟังก์ชันมีพารามิเตอร์สองตัวคือ `from` และ `text`

```js run
function showMessage(*!*from, text*/!*) { // พารามิเตอร์: from, text
  alert(from + ': ' + text);
}

*!*showMessage('Ann', 'Hello!');*/!* // Ann: Hello! (*)
*!*showMessage('Ann', "What's up?");*/!* // Ann: What's up? (**)
```

เมื่อฟังก์ชันถูกเรียกในบรรทัด `(*)` และ `(**)` ค่าที่ส่งเข้าไปจะถูกคัดลอกไปยังตัวแปรท้องถิ่น `from` และ `text` จากนั้นฟังก์ชันก็จะใช้ตัวแปรเหล่านั้น

นี่คืออีกตัวอย่าง: เรามีตัวแปร `from` และส่งผ่านมันเข้าไปในฟังก์ชัน สังเกตว่า ฟังก์ชันเปลี่ยนค่า `from` แต่การเปลี่ยนแปลงนั้นจะไม่ปรากฏภายนอก เพราะฟังก์ชันจะได้รับสำเนาของค่าเสมอ:

```js run
function showMessage(from, text) {

*!*
  from = '*' + from + '*'; // ทำให้ "from" ดูสวยงามขึ้น
*/!*

  alert( from + ': ' + text );
}

let from = "Ann";

showMessage(from, "Hello"); // *Ann*: Hello

// ค่าของ "from" ยังเหมือนเดิม ฟังก์ชันแก้ไขสำเนาในตัวเอง
alert( from ); // Ann  
```

เมื่อค่าถูกส่งผ่านเข้าไปเป็นพารามิเตอร์ของฟังก์ชัน เราเรียกค่านั้นว่า *อาร์กิวเมนต์ (argument)*

หรือพูดอีกอย่างคือ เพื่อให้เข้าใจคำศัพท์ชัดเจน:

- พารามิเตอร์ คือตัวแปรที่ระบุในวงเล็บตอนประกาศฟังก์ชัน (เป็นคำศัพท์ช่วงประกาศ)
- อาร์กิวเมนต์ คือค่าที่ส่งผ่านเข้าไปในฟังก์ชันตอนเรียกใช้ (เป็นคำศัพท์ช่วงเรียกใช้)

เราประกาศฟังก์ชันโดยระบุพารามิเตอร์ของมัน จากนั้นเรียกใช้มันโดยส่งผ่านอาร์กิวเมนต์เข้าไป

ในตัวอย่างข้างบน เราอาจพูดว่า: "ฟังก์ชัน `showMessage` ถูกประกาศด้วยพารามิเตอร์สองตัว จากนั้นถูกเรียกใช้ด้วยอาร์กิวเมนต์สองตัวคือ `from` และ `"Hello"`"

## ค่าเริ่มต้น (Default values)

หากฟังก์ชันถูกเรียกใช้แต่ไม่ได้ส่งอาร์กิวเมนต์มาด้วย ค่าที่สอดคล้องกันจะเป็น `undefined`

ยกตัวอย่างเช่น ฟังก์ชัน `showMessage(from, text)` ที่กล่าวถึงก่อนหน้า สามารถเรียกใช้ด้วยอาร์กิวเมนต์เพียงตัวเดียวได้:

```js
showMessage("Ann");
```

นี่ไม่ใช่ข้อผิดพลาด การเรียกแบบนี้จะแสดงผลเป็น `"*Ann*: undefined"` เนื่องจากไม่ได้ส่งค่าให้กับพารามิเตอร์ `text` จึงมีค่าเป็น `undefined`

เราสามารถระบุค่าที่เรียกว่า "ค่าเริ่มต้น" (ใช้เมื่อไม่ได้ส่งค่ามา) สำหรับพารามิเตอร์ในการประกาศฟังก์ชันได้ โดยใช้ `=`:

```js run
function showMessage(from, *!*text = "no text given"*/!*) {
  alert( from + ": " + text );
}

showMessage("Ann"); // Ann: no text given
```

ตอนนี้ถ้าไม่ได้ส่งพารามิเตอร์ `text` มา มันจะมีค่าเป็น `"no text given"`

ค่าเริ่มต้นจะถูกนำมาใช้ด้วย ถ้าพารามิเตอร์มีอยู่แต่ค่าเป็น `undefined` อย่างเคร่งครัด เช่นนี้:

```js
showMessage("Ann", undefined); // Ann: no text given
```

ในที่นี้ `"no text given"` เป็น string แต่มันสามารถเป็นนิพจน์ที่ซับซ้อนกว่านั้นได้ ซึ่งจะถูกประเมินค่าและกำหนดให้เฉพาะเมื่อไม่ได้ส่งพารามิเตอร์มาเท่านั้น ดังนั้นสิ่งนี้ก็เป็นไปได้:

```js run
function showMessage(from, text = anotherFunction()) {
  // anotherFunction() จะถูกเรียกใช้เฉพาะเมื่อไม่ได้ส่ง text มา
  // ผลลัพธ์ของมันจะกลายเป็นค่าของ text
}
```

```smart header="การประเมินค่าพารามิเตอร์เริ่มต้น"
ใน JavaScript พารามิเตอร์เริ่มต้นจะถูกประเมินค่าทุกครั้งที่เรียกใช้ฟังก์ชันโดยไม่ส่งพารามิเตอร์ที่เกี่ยวข้อง

ในตัวอย่างข้างต้น `anotherFunction()` จะไม่ถูกเรียกใช้เลย ถ้าส่งพารามิเตอร์ `text` มา

ในทางกลับกัน มันจะถูกเรียกใช้แยกต่างหากทุกครั้งที่ไม่ได้ส่ง `text` มา
```

````smart header="พารามิเตอร์เริ่มต้นในโค้ด JavaScript เก่า"
เมื่อหลายปีก่อน JavaScript ไม่รองรับไวยากรณ์ของพารามิเตอร์เริ่มต้น ดังนั้นคนจึงใช้วิธีอื่นในการระบุค่าเริ่มต้น

ปัจจุบันเราอาจพบเจอสิ่งเหล่านี้ในสคริปต์เก่าๆ 

เช่น การตรวจสอบ `undefined` อย่างชัดเจน:

```js
function showMessage(from, text) {
*!*
  if (text === undefined) {
    text = 'no text given';
  }
*/!*

  alert( from + ": " + text );
}
```

...หรือใช้ตัวดำเนินการ `||`:

```js  
function showMessage(from, text) {
  // ถ้าค่าของ text เป็น falsy ให้กำหนดค่าเริ่มต้น
  // ซึ่งสมมติว่า text == "" เหมือนกับไม่มี text เลย
  text = text || 'no text given';
  ...
}
```
````

### พารามิเตอร์เริ่มต้นทางเลือก

บางครั้งการกำหนดค่าเริ่มต้นให้พารามิเตอร์ในภายหลัง หลังจากประกาศฟังก์ชันไปแล้ว ก็มีเหตุผลเช่นกัน

เราสามารถตรวจสอบว่ามีการส่งพารามิเตอร์มาหรือไม่ระหว่างการทำงานของฟังก์ชัน โดยเปรียบเทียบกับ `undefined`:

```js run
function showMessage(text) {
  // ...

*!*
  if (text === undefined) { // ถ้าไม่มีพารามิเตอร์ส่งมา
    text = 'ข้อความว่าง';  
  }
*/!*

  alert(text);
}

showMessage(); // ข้อความว่าง
```

...หรือเราสามารถใช้ตัวดำเนินการ `||`:

```js
function showMessage(text) {
  // ถ้า text เป็น undefined หรือ falsy อื่นๆ ให้กำหนดเป็น 'empty'
  text = text || 'empty';
  ...  
}
```

JavaScript เอนจินสมัยใหม่รองรับ[ตัวดำเนินการรวม nullish](info:nullish-coalescing-operator) `??` ซึ่งจะเหมาะกว่าเมื่อต้องการให้ค่า falsy ส่วนใหญ่ เช่น `0` ถือเป็นค่า "ปกติ":

```js run
function showCount(count) {
  // ถ้า count เป็น undefined หรือ null ให้แสดง "unknown"
  alert(count ?? "unknown");
}

showCount(0); // 0
showCount(null); // unknown 
showCount(); // unknown
```

## การส่งคืนค่า (Returning a value)

ฟังก์ชันสามารถส่งคืนค่ากลับไปยังโค้ดที่เรียกใช้เป็นผลลัพธ์ได้

ตัวอย่างง่ายๆ คือฟังก์ชันที่รวมผลบวกของสองค่า:

```js run no-beautify
function sum(a, b) {
  *!*return*/!* a + b;
}

let result = sum(1, 2);
alert( result ); // 3
```

คำสั่ง `return` สามารถอยู่ที่ไหนก็ได้ในฟังก์ชัน เมื่อการทำงานมาถึงมัน ฟังก์ชันจะหยุดและส่งคืนค่าไปยังโค้ดที่เรียกใช้ (กำหนดให้กับ `result` ในตัวอย่างข้างต้น)  

ในฟังก์ชันเดียวอาจมีหลายจุดที่ใช้ `return` ได้ เช่น:

```js run
function checkAge(age) {
  if (age >= 18) {
*!*
    return true;
*/!*
  } else {
*!*
    return confirm('คุณได้รับอนุญาตจากผู้ปกครองหรือไม่?');
*/!*
  }
}

let age = prompt('คุณอายุเท่าไหร่?', 18);

if ( checkAge(age) ) {
  alert('อนุญาตให้เข้าใช้งาน');
} else {
  alert('ไม่อนุญาตให้เข้าใช้งาน');
}
```

เราสามารถใช้ `return` โดยไม่มีค่าก็ได้ ซึ่งจะทำให้ฟังก์ชันจบการทำงานทันที

ตัวอย่างเช่น:

```js
function showMovie(age) {
  if ( !checkAge(age) ) {
*!*
    return;
*/!*
  }

  alert("กำลังแสดงภาพยนตร์ให้ชม"); // (*)
  // ...
}
```

ในโค้ดข้างต้น ถ้า `checkAge(age)` คืนค่า `false` ฟังก์ชัน `showMovie` จะไม่ทำงานต่อไปที่ `alert`

````smart header="ฟังก์ชันที่มี `return` ว่างหรือไม่มี `return` จะคืนค่า `undefined`"
ถ้าฟังก์ชันไม่มีการคืนค่า มันจะเหมือนกับการคืนค่า `undefined`:

```js run
function doNothing() { /* ว่าง */ }

alert( doNothing() === undefined ); // true
```

`return` ว่างก็เหมือนกับ `return undefined`:

```js run  
function doNothing() {
  return;
}

alert( doNothing() === undefined ); // true
```
````

````warn header="อย่าขึ้นบรรทัดใหม่ระหว่าง `return` กับค่าที่คืน"
สำหรับนิพจน์ยาวๆ ใน `return` อาจเย้ายวนใจให้แยกเป็นบรรทัดใหม่ แบบนี้:

```js
return
 (some + long + expression + or + whatever * f(a) + f(b))
```
นั่นจะไม่ทำงาน เพราะ JavaScript จะสันนิษฐานว่ามีเครื่องหมายอัฒภาคหลัง `return` ซึ่งจะทำงานเหมือนกับ:

```js  
return*!*;*/!*
 (some + long + expression + or + whatever * f(a) + f(b))
```

ดังนั้นมันจะกลายเป็น return เปล่าๆ อย่างมีประสิทธิภาพ 

ถ้าเราต้องการให้นิพจน์ที่คืนค่าขึ้นบรรทัดใหม่ เราควรเริ่มต้นในบรรทัดเดียวกับ `return` หรืออย่างน้อยควรใส่วงเล็บเปิดเอาไว้ที่นั่น แบบนี้:

```js
return (
  some + long + expression
  + or +
  whatever * f(a) + f(b)
  )
```

และมันจะทำงานตามที่เราคาดหวัง
````

## การตั้งชื่อฟังก์ชัน [#function-naming]

ฟังก์ชันคือการกระทำ ดังนั้นชื่อของมันมักจะเป็นคำกริยา ชื่อควรสั้นกระชับ ตรงประเด็นที่สุดเท่าที่จะเป็นไปได้ และบ่งบอกว่าฟังก์ชันทำอะไร เพื่อให้คนที่อ่านโค้ดเข้าใจได้ทันทีว่าฟังก์ชันนั้นทำหน้าที่อะไร

เป็นแนวปฏิบัติที่แพร่หลายในการขึ้นต้นชื่อฟังก์ชันด้วยคำกริยาเพื่ออธิบายการกระทำคร่าวๆ ทีมงานควรตกลงกันเรื่องความหมายของคำนำหน้าเหล่านี้ให้ชัดเจน

ตัวอย่างเช่น ฟังก์ชันที่ขึ้นต้นด้วย `"show"` มักจะแสดงบางอย่าง

ฟังก์ชันที่ขึ้นต้นด้วย...

- `"get…"` -- คืนค่าบางอย่าง
- `"calc…"` -- คำนวณบางอย่าง  
- `"create…"` -- สร้างบางอย่าง
- `"check…"` -- ตรวจสอบบางอย่างและคืนค่าบูลีน ฯลฯ

ตัวอย่างชื่อฟังก์ชันเหล่านี้:

```js no-beautify
showMessage(..)     // แสดงข้อความ
getAge(..)          // คืนค่าอายุ (ได้ค่ามาด้วยวิธีใดวิธีหนึ่ง)
calcSum(..)         // คำนวณผลรวมและคืนผลลัพธ์  
createForm(..)      // สร้างฟอร์ม (และมักจะคืนค่าฟอร์มนั้น)
checkPermission(..) // ตรวจสอบสิทธิ์ คืนค่า true/false
```

เมื่อใช้คำนำหน้าแล้ว เพียงแค่มองชื่อฟังก์ชันก็พอจะเข้าใจได้ว่ามันทำงานแบบไหนและคืนค่าประเภทใด

```smart header="หนึ่งฟังก์ชัน -- หนึ่งการกระทำ"
ฟังก์ชันควรทำในสิ่งที่ชื่อของมันบอกไว้ ไม่มากไปกว่านั้น

การกระทำสองอย่างที่เป็นอิสระจากกัน มักสมควรแยกเป็นสองฟังก์ชัน แม้ว่าปกติจะถูกเรียกใช้ด้วยกัน (ในกรณีนั้นเราอาจสร้างฟังก์ชันที่สามเพื่อเรียกใช้ทั้งสองฟังก์ชันนั้น)

ตัวอย่างที่ละเมิดกฎข้อนี้:

- `getAge` -- จะไม่ดีถ้ามันแสดง `alert` บอกอายุด้วย (ควรแค่ดึงค่าอายุเท่านั้น)
- `createForm` -- จะไม่ดีถ้ามันแก้ไขเอกสารด้วยการเพิ่มฟอร์มเข้าไป (ควรแค่สร้างฟอร์มและคืนค่า)  
- `checkPermission` -- จะไม่ดีถ้ามันแสดงข้อความ `อนุญาต/ไม่อนุญาตให้เข้าถึง` (ควรแค่ตรวจสอบและคืนผลลัพธ์)

ตัวอย่างเหล่านี้สมมติความหมายทั่วไปของคำนำหน้า คุณและทีมสามารถตกลงกันถึงความหมายอื่นๆ ได้ แต่โดยปกติมักจะไม่ค่อยแตกต่างกันมาก ไม่ว่าอย่างไร คุณควรเข้าใจชัดเจนว่าคำนำหน้าหมายถึงอะไร ฟังก์ชันที่มีคำนำหน้าสามารถและไม่ควรทำอะไรได้บ้าง ฟังก์ชันที่มีคำนำหน้าเดียวกันทั้งหมดควรปฏิบัติตามกฎเดียวกัน และทีมควรแบ่งปันความรู้นี้ร่วมกัน
```

```smart header="ชื่อฟังก์ชันที่สั้นมากๆ"
ฟังก์ชันที่ถูกใช้ *บ่อยมากๆ* บางครั้งอาจมีชื่อที่สั้นมากๆ

เช่น เฟรมเวิร์ค [jQuery](https://jquery.com/) กำหนดฟังก์ชันชื่อ `$` ส่วนไลบรารี [Lodash](https://lodash.com/) มีฟังก์ชันหลักชื่อ `_`

แต่สิ่งเหล่านี้เป็นข้อยกเว้น โดยทั่วไปแล้วชื่อฟังก์ชันควรกระชับและบ่งบอกความหมายได้ชัดเจน
```