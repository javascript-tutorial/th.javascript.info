# ฟังก์ชัน

บ่อยครั้งที่เราต้องทำการกระทำที่คล้ายๆ กันในหลายๆ ที่ของสคริปต์

เช่น เราอาจต้องแสดงข้อความที่ดูดีเมื่อผู้ใช้ล็อกอิน ล็อกเอาท์ หรือที่อื่นๆ

ฟังก์ชันคือ "บล็อกสร้าง" หลักของโปรแกรม มันทำให้เราเรียกใช้โค้ดได้หลายครั้งโดยไม่ต้องเขียนซ้ำ

เราเคยเห็นตัวอย่างฟังก์ชันที่มีมาในตัวแล้ว เช่น `alert(message)`, `prompt(message, default)` และ `confirm(question)` แต่เราก็สามารถสร้างฟังก์ชันของตัวเองได้ด้วย

## การประกาศฟังก์ชัน

ในการสร้างฟังก์ชัน เราสามารถใช้ *การประกาศฟังก์ชัน*

ซึ่งมีรูปแบบดังนี้:

```js
function showMessage() {
  alert( 'สวัสดีทุกคน!' );
}
```

ใช้คีย์เวิร์ด `function` ก่อน ตามด้วย*ชื่อฟังก์ชัน* แล้วก็รายการ *parameter* ในวงเล็บ (คั่นด้วยเครื่องหมายจุลภาค ในตัวอย่างข้างบนจะเว้นว่าง เดี๋ยวจะมีตัวอย่างอีกทีหลัง) สุดท้ายคือโค้ดของฟังก์ชันระหว่างปีกกาปิดเปิด ที่เรียกว่า "ตัวฟังก์ชัน" หรือ "function body" 

```js
function name(parameter1, parameter2, ... parameterN) {
  // ตัวฟังก์ชัน
}
```

ฟังก์ชันใหม่ของเราสามารถเรียกใช้ได้ด้วยชื่อของมัน เช่น: `showMessage()`

ดังตัวอย่าง:

```js run
function showMessage() {
  alert( 'สวัสดีทุกคน!' );
}

*!*
showMessage();
showMessage();
*/!*  
```

เมื่อเรียก `showMessage()` ก็จะรันโค้ดในตัวฟังก์ชัน ในที่นี้เราจะเห็นข้อความถูกแสดงสองครั้ง

ตัวอย่างนี้แสดงให้เห็นวัตถุประสงค์หลักอย่างหนึ่งของฟังก์ชัน นั่นคือเพื่อหลีกเลี่ยงการเขียนโค้ดซ้ำ

ถ้าเราต้องการเปลี่ยนข้อความหรือวิธีแสดงผล ก็แค่แก้ไขโค้ดในที่เดียว นั่นคือในตัวฟังก์ชันที่ทำการแสดงผลมัน

## ตัวแปรภายในฟังก์ชัน (Local variables)

ตัวแปรที่ประกาศภายในฟังก์ชัน จะมองเห็นได้เฉพาะภายในฟังก์ชันนั้นเท่านั้น

ตัวอย่างเช่น:

```js run
function showMessage() {
*!*
  let message = "Hello, I'm JavaScript!"; // ตัวแปรท้องถิ่น
*/!*

  alert( message );
}

showMessage(); // Hello, I'm JavaScript!

alert( message ); // <-- Error! ตัวแปรอยู่ภายในฟังก์ชัน ไม่สามารถเข้าถึงจากภายนอกได้
```

## ตัวแปรภายนอก (Outer variables)

ฟังก์ชันสามารถเข้าถึงตัวแปรภายนอกได้ด้วย เช่น:

```js run no-beautify
let *!*userName*/!* = 'John';

function showMessage() {
  let message = 'Hello, ' + *!*userName*/!*;
  alert(message);
}

showMessage(); // Hello, John
```

ฟังก์ชันสามารถเข้าถึงตัวแปรภายนอกได้อย่างเต็มที่ และยังสามารถแก้ไขค่าได้ด้วย

ตัวอย่างเช่น:

```js run
let *!*userName*/!* = 'John';

function showMessage() {
  *!*userName*/!* = "Bob"; // (1) เปลี่ยนค่าตัวแปรภายนอก

  let message = 'Hello, ' + *!*userName*/!*;
  alert(message);
}

alert( userName ); // *!*John*/!* ก่อนเรียกฟังก์ชัน

showMessage();

alert( userName ); // *!*Bob*/!*, ค่าถูกเปลี่ยนโดยฟังก์ชัน  
```

ตัวแปรภายนอกจะถูกใช้ก็ต่อเมื่อไม่มีตัวแปรภายในฟังก์ชั่นที่ชื่อเดียวกัน

ถ้ามีการประกาศตัวแปรที่ชื่อซ้ำกันภายในฟังก์ชัน มันจะ *บดบัง* ตัวแปรภายนอก เช่น ในโค้ดด้านล่าง ฟังก์ชันจะใช้ `userName` ภายในของตัวเอง ส่วนตัวภายนอกจะถูกมองข้าม:

```js run
let userName = 'John';

function showMessage() {
*!*
  let userName = "Bob"; // ประกาศตัวแปรท้องถิ่น 
*/!*

  let message = 'Hello, ' + userName; // *!*Bob*/!*
  alert(message);
}

// ฟังก์ชันจะสร้างและใช้ userName ของตัวเอง
showMessage();

alert( userName ); // *!*John*/!*, ไม่เปลี่ยนแปลง เพราะฟังก์ชันไม่ได้เข้าถึงตัวแปรภายนอก
```

```smart header="ตัวแปรโกลบอล (Global variables)"
ตัวแปรที่ประกาศนอกฟังก์ชันใดๆ เช่น `userName` ภายนอกในตัวอย่างข้างต้น เรียกว่า *ตัวแปรโกลบอล* 

ตัวแปรโกลบอลจะมองเห็นได้จากทุกฟังก์ชัน (ยกเว้นถูกบดบังโดยตัวแปรภายในฟังก์ชั่น)

เป็นแนวทางปฏิบัติที่ดีที่จะลดการใช้ตัวแปรโกลบอล โค้ดสมัยใหม่มักมีตัวแปรโกลบอลน้อยมากหรือไม่มีเลย ตัวแปรส่วนใหญ่จะอยู่ภายในฟังก์ชันของตัวเอง อย่างไรก็ตาม บางครั้งตัวแปรโกลบอลก็มีประโยชน์ในการเก็บข้อมูลระดับโปรเจกต์
```

## พารามิเตอร์ (Parameters)

เราสามารถส่งผ่านข้อมูลใดๆ ไปยังฟังก์ชันโดยใช้พารามิเตอร์ได้

ในตัวอย่างด้านล่าง ฟังก์ชันมีพารามิเตอร์สองตัวคือ `from` และ `text`

```js run
function showMessage(*!*from, text*/!*) { // พารามิเตอร์: from, text
  alert(from + ': ' + text);
}

*!*showMessage('Ann', 'Hello!');*/!* // Ann: Hello! (*)
*!*showMessage('Ann', "What's up?");*/!* // Ann: What's up? (**)
```

เมื่อฟังก์ชันถูกเรียกในบรรทัด `(*)` และ `(**)` ค่าที่ส่งเข้าไปจะถูกคัดลอกไปยังตัวแปรท้องถิ่น `from` และ `text` จากนั้นฟังก์ชันก็จะใช้ตัวแปรเหล่านั้น

นี่คืออีกตัวอย่าง: เรามีตัวแปร `from` และส่งผ่านมันเข้าไปในฟังก์ชัน สังเกตว่า ฟังก์ชันเปลี่ยนค่า `from` แต่การเปลี่ยนแปลงนั้นจะไม่ปรากฏภายนอก เพราะฟังก์ชันจะได้รับสำเนาของค่าเสมอ:

```js run
function showMessage(from, text) {

*!*
  from = '*' + from + '*'; // ทำให้ "from" ดูสวยงามขึ้น
*/!*

  alert( from + ': ' + text );
}

let from = "Ann";

showMessage(from, "Hello"); // *Ann*: Hello

// ค่าของ "from" ยังเหมือนเดิม ฟังก์ชันแก้ไขสำเนาในตัวเอง
alert( from ); // Ann  
```

เมื่อค่าถูกส่งผ่านเข้าไปเป็นพารามิเตอร์ของฟังก์ชัน เราเรียกค่านั้นว่า *อาร์กิวเมนต์ (argument)*

หรือพูดอีกอย่างคือ เพื่อให้เข้าใจคำศัพท์ชัดเจน:

- พารามิเตอร์ คือตัวแปรที่ระบุในวงเล็บตอนประกาศฟังก์ชัน (เป็นคำศัพท์ช่วงประกาศ)
- อาร์กิวเมนต์ คือค่าที่ส่งผ่านเข้าไปในฟังก์ชันตอนเรียกใช้ (เป็นคำศัพท์ช่วงเรียกใช้)

เราประกาศฟังก์ชันโดยระบุพารามิเตอร์ของมัน จากนั้นเรียกใช้มันโดยส่งผ่านอาร์กิวเมนต์เข้าไป

ในตัวอย่างข้างบน เราอาจพูดว่า: "ฟังก์ชัน `showMessage` ถูกประกาศด้วยพารามิเตอร์สองตัว จากนั้นถูกเรียกใช้ด้วยอาร์กิวเมนต์สองตัวคือ `from` และ `"Hello"`"

## ค่าเริ่มต้น (Default values)

หากฟังก์ชันถูกเรียกใช้แต่ไม่ได้ส่งอาร์กิวเมนต์มาด้วย ค่าที่สอดคล้องกันจะเป็น `undefined`

ยกตัวอย่างเช่น ฟังก์ชัน `showMessage(from, text)` ที่กล่าวถึงก่อนหน้า สามารถเรียกใช้ด้วยอาร์กิวเมนต์เพียงตัวเดียวได้:

```js
showMessage("Ann");
```

นี่ไม่ใช่ข้อผิดพลาด การเรียกแบบนี้จะแสดงผลเป็น `"*Ann*: undefined"` เนื่องจากไม่ได้ส่งค่าให้กับพารามิเตอร์ `text` จึงมีค่าเป็น `undefined`

เราสามารถระบุค่าที่เรียกว่า "ค่าเริ่มต้น" (ใช้เมื่อไม่ได้ส่งค่ามา) สำหรับพารามิเตอร์ในการประกาศฟังก์ชันได้ โดยใช้ `=`:

```js run
function showMessage(from, *!*text = "no text given"*/!*) {
  alert( from + ": " + text );
}

showMessage("Ann"); // Ann: no text given
```

ตอนนี้ถ้าไม่ได้ส่งพารามิเตอร์ `text` มา มันจะมีค่าเป็น `"no text given"`

ค่าเริ่มต้นจะถูกนำมาใช้ด้วย ถ้าพารามิเตอร์มีอยู่แต่ค่าเป็น `undefined` อย่างเคร่งครัด เช่นนี้:

```js
showMessage("Ann", undefined); // Ann: no text given
```

ในที่นี้ `"no text given"` เป็น string แต่มันสามารถเป็นนิพจน์ที่ซับซ้อนกว่านั้นได้ ซึ่งจะถูกประเมินค่าและกำหนดให้เฉพาะเมื่อไม่ได้ส่งพารามิเตอร์มาเท่านั้น ดังนั้นสิ่งนี้ก็เป็นไปได้:

```js run
function showMessage(from, text = anotherFunction()) {
  // anotherFunction() จะถูกเรียกใช้เฉพาะเมื่อไม่ได้ส่ง text มา
  // ผลลัพธ์ของมันจะกลายเป็นค่าของ text
}
```

```smart header="การประเมินค่าพารามิเตอร์เริ่มต้น"
ใน JavaScript พารามิเตอร์เริ่มต้นจะถูกประเมินค่าทุกครั้งที่เรียกใช้ฟังก์ชันโดยไม่ส่งพารามิเตอร์ที่เกี่ยวข้อง

ในตัวอย่างข้างต้น `anotherFunction()` จะไม่ถูกเรียกใช้เลย ถ้าส่งพารามิเตอร์ `text` มา

ในทางกลับกัน มันจะถูกเรียกใช้แยกต่างหากทุกครั้งที่ไม่ได้ส่ง `text` มา
```

````smart header="พารามิเตอร์เริ่มต้นในโค้ด JavaScript เก่า"
เมื่อหลายปีก่อน JavaScript ไม่รองรับไวยากรณ์ของพารามิเตอร์เริ่มต้น ดังนั้นคนจึงใช้วิธีอื่นในการระบุค่าเริ่มต้น

ปัจจุบันเราอาจพบเจอสิ่งเหล่านี้ในสคริปต์เก่าๆ 

เช่น การตรวจสอบ `undefined` อย่างชัดเจน:

```js
function showMessage(from, text) {
*!*
  if (text === undefined) {
    text = 'no text given';
  }
*/!*

  alert( from + ": " + text );
}
```

...หรือใช้ตัวดำเนินการ `||`:

```js  
function showMessage(from, text) {
  // ถ้าค่าของ text เป็น falsy ให้กำหนดค่าเริ่มต้น
  // ซึ่งสมมติว่า text == "" เหมือนกับไม่มี text เลย
  text = text || 'no text given';
  ...
}
```
````