# คำสั่ง "switch"

คำสั่ง `switch` สามารถใช้แทนการตรวจสอบ `if` หลายๆ ครั้งได้

มันให้วิธีที่อธิบายได้ชัดเจนกว่าในการเปรียบเทียบค่าหนึ่งกับหลายๆ กรณี

## รูปแบบ

คำสั่ง `switch` มีหนึ่งหรือหลาย `case` บล็อก และตัวเลือก `default`

มีรูปแบบดังนี้:

```js no-beautify
switch(x) {
  case 'ค่า1':  // ถ้า (x === 'ค่า1')
    ...
    [break]

  case 'ค่า2':  // ถ้า (x === 'ค่า2')
    ...
    [break]

  default:
    ...
    [break]
}
```

- ค่า `x` จะถูกตรวจสอบความเท่ากันอย่างเข้มงวด (strict equality) กับค่าจาก `case` แรก (คือ `ค่า1`) จากนั้นกับ `case` ที่สอง (`ค่า2`) และต่อไปเรื่อยๆ
- ถ้าพบว่าเท่ากัน `switch` จะเริ่มทำงานโค้ดจาก `case` ที่ตรงกันนั้น ไปจนถึง `break` ที่ใกล้ที่สุด (หรือจนจบ `switch`)
- ถ้าไม่มี case ใดตรงกัน จะรันโค้ดใน `default` (ถ้ามี)

## ตัวอย่าง

ตัวอย่างของ `switch` (ส่วนที่ถูกรันจะเน้นสีไว้):

```js run
let a = 2 + 2;

switch (a) {
  case 3:
    alert( 'เล็กเกินไป' );
    break;
*!*
  case 4:
    alert( 'ถูกต้องแล้ว!' );
    break;
*/!*
  case 5:
    alert( 'ใหญ่เกินไป' );
    break;
  default:
    alert( "ไม่รู้จักค่าแบบนี้" );
}
```

ในที่นี้ `switch` จะเริ่มเปรียบเทียบ `a` กับ variant `case` แรก คือ `3` ซึ่งไม่ตรงกัน

จากนั้นกับ `4` ซึ่งตรงกัน เพราะฉะนั้นการทำงานจะเริ่มจาก `case 4` ไปจนถึง `break` ที่ใกล้ที่สุด

**ถ้าไม่มี `break` การทำงานจะดำเนินต่อไปยัง `case` ถัดไปโดยไม่มีการตรวจสอบใดๆ**

ตัวอย่างที่ไม่มี `break`:

```js run
let a = 2 + 2;

switch (a) {
  case 3:
    alert( 'เล็กเกินไป' );
*!*
  case 4:
    alert( 'ถูกต้องแล้ว!' );
  case 5:
    alert( 'ใหญ่เกินไป' );
  default:
    alert( "ไม่รู้จักค่าแบบนี้" );
*/!*
}
```

ในตัวอย่างด้านบน เราจะเห็นการทำงานต่อเนื่องกันของ `alert` สามครั้ง:

```js
alert( 'ถูกต้องแล้ว!' );
alert( 'ใหญ่เกินไป' );
alert( "ไม่รู้จักค่าแบบนี้" );
```

````smart header="นิพจน์ใดๆ สามารถใช้เป็น argument ของ `switch/case` ได้"
ทั้ง `switch` และ `case` ยอมให้ใช้นิพจน์แบบใดก็ได้

ตัวอย่างเช่น:

```js run
let a = "1";
let b = 0;

switch (+a) {
*!*
  case b + 1:
    alert("นี่รัน เพราะ +a เป็น 1 ซึ่งเท่ากับ b+1 พอดี");
    break;
*/!*

  default:
    alert("นี่ไม่รัน");
}
```
ที่นี่ `+a` ให้ค่า `1` ซึ่งเปรียบเทียบกับ `b + 1` ใน `case` และโค้ดที่สอดคล้องกันจะทำงาน
````

## การจัดกลุ่มของ "case"

หลาย variant ของ `case` ที่ใช้โค้ดเดียวกันสามารถจัดกลุ่มเข้าด้วยกันได้

ตัวอย่างเช่น ถ้าเราต้องการให้โค้ดเดียวกันรันสำหรับทั้ง `case 3` และ `case 5`:

```js run no-beautify
let a = 3;

switch (a) {
  case 4:
    alert('ถูกต้อง!');
    break;

*!*
  case 3: // (*) จัดกลุ่มสอง case
  case 5:
    alert('ผิด!');
    alert("ทำไมคุณไม่ไปเรียนคณิตศาสตร์ดูล่ะ?");
    break;
*/!*

  default:
    alert('ผลลัพธ์แปลกๆ นะ');
}
```

ตอนนี้ทั้ง `3` และ `5` ก็จะแสดงข้อความเดียวกัน

ความสามารถในการ "จัดกลุ่ม" case เป็นผลข้างเคียงของวิธีการทำงานของ `switch/case` โดยไม่มี `break` ที่นี่การทำงานของ `case 3` เริ่มจากบรรทัด `(*)` และไปต่อยัง `case 5` เพราะไม่มี `break` 

## ชนิดข้อมูลมีความสำคัญ

ขอเน้นว่าการตรวจสอบความเท่ากันจะเป็นแบบเข้มงวด (strict equality) เสมอ ค่าต้องมีชนิดเดียวกันจึงจะตรงกัน

ตัวอย่างเช่น ลองพิจารณาโค้ดนี้:

```js run
let arg = prompt("ใส่ค่ามา");
switch (arg) {
  case '0':
  case '1':
    alert( 'ศูนย์หรือหนึ่ง' );
    break;

  case '2':
    alert( 'สอง' );
    break;

  case 3:
    alert( 'ไม่มีทางรัน!' );
    break;
  default:
    alert( 'ค่าที่ไม่รู้จัก' );
}
```

1. สำหรับ `0`, `1`, `alert` แรกจะทำงาน
2. สำหรับ `2`, `alert` ที่สองจะทำงาน  
3. แต่สำหรับ `3`, ผลลัพธ์ของ `prompt` คือสตริง `"3"`, ซึ่งไม่เท่ากับ `===` ตัวเลข `3` ดังนั้นเราจึงมีโค้ดที่ไม่มีทางรันใน `case 3`! ส่วน `default` จะทำงานแทน