# Function Expression

ในภาษา JavaScript ฟังก์ชันไม่ใช่แค่ "โครงสร้างภาษาที่พิเศษ" แต่ยังเป็นชนิดข้อมูลพิเศษอีกด้วย

ไวยากรณ์ที่เราเคยใช้มาก่อนหน้านี้เรียกว่า _Function Declaration_:

```js
function sayHi() {
  alert("สวัสดี");
}
```

นอกจากนี้ยังมีอีกรูปแบบหนึ่งในการสร้างฟังก์ชัน นั่นคือ _Function Expression_

Function Expression ช่วยให้เราสามารถสร้างฟังก์ชันใหม่ได้ระหว่างนิพจน์ (expression) ใดๆ

ตัวอย่างเช่น:

```js
let sayHi = function() {
  alert("สวัสดี");
};
```

ในที่นี้ เราจะเห็นว่าตัวแปร `sayHi` ได้รับการกำหนดค่าให้เป็นฟังก์ชันใหม่ ซึ่งถูกสร้างขึ้นมาเป็น `function() { alert("สวัสดี"); }`

เนื่องจากการสร้างฟังก์ชันนี้เกิดขึ้นในบริบทของนิพจน์กำหนดค่า (ทางขวาของเครื่องหมาย `=`) จึงเรียกว่าเป็น _Function Expression_

สังเกตได้ว่า ไม่มีการระบุชื่อต่อท้ายคีย์เวิร์ด `function` ซึ่งการละชื่อนี้สามารถทำได้กับ Function Expression

ในตัวอย่างนี้ เรากำหนดค่าให้กับตัวแปรทันที นั่นหมายความว่า "สร้างฟังก์ชันขึ้นมาแล้วกำหนดลงในตัวแปร `sayHi`"

ในสถานการณ์ที่ซับซ้อนกว่าซึ่งจะได้เจอในภายหลัง ฟังก์ชันอาจจะถูกสร้างและเรียกใช้งานทันที หรือถูกกำหนดเวลาให้รันภายหลัง โดยไม่จำเป็นต้องเก็บไว้ในตัวแปร ดังนั้นจึงมักจะไม่ระบุชื่อให้กับฟังก์ชันเหล่านี้

## ฟังก์ชันก็คือค่าชนิดหนึ่ง

ขอย้ำอีกครั้งว่า ไม่ว่าจะสร้างฟังก์ชันด้วยวิธีใด มันก็ยังคงเป็นค่า (value) อยู่วันยังค่ำ ในทั้งสองตัวอย่างข้างต้น เราเก็บฟังก์ชันไว้ในตัวแปร `sayHi`

เราสามารถแสดงค่าของฟังก์ชันออกมาด้วยคำสั่ง `alert` ได้เลย:

```js run
function sayHi() {
  alert("สวัสดี");
}

*!*
alert(sayHi); // แสดงโค้ดฟังก์ชัน
*/!*
```

สังเกตว่าบรรทัดสุดท้ายไม่ได้เรียกใช้ฟังก์ชัน เพราะไม่มีวงเล็บ `()` ต่อท้ายชื่อฟังก์ชัน `sayHi` ในบางภาษา การอ้างถึงชื่อฟังก์ชันอย่างเดียวจะเท่ากับการเรียกใช้มัน แต่ในจาวาสคริปต์ไม่เป็นเช่นนั้น

ในจาวาสคริปต์ ฟังก์ชันถือเป็นค่าประเภทหนึ่ง เราจึงสามารถจัดการมันได้เหมือนกับค่าชนิดอื่นๆ ในโค้ดด้านบน เราแปลงค่าของฟังก์ชันเป็นสตริง ซึ่งก็คือโค้ดต้นฉบับของฟังก์ชันนั่นเอง

แน่นอนว่าฟังก์ชันเป็นค่าที่พิเศษกว่าค่าปกติทั่วไป ตรงที่เราสามารถเรียกใช้งานมันได้ เช่น `sayHi()`

แต่ถึงอย่างนั้น มันก็ยังคงความเป็นค่าชนิดหนึ่งอยู่ เราจึงสามารถจัดการมันได้เหมือนกับค่าประเภทอื่นๆ

เราสามารถคัดลอกฟังก์ชันไปใส่ในตัวแปรอื่นได้:

```js run no-beautify
function sayHi() { // (1) สร้าง
  alert("สวัสดี");
}

let func = sayHi; // (2) คัดลอก 

func(); // สวัสดี     // (3) เรียกใช้ฟังก์ชันที่คัดลอกมา (ทำงานได้)!

sayHi(); // สวัสดี    // เรียกใช้ฟังก์ชันต้นฉบับก็ยังทำได้
```

มาดูว่าเกิดอะไรขึ้นในรายละเอียด:

1. Function Declaration `(1)` สร้างฟังก์ชันและเก็บไว้ในตัวแปร `sayHi`

2. บรรทัด `(2)` คัดลอกฟังก์ชันไปไว้ในตัวแปร `func` สังเกตว่าไม่มีวงเล็บ `()` ต่อท้ายชื่อ `sayHi` เพราะถ้ามี จะกลายเป็นเขียน _ผลลัพธ์_ จากการเรียก `sayHi()` ไปเก็บใน `func` ไม่ใช่เขียน _ฟังก์ชัน_ `sayHi` เอง

3. ตอนนี้ฟังก์ชันก็ถูกเรียกได้ทั้งในชื่อ `sayHi()` และ `func()`

หรือเราอาจจะใช้ Function Expression ตั้งแต่ต้นก็ได้:

```js
let sayHi = function() { // (1) สร้าง
  alert("สวัสดี");  
};

let func = sayHi;
// ...
```

ทุกอย่างก็ยังทำงานได้เหมือนเดิม

```smart header="ทำไมถึงมีเครื่องหมายอัฒภาคต่อท้าย?"

คุณอาจสงสัยว่าทำไม Function Expression ถึงมีเครื่องหมายอัฒภาค `;` ต่อท้าย ส่วน Function Declaration ไม่มี:

```js
function sayHi() {
  // ...
}

let sayHi = function() {
  // ...
}*!*;*/!*
```

คำตอบคือ เพราะ Function Expression ถูกสร้างภายในคำสั่งกำหนดค่าเป็น `function(...) {...}`: `let sayHi = ...;` ซึ่งจริงๆ แล้วเครื่องหมายอัฒภาค `;` เป็นสิ่งที่แนะนำให้ใส่ต่อท้ายคำสั่ง แต่ไม่ได้เป็นส่วนหนึ่งของไวยากรณ์ฟังก์ชัน

ถ้าเป็นการกำหนดค่าแบบง่ายๆ เช่น `let sayHi = 5;` ก็ควรมีเครื่องหมายอัฒภาคอยู่ด้วย รวมถึงตอนกำหนดฟังก์ชันก็เช่นกัน
````

## ฟังก์ชันคอลแบ็ก

มาดูตัวอย่างเพิ่มเติมของการส่งฟังก์ชันเป็นค่าและการใช้ Function Expression กัน

เราจะลองเขียนฟังก์ชัน `ask(question, yes, no)` ที่รับพารามิเตอร์ 3 ตัว:

`question`
: ข้อความคำถาม

`yes`
: ฟังก์ชันที่จะทำงานเมื่อคำตอบคือ "ใช่"

`no`
: ฟังก์ชันที่จะทำงานเมื่อคำตอบคือ "ไม่"

ฟังก์ชันนี้จะถามคำถาม `question` และเรียกใช้ `yes()` หรือ `no()` ขึ้นอยู่กับคำตอบที่ได้รับจากผู้ใช้:

```js run
*!*
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}
*/!*

function showOk() {
  alert("คุณเห็นด้วย");
}

function showCancel() {
  alert("คุณยกเลิก");
}

// วิธีเรียกใช้: ส่งฟังก์ชัน showOk, showCancel เป็นอาร์กิวเมนต์ให้ ask
ask("คุณเห็นด้วยไหม?", showOk, showCancel);
```

ในทางปฏิบัติ ฟังก์ชันแบบนี้ใช้ประโยชน์ได้มาก ความต่างหลักระหว่างฟังก์ชัน `ask` ในโลกจริงกับตัวอย่างด้านบนคือ ในโลกจริงฟังก์ชันมักใช้การโต้ตอบกับผู้ใช้ที่ซับซ้อนกว่า `confirm` ธรรมดา โดยเฉพาะในเบราว์เซอร์ที่ฟังก์ชันพวกนี้มักจะแสดงหน้าต่างคำถามที่สวยงาม แต่เรื่องนั้นเป็นอีกประเด็นหนึ่ง

**อาร์กิวเมนต์ `showOk` และ `showCancel` ของฟังก์ชัน `ask` เรียกว่า *ฟังก์ชันคอลแบ็ก* หรือเรียกสั้นๆ ว่า *คอลแบ็ก***

ไอเดียหลักๆ คือเราส่งฟังก์ชันไปเป็นค่า แล้วหวังว่ามันจะถูก "เรียกกลับมา" ในภายหลังเมื่อจำเป็น ในกรณีนี้ `showOk` กลายเป็นคอลแบ็กสำหรับคำตอบ "ใช่" และ `showCancel` สำหรับคำตอบ "ไม่"

เราสามารถเขียนโค้ดให้สั้นลงด้วยการใช้ Function Expression:

```js run no-beautify
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

*!*
ask(
  "คุณเห็นด้วยไหม?",
  function() { alert("คุณเห็นด้วย"); },
  function() { alert("คุณยกเลิก"); }
);
*/!*
```

ตรงนี้ฟังก์ชันถูกประกาศไว้โดยตรงภายในการเรียกใช้ `ask(...)` โดยไม่มีการตั้งชื่อ เรียกว่าฟังก์ชันแบบ *ไม่ระบุชื่อ (anonymous)* ฟังก์ชันเหล่านี้จะเข้าถึงจากภายนอก `ask` ไม่ได้ (เพราะไม่ได้ผูกกับตัวแปรใด) แต่ในกรณีนี้เราก็ไม่ต้องการให้มันเข้าถึงได้อยู่แล้ว  

โค้ดในลักษณะนี้มักจะเห็นได้บ่อยๆ ในสคริปต์ของพวกเรา ถือเป็นไปตามสไตล์การเขียนแบบ JavaScript

```smart header="ฟังก์ชันคือค่าที่ใช้ในการแทน \"การกระทำ\""
โดยปกติแล้ว ค่าอย่างสตริงหรือตัวเลขจะใช้แทน *ข้อมูล*

ส่วนฟังก์ชันนั้น สามารถมองได้ว่าเป็น *การกระทำ*

เราสามารถส่งมันเป็นค่าไปมาในตัวแปร และเรียกใช้มันได้เมื่อไหร่ก็ได้ที่ต้องการ 
```

## Function Expression กับ Function Declaration

มาสรุปความแตกต่างหลักระหว่าง Function Declaration และ Function Expression กัน

ก่อนอื่น มาดูที่ไวยากรณ์: วิธีแยกแยะสองอย่างนี้ในโค้ด

- *Function Declaration:* ฟังก์ชันที่ประกาศเป็นคำสั่งแยกเดี่ยวในโฟลว์หลักของโค้ด:

    ```js
    // Function Declaration
    function sum(a, b) {
      return a + b;
    }
    ```
- *Function Expression:* ฟังก์ชันที่ถูกสร้างขึ้นภายในนิพจน์หรือโครงสร้างไวยากรณ์อื่นๆ ในตัวอย่างนี้ ฟังก์ชันถูกสร้างขึ้นทางด้านขวาของ "นิพจน์กำหนดค่า" `=`:

    ```js
    // Function Expression
    let sum = function(a, b) {
      return a + b;
    };
    ```

ความแตกต่างที่ลึกซึ้งกว่านั้นคือ *เวลา* ที่ฟังก์ชันถูกสร้างขึ้นโดยเอ็นจิ้น JavaScript

**Function Expression จะถูกสร้างขึ้นเมื่อการทำงานมาถึงบรรทัดนั้น และใช้ได้ตั้งแต่ตอนนั้นเป็นต้นไปเท่านั้น**

เมื่อการประมวลผลไปถึงด้านขวาของการกำหนดค่า `let sum = function…` ตอนนี้ไงล่ะ ฟังก์ชันจะถูกสร้างขึ้น และสามารถนำไปใช้ได้ (เช่น กำหนดค่าให้ตัวแปร เรียกใช้งาน เป็นต้น) ตั้งแต่จุดนี้เป็นต้นไป

ในขณะที่ Function Declaration นั้นแตกต่างออกไป

**Function Declaration สามารถเรียกใช้ได้ก่อนที่จะมีการประกาศมันเสียอีก** 

ยกตัวอย่างเช่น Function Declaration ที่อยู่ในระดับโกลบอลจะมองเห็นได้ทั่วทั้งสคริปต์ ไม่ว่ามันจะถูกประกาศไว้ตรงไหนก็ตาม

นั่นเป็นเพราะกระบวนการภายใน ตอนที่ JavaScript เตรียมจะรันสคริปต์ มันจะค้นหา Function Declaration ในระดับโกลบอลก่อน แล้วสร้างฟังก์ชันเหล่านั้นขึ้น เราอาจมองเรียกมันว่า "ขั้นตอนเตรียมการ"

หลังจากที่ Function Declaration ทั้งหมดถูกประมวลผลเสร็จแล้ว การทำงานของโค้ดจึงเริ่มต้นขึ้น ดังนั้นจึงสามารถเข้าถึงฟังก์ชันเหล่านี้ได้ทันที

ดังเช่นตัวอย่างนี้ที่ทำงานได้:

```js run refresh untrusted
*!*
sayHi("John"); // Hello, John
*/!*

function sayHi(name) {
  alert( `Hello, ${name}` );
}
```

Function Declaration `sayHi` จะถูกสร้างขึ้นตอนที่ JavaScript เตรียมจะเริ่มรันสคริปต์ และจะมองเห็นได้ทั่วทั้งสคริปต์

...แต่ถ้าเป็น Function Expression มันจะไม่สามารถทำงานแบบนี้ได้:

```js run refresh untrusted
*!*
sayHi("John"); // เกิด error!
*/!*

let sayHi = function(name) {  // (*) ไม่มีเวทย์มนต์อีกต่อไป
  alert( `Hello, ${name}` );
};
```

Function Expression จะถูกสร้างขึ้นเมื่อการทำงานมาถึงบรรทัดนั้น ซึ่งในที่นี้ก็คือบรรทัด `(*)` ซึ่งมันสายไปเสียแล้ว

อีกหนึ่งคุณสมบัติพิเศษของ Function Declaration คือขอบเขตของบล็อก

**ในโหมดเข้มงวด ถ้า Function Declaration อยู่ภายในบล็อกโค้ด มันจะมองเห็นได้ทั่วทั้งภายในบล็อกนั้น แต่จะมองไม่เห็นจากภายนอกบล็อก**

ยกตัวอย่างเช่น สมมติเราต้องการประกาศฟังก์ชัน `welcome()` โดยขึ้นอยู่กับตัวแปร `age` ที่ได้มาตอน runtime และวางแผนจะใช้มันภายหลัง

ถ้าเราใช้ Function Declaration มันจะไม่ทำงานตามที่คาดหวัง:

```js run
let age = prompt("What is your age?", 18);

// ประกาศฟังก์ชันแบบมีเงื่อนไข
if (age < 18) {

  function welcome() {
    alert("Hello!");
  }

} else {

  function welcome() {
    alert("Greetings!");
  }

}

// ...วางแผนจะใช้ในภายหลัง
*!*
welcome(); // เกิด Error: welcome is not defined
*/!*
```

นั่นเป็นเพราะว่า Function Declaration จะมองเห็นได้เฉพาะภายในบล็อกโค้ดที่ประกาศมันเท่านั้น

ลองดูตัวอย่างอื่นอีก:

```js run
let age = 16; // สมมติใช้ 16 เป็นตัวอย่าง

if (age < 18) {
*!*
  welcome();               // \   (ทำงานได้)
*/!*
                           //  |
  function welcome() {     //  |  Function Declaration พร้อมใช้งาน
    alert("Hello!");       //  |  ได้ทุกที่ภายในบล็อกที่ประกาศมัน
  }                        //  |
                           //  |
*!*
  welcome();               // /   (ทำงานได้)
*/!*

} else {

  function welcome() {
    alert("Greetings!");
  }
}

// ตอนนี้เราอยู่นอกวงเล็บปีกกาแล้ว
// ดังนั้นจึงมองไม่เห็น Function Declaration ที่ประกาศภายในวงเล็บ

*!*
welcome(); // เกิด Error: welcome is not defined
*/!*
```

แล้วจะทำอย่างไรให้ `welcome` มองเห็นได้จากภายนอก `if` ล่ะ?

วิธีที่ถูกต้องคือใช้ Function Expression แล้วกำหนดค่า `welcome` ให้กับตัวแปรที่ประกาศไว้ภายนอก `if` ซึ่งจะทำให้มองเห็นได้อย่างถูกต้อง

ดังเช่นโค้ดนี้ที่ทำงานได้ตามที่ตั้งใจ:

```js run
let age = prompt("What is your age?", 18);

let welcome;

if (age < 18) {

  welcome = function() {
    alert("Hello!");
  };

} else {

  welcome = function() {
    alert("Greetings!");
  };

}

*!*
welcome(); // ตอนนี้ ok แล้ว
*/!*
```

หรือจะทำให้เรียบง่ายยิ่งขึ้นโดยใช้ตัวดำเนินการ `?`:

```js run
let age = prompt("What is your age?", 18);

let welcome = (age < 18) ?
  function() { alert("Hello!"); } :
  function() { alert("Greetings!"); };

*!*
welcome(); // ตอนนี้ ok แล้ว
*/!*
```


```smart header="เมื่อไหร่ควรเลือกใช้ Function Declaration กับ Function Expression?"
โดยทั่วไปแล้ว ถ้าเป็นไปได้ควรเลือกใช้ Function Declaration มันให้อิสระในการจัดระเบียบโค้ดมากกว่า เพราะเราสามารถเรียกฟังก์ชันพวกนี้ได้ก่อนที่จะประกาศมัน

นอกจากนี้ยังทำให้โค้ดอ่านง่ายขึ้นด้วย เพราะการมองหา `function f(…) {…}` ในโค้ดนั้นง่ายกว่า `let f = function(…) {…};` Function Declaration จะ "เด่น" กว่านั่นเอง

...แต่ถ้า Function Declaration ไม่เหมาะกับเราด้วยเหตุผลบางอย่าง หรือถ้าเราอยากประกาศฟังก์ชันแบบมีเงื่อนไข (อย่างในตัวอย่างที่เราเห็นไปเมื่อกี้) การใช้ Function Expression ก็จะเหมาะสมกว่า
```