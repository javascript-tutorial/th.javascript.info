# นิพจน์ฟังก์ชัน

ใน JavaScript ฟังก์ชันไม่ใช่ "โครงสร้างพิเศษทางภาษา" แต่เป็นค่าชนิดหนึ่งที่มีลักษณะเฉพาะ

รูปแบบที่เราใช้ก่อนหน้านี้เรียกว่า *การประกาศฟังก์ชัน* (Function Declaration):

```js
function sayHi() {
  alert( "Hello" );
}
```

มีอีกวิธีหนึ่งในการสร้างฟังก์ชันที่เรียกว่า *นิพจน์ฟังก์ชัน* (Function Expression)

ซึ่งช่วยให้เราสามารถสร้างฟังก์ชันใหม่ได้ในทุกๆ นิพจน์ (expression)

ตัวอย่างเช่น:

```js
let sayHi = function() {
  alert( "Hello" );
};
```

ในที่นี้เราเห็นตัวแปร `sayHi` ได้รับค่าเป็นฟังก์ชันใหม่ที่สร้างขึ้นด้วย `function() { alert("Hello"); }`

เนื่องจากการสร้างฟังก์ชันเกิดขึ้นในบริบทของนิพจน์การกำหนดค่า (ทางขวาของเครื่องหมาย `=`) จึงเป็นนิพจน์ฟังก์ชัน

โปรดสังเกตว่าไม่มีชื่อหลังคำสำคัญ `function` การละเว้นชื่อนั้นอนุญาตสำหรับนิพจน์ฟังก์ชัน

ในที่นี้เรากำหนดค่าให้กับตัวแปรทันที ดังนั้นความหมายของตัวอย่างโค้ดเหล่านี้จึงเหมือนกันคือ "สร้างฟังก์ชันและเก็บลงในตัวแปร `sayHi`"

ในสถานการณ์ที่ซับซ้อนขึ้นซึ่งเราจะเจอในภายหลัง ฟังก์ชันอาจถูกสร้างขึ้นและเรียกใช้ทันที หรือกำหนดเวลาเพื่อใช้ในภายหลัง โดยไม่เก็บไว้ที่ใดเลย จึงไม่มีชื่อ (anonymous)

## ฟังก์ชันคือค่า

ขอย้ำอีกครั้ง: ไม่ว่าฟังก์ชันจะถูกสร้างมาอย่างไร มันคือค่าชนิดหนึ่ง ตัวอย่างทั้งสองด้านบนเก็บฟังก์ชันไว้ในตัวแปร `sayHi`

เราสามารถแสดงค่านั้นผ่าน `alert` ได้ด้วย:

```js run
function sayHi() {
  alert( "Hello" );
}

*!*
alert( sayHi ); // แสดงโค้ดฟังก์ชัน
*/!*
```

โปรดสังเกตว่าบรรทัดสุดท้ายไม่ได้เรียกใช้ฟังก์ชัน เพราะไม่มีวงเล็บหลัง `sayHi` มีภาษาโปรแกรมบางภาษาที่เมื่อพูดถึงชื่อฟังก์ชันจะทำให้เกิดการเรียกใช้ทันที แต่ JavaScript ไม่เป็นเช่นนั้น

ใน JavaScript ฟังก์ชันเป็นค่าประเภทหนึ่ง เราจึงสามารถจัดการกับมันเหมือนกับค่าประเภทอื่นๆ โค้ดด้านบนแสดงการแปลงเป็นสตริง ซึ่งก็คือซอร์สโค้ดนั่นเอง

แน่นอนว่าฟังก์ชันเป็นค่าพิเศษ ตรงที่เราสามารถเรียกใช้มันได้ เช่น `sayHi()`

แต่มันก็ยังคงเป็นค่าอยู่ เราจึงทำงานกับมันได้เหมือนกับค่าประเภทอื่นๆ

เราสามารถคัดลอกฟังก์ชันไปยังตัวแปรอื่นได้:

```js run no-beautify
function sayHi() {   // (1) สร้าง
  alert( "Hello" );
}

let func = sayHi;    // (2) คัดลอก

func(); // Hello     // (3) เรียกใช้สำเนา (ใช้ได้)!
sayHi(); // Hello    //     ตัวต้นฉบับยังใช้ได้เหมือนเดิม (แน่นอน)
```

นี่คือสิ่งที่เกิดขึ้นในรายละเอียด:

1. การประกาศฟังก์ชัน `(1)` สร้างฟังก์ชันและเก็บไว้ในตัวแปรชื่อ `sayHi`
2. บรรทัด `(2)` คัดลอกมันไปยังตัวแปร `func` โปรดสังเกตอีกครั้ง: ไม่มีวงเล็บหลัง `sayHi` ถ้ามี `func = sayHi()` จะเขียน *ผลลัพธ์จากการเรียกใช้* `sayHi()` ลงใน `func` ไม่ใช่เขียน *ฟังก์ชัน* `sayHi` เอง
3. ตอนนี้ฟังก์ชันสามารถเรียกได้ทั้งในชื่อ `sayHi()` และ `func()`

เราสามารถใช้นิพจน์ฟังก์ชันเพื่อประกาศ `sayHi` ในบรรทัดแรกก็ได้:

```js
let sayHi = function() { // (1) สร้าง
  alert( "Hello" );
};

let func = sayHi;
// ...
```

ทุกอย่างจะทำงานเหมือนเดิม

```smart header="ทำไมต้องมีเครื่องหมายอัฒภาคตามหลัง?"
คุณอาจสงสัยว่าทำไมนิพจน์ฟังก์ชันถึงต้องมีเครื่องหมายอัฒภาค `;` ท้ายประโยค แต่การประกาศฟังก์ชันไม่ต้องมี:

```js
function sayHi() {
  // ...
}

let sayHi = function() {
  // ...
}*!*;*/!*
```

คำตอบคือ: นิพจน์ฟังก์ชันถูกสร้างขึ้นในรูปแบบ `function(…) {…}` ภายในประโยคการกำหนดค่า: `let sayHi = …;` ควรมีเครื่องหมายอัฒภาค `;` ท้ายประโยค มันไม่ใช่ส่วนหนึ่งของไวยากรณ์ฟังก์ชัน

เครื่องหมายอัฒภาคจะอยู่ในการกำหนดค่าทั่วไป เช่น `let sayHi = 5;` และอยู่ในการกำหนดค่าฟังก์ชันเช่นกัน

## ฟังก์ชันคอลแบ็ก

มาดูตัวอย่างเพิ่มเติมเกี่ยวกับการส่งฟังก์ชันเป็นค่า และการใช้นิพจน์ฟังก์ชันกัน

เราจะเขียนฟังก์ชัน `ask(question, yes, no)` ที่มีสามพารามิเตอร์:

`question`
: ข้อความของคำถาม

`yes`
: ฟังก์ชันที่จะรันหากคำตอบคือ "ใช่"

`no`
: ฟังก์ชันที่จะรันหากคำตอบคือ "ไม่"

ฟังก์ชันควรถาม `question` และเรียกใช้ `yes()` หรือ `no()` ตามคำตอบของผู้ใช้:

```js run
*!*
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}
*/!*

function showOk() {
  alert( "You agreed." );
}

function showCancel() {
  alert( "You canceled the execution." );
}

// การใช้งาน: ส่งฟังก์ชัน showOk, showCancel เป็นอาร์กิวเมนต์ให้ ask
ask("Do you agree?", showOk, showCancel);
```

ในทางปฏิบัติ ฟังก์ชันเหล่านี้มีประโยชน์มาก ความแตกต่างหลักระหว่าง `ask` ในชีวิตจริงกับตัวอย่างข้างต้นคือ ฟังก์ชันในชีวิตจริงใช้วิธีที่ซับซ้อนกว่าในการโต้ตอบกับผู้ใช้ นอกเหนือจากการใช้ `confirm` ธรรมดา ในเบราว์เซอร์ ฟังก์ชันเหล่านี้มักสร้างหน้าต่างคำถามที่สวยงาม แต่นั่นเป็นอีกเรื่องหนึ่ง

**อาร์กิวเมนต์ `showOk` และ `showCancel` ของ `ask` เรียกว่า *ฟังก์ชันคอลแบ็ก* หรือ *คอลแบ็ก***

แนวคิดคือ เราส่งฟังก์ชันไป และคาดหวังว่ามันจะถูก "เรียกกลับ (called back)" ในภายหลังหากจำเป็น ในกรณีของเรา `showOk` เป็นคอลแบ็กสำหรับคำตอบ "ใช่" และ `showCancel` สำหรับคำตอบ "ไม่"

เราสามารถใช้นิพจน์ฟังก์ชันเพื่อเขียนฟังก์ชันเทียบเท่าที่สั้นกว่าได้:

```js run no-beautify
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

*!*
ask(
  "Do you agree?",
  function() { alert("You agreed."); },
  function() { alert("You canceled the execution."); }
);
*/!*
```

ในที่นี้ ฟังก์ชันถูกประกาศขึ้นภายในการเรียก `ask(...)` โดยตรง โดยไม่มีการระบุชื่อ จึงเรียกว่า *anonymous (ไม่มีชื่อ)* ฟังก์ชันเหล่านี้ไม่สามารถเข้าถึงได้จากภายนอกของ `ask` (เพราะไม่ได้กำหนดให้กับตัวแปร) แต่นั่นแหละคือสิ่งที่เราต้องการในที่นี้

โค้ดลักษณะนี้ปรากฏในสคริปต์ของเราได้อย่างเป็นธรรมชาติ มันเป็นไปตามหลักการของภาษา JavaScript

```smart header="ฟังก์ชันคือค่าที่แทนการ \"กระทำ\""   
ค่าปกติ เช่น สตริงหรือตัวเลข แสดงถึง *ข้อมูล*

สามารถมองฟังก์ชันเป็น *การกระทำ* ได้

เราสามารถส่งผ่านมันไประหว่างตัวแปร และสั่งให้ทำงานเมื่อใดก็ได้ที่ต้องการ
```

## Function Expression กับ Function Declaration

มาสรุปความแตกต่างสำคัญระหว่าง Function Declaration และ Function Expression กัน

ประการแรก ในแง่วากยสัมพันธ์: วิธีแยกแยะทั้งสองแบบในโค้ด

- *Function Declaration:* ฟังก์ชันที่ประกาศเป็นประโยคแยกต่างหาก ในเนื้อหาหลักของโค้ด:

    ```js
    // Function Declaration
    function sum(a, b) {
      return a + b;
    }
    ```
- *Function Expression:* ฟังก์ชันที่ถูกสร้างภายในนิพจน์ หรือภายในโครงสร้างไวยากรณ์อื่นๆ ในที่นี้ ฟังก์ชันถูกสร้างขึ้นทางด้านขวาของ "นิพจน์การกำหนดค่า" `=`:

    ```js
    // Function Expression
    let sum = function(a, b) {
      return a + b;
    };
    ```

ความแตกต่างที่ละเอียดอ่อนกว่าคือ เวลาที่ฟังก์ชันถูกสร้างโดยเอนจินของ JavaScript *เมื่อใด*

**Function Expression ถูกสร้างเมื่อการประมวลผลมาถึงมัน และใช้งานได้ตั้งแต่จุดนั้นเป็นต้นไป**

เมื่อโฟลว์การประมวลผลผ่านไปถึงทางด้านขวาของการกำหนดค่า `let sum = function…` -- ฟังก์ชันก็จะถูกสร้างขึ้น และสามารถใช้งานได้ตั้งแต่ตอนนี้เป็นต้นไป (กำหนดค่า เรียกใช้ ฯลฯ) 

Function Declaration นั้นแตกต่างออกไป

**Function Declaration สามารถเรียกใช้ได้ก่อนที่จะมีการประกาศ**

ยกตัวอย่างเช่น Function Declaration ระดับโกลบอลจะมองเห็นได้ทั่วทั้งสคริปต์ ไม่ว่าจะอยู่ตรงไหน

นั่นเป็นเพราะอัลกอริทึมภายใน เมื่อ JavaScript เตรียมตัวที่จะรันสคริปต์ มันจะมองหา Function Declaration ระดับโกลบอลก่อนเป็นอันดับแรก แล้วทำการสร้างฟังก์ชันเหล่านั้นขึ้น เราอาจมองเป็น "ขั้นตอนการเตรียมการ"

และหลังจากประมวลผล Function Declaration ทั้งหมดแล้ว จึงค่อยประมวลผลโค้ดตามปกติ ดังนั้นโค้ดจึงสามารถเข้าถึงฟังก์ชันเหล่านั้นได้

ตัวอย่างเช่น โค้ดนี้สามารถทำงานได้:

```js run refresh untrusted
*!*
sayHi("John"); // Hello, John
*/!*

function sayHi(name) {
  alert( `Hello, ${name}` );
}
```

Function Declaration `sayHi` ถูกสร้างขึ้นตอนที่ JavaScript กำลังเตรียมจะเริ่มสคริปต์ และมองเห็นได้ทั่วทั้งสคริปต์

...แต่ถ้าเป็น Function Expression ก็จะใช้งานไม่ได้:

```js run refresh untrusted
*!*
sayHi("John"); // error!
*/!*

let sayHi = function(name) {  // (*) ไม่มีเวทมนต์อีกต่อไป
  alert( `Hello, ${name}` );
};
```

Function Expression จะถูกสร้างก็ต่อเมื่อการประมวลผลมาถึงมัน ซึ่งจะเกิดขึ้นที่บรรทัด `(*)` เท่านั้น ช้าไปแล้ว

อีกคุณสมบัติพิเศษของ Function Declaration คือขอบเขตแบบบล็อก

**ในโหมดเข้มงวด เมื่อ Function Declaration อยู่ภายในบล็อกโค้ด มันจะมองเห็นได้ทั่วภายในบล็อกนั้น แต่มองไม่เห็นภายนอกบล็อก**

ยกตัวอย่าง สมมติเราต้องการประกาศฟังก์ชัน `welcome()` โดยขึ้นอยู่กับค่าตัวแปร `age` ที่ได้มาระหว่างรันไทม์ และเราวางแผนจะใช้มันในภายหลัง

หากใช้ Function Declaration มันจะไม่ทำงานตามที่ตั้งใจ:

```js run
let age = prompt("What is your age?", 18);

// ประกาศฟังก์ชันตามเงื่อนไข
if (age < 18) {

  function welcome() {
    alert("Hello!");
  }

} else {

  function welcome() {
    alert("Greetings!");
  }

}

// ...ใช้ในภายหลัง
*!*
welcome(); // Error: welcome is not defined
*/!*
```

เราจะทำอย่างไรเพื่อให้ `welcome` มองเห็นได้จากภายนอก `if`?

วิธีที่ถูกต้องคือการใช้ Function Expression และกำหนดค่า `welcome` ให้กับตัวแปรที่ประกาศไว้นอก `if` ซึ่งมีการมองเห็นที่เหมาะสม

โค้ดนี้ทำงานตามที่ตั้งใจไว้:

```js run
let age = prompt("What is your age?", 18);

let welcome;

if (age < 18) {

  welcome = function() {
    alert("Hello!");
  };

} else {

  welcome = function() {
    alert("Greetings!");
  };

}

*!*
welcome(); // ตอนนี้ใช้ได้แล้ว
*/!*
```

หรือเราสามารถทำให้มันเรียบง่ายขึ้นอีกโดยใช้ตัวดำเนินการเครื่องหมายคำถาม `?`:

```js run
let age = prompt("What is your age?", 18);

let welcome = (age < 18) ?
  function() { alert("Hello!"); } :
  function() { alert("Greetings!"); };

*!*
welcome(); // ตอนนี้ใช้ได้แล้ว
*/!*
```


```smart header="เมื่อไหร่ควรเลือกใช้ Function Declaration หรือ Function Expression?"
โดยหลักการทั่วไป เมื่อเราต้องการประกาศฟังก์ชัน สิ่งแรกที่ควรพิจารณาคือใช้ไวยากรณ์แบบ Function Declaration เพราะมันให้อิสระในการจัดวางโค้ดมากกว่า เนื่องจากเราสามารถเรียกใช้ฟังก์ชันเหล่านั้นได้ก่อนที่จะมีการประกาศ

นอกจากนี้ยังอ่านทำความเข้าใจง่ายกว่า เพราะมองหา `function f(…) {…}` ในโค้ดได้ง่ายกว่า `let f = function(…) {…};` Function Declaration นั้น "โดดเด่นมากกว่า"

...แต่ถ้า Function Declaration ไม่เหมาะสมกับเราด้วยเหตุผลบางประการ หรือเราต้องการประกาศแบบมีเงื่อนไข (เราเพิ่งเห็นตัวอย่างไป) ควรใช้ Function Expression แทน
```

## สรุป

- ฟังก์ชันคือค่า สามารถกำหนดค่า คัดลอก หรือประกาศไว้ที่ใดก็ได้ในโค้ด
- ถ้าฟังก์ชันถูกประกาศเป็นประโยคแยกต่างหากในลำดับการทำงานหลักของโค้ด เรียกว่า "Function Declaration"
- ถ้าฟังก์ชันถูกสร้างขึ้นเป็นส่วนหนึ่งของนิพจน์ เรียกว่า "Function Expression"
- Function Declaration จะถูกประมวลผลก่อนที่บล็อกโค้ดจะเริ่มทำงาน ทำให้มองเห็นได้ทั่วทั้งบล็อก  
- Function Expression จะถูกสร้างขึ้นเมื่อลำดับการทำงานมาถึงจุดที่มันอยู่

ในเกือบทุกกรณีที่เราต้องการประกาศฟังก์ชัน Function Declaration เป็นตัวเลือกที่เหมาะสมกว่า เพราะมันมองเห็นได้ก่อนการประกาศจริงๆ ทำให้เรามีความยืดหยุ่นในการจัดวางโค้ดมากขึ้น และมักจะอ่านเข้าใจง่ายกว่า

ดังนั้นเราควรใช้ Function Expression เฉพาะเมื่อ Function Declaration ไม่เหมาะสมกับงาน เราได้เห็นตัวอย่างไปบ้างแล้วในบทนี้ และจะเห็นเพิ่มเติมในอนาคต