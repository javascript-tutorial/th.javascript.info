# นิพจน์ฟังก์ชั่น (Function expressions)

ในจาวาสคริปต์ ฟังก์ชันไม่ใช่เมจิกทางภาษา แต่เป็นค่าชนิดพิเศษ

ไวยากรณ์ที่เราใช้ก่อนหน้านี้เรียกว่า *Function Declaration*:

```js
function sayHi() {
  alert( "Hello" );
}
```

มีอีกรูปแบบหนึ่งสำหรับการสร้างฟังก์ชันที่เรียกว่า *Function Expression*

มันอนุญาตให้สร้างฟังก์ชันใหม่ที่อยู่ตรงกลางของนิพจน์

ตัวอย่างเช่น:

```js
let sayHi = function() {
  alert( "Hello" );
};
```

จากด้านบนเราจะเห็นตัวแปร `sayHi` รับค่า ที่เป็นฟังก์ชั่นใหม่เป็น `function() { alert("Hello"); }`

เนื่องจากการสร้างฟังก์ชันเกิดขึ้นในบริบทของการกำหนดแบบใช้นิพจน์ (ทางด้านขวาของ `=`) เราเรียกสิ่งนี้ว่า *นิพจน์ฟังก์ชัน (Function Expression)*

โปรดทราบว่า *นิพจน์ฟังก์ชัน (Function Expression)* จะไม่มีชื่อฟังก์ชั่นอยู่ด้านหลังคีย์เวิร์ด `function`

เรากำหนดฟังก์ชั่นให้กับตัวแปรทันที ความหมายจากโค้ดด้านบนก็คือ "สร้างฟังก์ชั่นและใส่ลงในตัวแปร `sayHi`"

เราสามารถประยุกต์ใช้ *นิพจน์ฟังก์ชัน (Function Expression)* กับสถานการณ์อย่าง ฟังก์ชั่นเรียกตามกำหนดเวลา หรือ เรียกหลังจากทำงานอย่างหนึ่งเสร็จ แค่ตอนนี้เราจะละไว้ในหัวข้ออื่นๆภายหลัง

## ฟังก์ชั่นคือค่า

ขอย้ำอีกครั้งว่า ไม่ว่าฟังก์ชั่นจะถูกสร้างขึ้นอย่างไร ฟังก์ชันก็คือค่า ทั้งสองตัวอย่างด้านบนเก็บฟังก์ชันไว้เป็นตัวแปร `sayHi`

เราสามารถแสดงค่านั้นออกมาได้โดยใช้ `alert`:

```js run
function sayHi() {
  alert( "Hello" );
}

*!*
alert( sayHi ); // แสดงโค้ดฟังก์ชัน
*/!*
```

บรรทัดสุดท้ายจะไม่ทำงาน เนื่องจากไม่มีวงเล็บเปิด-ปิดหลัง `sayHi` เพื่อเรียกฟังก์ชั่นนี้ทำงาน มีภาษาโปรแกรมมิ่งบางภาษาที่สามารถให้ฟังก์ชั่นทำงานได้เพียงระบุชื่อฟังก์ชั่นโดยไม่ต้องใส่วงเล็บเปิด-ปิด แต่สำหรับจาวาสคริปต์ไม่ได้เป็นแบบนั้น

ในจาวาสคริปต์ฟังก์ชันคือค่าค่าหรึ่ง ดังนั้นเราสามารถจัดการกับมันเป็นค่าได้ โค้ดของฟังก์ชั่นทั้งหมดจะถูกแสดงออกมาด้วยค่าสตริง

แน่นอนว่า ฟังก์ชันเป็นค่าพิเศษ นั่นคือเราสามารถสั่งให้มันทำงานได้โดยการเติมวงเล็บ `sayHi()`

แต่มันก็ยังคงเป็นค่าอยู่ ดังนั้นเราจึงสามารถทำงานกับมันได้เหมือนกับค่าอื่นๆ

เราสามารถคัดลอกฟังก์ชันไปยังตัวแปรอื่นได้:

```js run no-beautify
function sayHi() {   // (1) สร้างฟังก์ชั่น
  alert( "Hello" );
}

let func = sayHi;    // (2) คัดลอกฟังก์ชั่น

func(); // Hello     // (3) สั่งตัวก็อปปี้ทำงาน (ทำงานได้)
sayHi(); // Hello    //     สั่งตัวดั้งเดิมทำงาน (ทำงานได้เช่นกัน)
```

นี่คือสิ่งที่เกิดขึ้นจากโค้ดข้างบนโดยละเอียด:

1. การประกาศฟังก์ชั่น (Function Declaration) `(1)` สร้างฟังก์ชันและใส่ลงในตัวแปรชื่อ `sayHi`
2. บรรทัด `(2)` คัดลอกลงในตัวแปร `func` อย่าลืมว่า: ไม่มีวงเล็บหลังหลังฟังก์ชั่น `sayHi` หากมีวงเล็บแบบนี้ `func = sayHi()` ผลลัพธ์ที่คืนกลับมาจาก `sayHi()` จะเก็บไว้ในตัวแปร `func` ไม่ใช่ตัวฟังก์ชั่น `sayHi` เอง
3. ตอนนี้ฟังก์ชันนี้สามารถเรียกได้ทั้ง `sayHi()` และ `func()`

นอกจากนี้เรายังสามารถใช้นิพจน์ฟังก์ชั่น (Function Expression) เพื่อประกาศ `sayHi` ในบรรทัดแรกได้:

```js
let sayHi = function() { // (1) create
  alert( "Hello" );
};

let func = sayHi;
// ...
```

ทุกอย่างจะทำงานเหมือนกัน


````smart header="ทำไมมี semicolon ต่อท้าย?"
อาจสงสัยว่าทำไม นิพจน์ฟังก์ชั่น (Function Expression) ถึงมีเครื่องหมายอัฒภาค `;` ต่อท้าย แต่ Function Declaration ไม่มี:

```js
function sayHi() {
  // ...
}

let sayHi = function() {
  // ...
}*!*;*/!*
```

คำตอบนั้นง่าย: นิพจน์ฟังก์ชั่น (Function Expression) ถูกสร้างขึ้นที่นี่เป็น `function(…) {…}` ด้วยคำสั่งการกำหนดค่า (assignment): `let sayHi = …;` การใช้ `;` ที่ส่วนท้ายของคำสั่ง เป็นการจบประโยคคำสั่งการกำหนดค่า

อาทิ `let sayHi = 5;` เราก็จบประโยตด้วย `;` ซึ่งแน่นอนว่ากับนิพจน์ฟังก์ชั่น (Function Expression) ด้วย
````

## ฟังก์ชันไว้เรียกทีหลัง (Callback functions)

มาดูตัวอย่างเพิ่มเติมของการส่งฟังก์ชันเป็นค่าและการใช้นิพจน์ฟังก์ชั่น (function expressions)

เราจะลองมาเขียนฟังก์ชั่น `ask(question, yes, no)` ด้วยพารามิเตอร์สามตัว:

`question`
: ข้อความถาม

`yes`
: ฟังก์ชั่นที่ทำงานหากคำตอบคือ "Yes"

`no`
: ฟังก์ชั่นที่ทำงานหากคำตอบคือ "No"

ฟังก์ชั่นควรถาม `question` จากนั้นให้กำหนดเงื่อนไขเพื่อเรียกใช้ฟังก์ชั่น `yes()` หรือ `no()` ตามคำตอบของผู้ใช้:

```js run
*!*
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}
*/!*

function showOk() {
  alert( "You agreed." );
}

function showCancel() {
  alert( "You canceled the execution." );
}

// การใช้งาน: ฟังก์ชั่น showOk, showCancel ถูกส่งผ่านเป็นอาร์กิวเมนต์เพื่อใช้ถาม
ask("Do you agree?", showOk, showCancel);
```

ในทางปฏิบัติ ฟังก์ชั่นดังกล่าวมีประโยชน์มาก ความแตกต่างที่สำคัญระหว่าง "การถาม" ในชีวิตจริงกับตัวอย่างข้างต้นคือฟังก์ชันในชีวิตจริงใช้วิธีที่ซับซ้อนกว่าในการโต้ตอบกับผู้ใช้มากกว่า `confirm` ในเบราว์เซอร์ธรรมดาๆ ฟังก์ชันดังกล่าวมักจะสร้างหน้าต่างคำถามที่ดูดีกว่า

**อาร์กิวเมนต์ `showOk` และ `showCancel` ของฟังก์ชั่น `ask` เรียกว่า *ฟังก์ชันไว้เรียกทีหลัง (Callback functions)* หรือบางทีเราก็เรียกสั้นๆแค่ *Callback***

แนวคิดคือเราส่งฟังก์ชันและคาดว่าจะ "เอาไว้เรียกทีหลัง" หากจำเป็น ในกรณีของเรา `showOk` ก็คือฟังก์ชั่น Callback สำหรับคำตอบ "yes" และ `showCancel` สำหรับคำตอบ "no"
เราสามารถgเขียนเป็น Function Expressions เพื่อให้ฟังก์ชั่นส้ันลงได้ดังนี้:

```js run no-beautify
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

*!*
ask(
  "Do you agree?",
  function() { alert("You agreed."); },
  function() { alert("You canceled the execution."); }
);
*/!*
```

ในที่นี้ ฟังก์ชั่นต่างๆ จะถูกประกาศไว้ภายใน `ask(...)` ฟังก์ชั่นเหล่านี้ไม่มีชื่อ เราจึงเรียกว่าฟังก์ชั่นเหล่านี้ว่า *anonymous* ฟังก์ชันดังกล่าวไม่สามารถเข้าถึงได้จากภายนอกฟังก์ชั่น 'ask' (เพราะไม่ได้กำหนดเข้าตัวแปร)

โค้ดดังกล่าวที่ปรากฏในสคริปต์เป็นเรื่องปกติสำหรับจาวาสคริปต์

```smart header="ฟังก์ชั่นคือค่าที่เป็นตัวแทนของ \"การกระทำ\""
ค่าปกติเช่นสตริงหรือตัวเลขเป็นตัวแทนของ *ข้อมูล*

ฟังก์ชั่นจะถูกรับรู้ว่าคือ *การกระทำ* เสมอ

เราสามารถส่งต่อฟังก์ชั่นระหว่างตัวแปรและเรียกใช้ฟังก์ชั่นนั้นผ่านตัวแปรเมื่อเราต้องการได้
```


## Function Expression vs Function Declaration

มาดูความแตกต่างระหว่างการประกาศฟังก์ชั่น (Function Declaration) และ นิพจน์ฟังก์ชั่น (Function Expression)

อันดับแรก ไวยากรณ์: วิธีแยกความแตกต่างระหว่างทั้งสองในโค้ด

- *การประกาศฟังก์ชั่น:* ฟังก์ชันที่ประกาศเป็นคำสั่งแยกต่างหากในโฟลว์โค้ดหลัก

    ```js
    // Function Declaration
    function sum(a, b) {
      return a + b;
    }
    ```
- *นิพจน์ฟังก์ชั่น:* ฟังก์ชันที่สร้างขึ้นภายในนิพจน์หรือภายในโครงสร้างไวยากรณ์อื่น ในทีนี้เราเขียนฟังก์ชั่นด้านขวาของ "assignment expression" `=`

    ```js
    // Function Expression
    let sum = function(a, b) {
      return a + b;
    };
    ```

ความซับซ้อนจะยิ่งมากขึ้น *เมื่อ* JavaScript engine มาเกี่ยวข้องด้วย

**นิพจน์ฟังก์ชั่นจะถูกสร้างขึ้นเมื่อการดำเนินการมาถึง และสามารถใช้ได้ในช่วงเวลานั้นเท่านั้น**

นั่นก็คือนิพจน์ฟังก์ชั่นจะทำงานตามโฟลว์การทำงานของโปรแกรม ซึ่งจะเหมือนกับการอ่านหนังสือของคนเรา นั่นคือจากซ้ายไปขวาและบนลงล่าง `let sum = function…` นั่นหมายถึงนิพจน์ฟังก์ชั่นสามารถใช้งานได้จากบรรทัดที่เพิ่งถูกกำหนดลงมาเท่านั้น

ส่วนการประกาศฟังก์ชัน (Function Declarations) จะต่างออกไป

**การประกาศฟังก์ชันสามารถเรียกได้เร็วกว่าที่กำหนดไว้**

นั่นก็คือการประกาศฟังก์ชัน (Function Declarations) เป็น global scope ไม่ว่าเราจะประกาศฟังก์ชั่นส่วนไหนของสคริปต์ เราก็สามารถเรียกใช้ฟังก์ชั่นนั่นได้

นั่นเป็นเพราะอัลกอริธึมของ JavaScript engine เมื่อจาวาสคริปต์เตรียมที่จะรันสคริปต์ อันดับแรกมันจะค้นหา Global Function Declarations ในสคริปต์นั้นๆ และสร้างฟังก์ชันขึ้นมาก่อน เราเรียกขั้นตอนนี้ว่า "initialization stage"

และหลังจากประมวลผลบรรดาการประกาศฟังก์ชันทั้งหมด (Function Declarations) แล้ว โค้ดก็จะถูกดำเนินการ จึงมีการเข้าถึงฟังก์ชั่นเหล่านี้

ตัวอย่างเช่น:

```js run refresh untrusted
*!*
sayHi("John"); // Hello, John
*/!*

function sayHi(name) {
  alert( `Hello, ${name}` );
}
```

การประกาศฟังก์ชัน `sayHi` ถูกสร้างขึ้นเมื่อ JavaScript กำลังเตรียมที่จะเริ่มสคริปต์ ดังนั้นทุกส่วนในสคริปต์จึงเห็นฟังก์ชั่น `sayHi`

...หากเป็น Function Expression มันก็จะใช้งานไม่ได้:

```js run refresh untrusted
*!*
sayHi("John"); // error!
*/!*

let sayHi = function(name) {  // (*) no magic any more
  alert( `Hello, ${name}` );
};
```

นิพจน์ฟังก์ชันจะถูกสร้างขึ้นเมื่อการดำเนินการมาถึง ที่จะเกิดขึ้นเฉพาะในบรรทัด `(*)` ดังนั้นหากเราจะเรียกใช้ ควรเรียกในบรรทัดถัดไป

คุณสมบัติพิเศษอีกอย่างของการประกาศฟังก์ชัน (Function Declarations) คือขอบเขตบล็อก

**ใน strict mode, เมื่อการประกาศฟังก์ชันอยู่ในบล็อกโค้ด โค้ดที่อยู่ในบล็อคนั้นจะสามารถใช้งานฟังก์ชั่นประกาศแบบนี้ได้หมด แต่ไม่สามารถใช้งานได้จากภายนอกบล็อค**

ตัวอย่างเช่น สมมติว่าเราจำเป็นต้องประกาศฟังก์ชัน `welcome()` ขึ้นอยู่กับตัวแปร `age` ที่เราได้รับระหว่างรันไทม์ แล้วเราวางแผนที่จะใช้มันในภายหลัง

ถ้าเราใช้การประกาศฟังก์ชัน (Function Declaration) ก็จะไม่ทำงานตามที่ตั้งใจไว้:

```js run
let age = prompt("What is your age?", 18);

// ประกาศฟังก์ชันแบบมีเงื่อนไข
if (age < 18) {

  function welcome() {
    alert("Hello!");
  }

} else {

  function welcome() {
    alert("Greetings!");
  }

}

// ...ใช้ทีหลัง
*!*
welcome(); // Error: welcome is not defined
*/!*
```

นั่นเป็นเพราะการประกาศฟังก์ชันจะใช้งานได้เฉพาะในบล็อคโค้ดที่มันอยู่เท่านั้น

นี่เป็นอีกตัวอย่างหนึ่ง:

```js run
let age = 16; // ใช้ 16 เป็นตัวอย่าง

if (age < 18) {
*!*
  welcome();               // \   (runs)
*/!*
                           //  |
  function welcome() {     //  |
    alert("Hello!");       //  |  มีการประกาศฟังก์ชั่น (Function Declaration)
  }                        //  |
                           //  |
*!*
  welcome();               // /   (runs)
*/!*

} else {

  function welcome() {    
    alert("Greetings!");
  }
}

// ตั้งแต่บรรทัดนี้คือภายนอกโค้ดบล็อคที่ประกาศฟังก์ชั่น welcome เอาไว้
// ดังนั้นเราจึงไม่สามารถใช้ฟังก์ชั่นที่ประกาศภายในบล็อคโค้ดได้

*!*
welcome(); // Error: welcome is not defined
*/!*
```

เราจะทำอย่างไรเพื่อให้เราใช้งานฟังก์ชั่น `welcone` ได้จากภายนอก `if`

วิธีที่ถูกต้องคือการใช้ Function Expression คือประกาศตัวแปร `welcome` ภายนอก แล้วกำหนดฟังก์ชั่นให้ `welcome` ใน `if` อีกที

โค้ดจะทำงานได้ตามที่ตั้งใจไว้:

```js run
let age = prompt("What is your age?", 18);

let welcome;

if (age < 18) {

  welcome = function() {
    alert("Hello!");
  };

} else {

  welcome = function() {
    alert("Greetings!");
  };

}

*!*
welcome(); // ตอนนี้ใช้งานได้แล้ว
*/!*
```

หรือเราอาจทำให้มันง่ายขึ้นโดยใช้ตัวดำเนินการเครื่องหมายคำถาม `?`:

```js run
let age = prompt("What is your age?", 18);

let welcome = (age < 18) ?
  function() { alert("Hello!"); } :
  function() { alert("Greetings!"); };

*!*
welcome(); // ตอนนี้ใช้งานได้แล้ว
*/!*
```


```smart header="เมื่อใดควรเลือก การประกาศฟังก์ชั่น (Function Declaration) หรือ นิพจน์ฟังก์ชั่น (Function Expression) ดี?"
ตามกฎทั่วไป เมื่อเราต้องการประกาศฟังก์ชัน สิ่งแรกที่ต้องพิจารณาคือ ใช้การประกาศฟังก์ชั่น (Function Declaration) มันให้อิสระมากขึ้นในการจัดระเบียบโค้ด เพราะเราสามารถเรียกใช้ฟังก์ชั่นเหล่านี้ได้ทุกเมื่อ

แล้วการประกาศใช้ฟังก์ชั่นยังดีกว่าในแง่ความอ่านง่ายอีกด้วย เนื่องจากการค้นหา `function f(…) {…}` ในโค้ดง่ายกว่า `let f = function(…) {…};` การประกาศฟังก์ชันมีความ "สะดุดตา" มากกว่า

แต่ถ้าการประกาศฟังก์ชันไม่เหมาะกับเราด้วยเหตุผลบางอย่าง เช่นเราต้องการการประกาศแบบมีเงื่อนไข (เราเพิ่งเห็นตัวอย่างไปเมื่อกี้) ก็ควรใช้นิพจน์ฟังก์ชันแทน
```

## สรุป

- ฟังก์ชันคือค่าที่สามารถกำหนด คัดลอก หรือประกาศในตำแหน่งใดก็ได้ในโค้ด
- หากฟังก์ชันถูกประกาศเป็นคำสั่งแยกต่างหากในโฟลว์โค้ดหลัก ฟังก์ชันนั้นเรียกว่า การประกาศฟังก์ชัน (Function Declaration)
- ถ้าฟังก์ชันถูกสร้างขึ้นเป็นส่วนหนึ่งของนิพจน์ จะเรียกว่า นิพจน์ฟังก์ชั่น (Function Expression)
- การประกาศฟังก์ชันจะได้รับการประมวลผลก่อน การทำงานหลักของโปรแกรม ดังนั้นโต้ดทุกส่วนในสคริปต์จึงสามารถใช้งานฟังก์ชั่นเหล่านี้ได้
- นิพจน์ของฟังก์ชันจะถูกสร้างขึ้นเมื่อโฟลว์การดำเนินการไปถึง

ในกรณีส่วนใหญ่เมื่อเราต้องการประกาศฟังก์ชัน การประกาศฟังก์ชันนั้นเหมาะสมกว่า เนื่องจากจะโต้ดทุกส่วนจะใช้งานฟังก์ชั่นนั้นได้ก่อนการประกาศ นั่นทำให้เรามีความยืดหยุ่นมากขึ้นในการจัดระเบียบโค้ดและอ่านง่ายขึ้น
ดังนั้น เราควรใช้ นิพจน์ฟังก์ชั่น (Function Expression) เฉพาะเมื่อ การประกาศฟังก์ชัน (Function Declaration) ไม่เหมาะกับงานเท่านั้น เราได้เห็นสองสามตัวอย่างแล้วในบทนี้ และจะเห็นเพิ่มเติมในอนาคต
