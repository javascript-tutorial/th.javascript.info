# Function Expression

ในภาษา JavaScript ฟังก์ชันไม่ใช่แค่ "โครงสร้างภาษาที่พิเศษ" แต่ยังเป็นชนิดข้อมูลพิเศษอีกด้วย

ไวยากรณ์ที่เราเคยใช้มาก่อนหน้านี้เรียกว่า _Function Declaration_:

```js
function sayHi() {
  alert("สวัสดี");
}
```

นอกจากนี้ยังมีอีกรูปแบบหนึ่งในการสร้างฟังก์ชัน นั่นคือ _Function Expression_

Function Expression ช่วยให้เราสามารถสร้างฟังก์ชันใหม่ได้ระหว่างนิพจน์ (expression) ใดๆ

ตัวอย่างเช่น:

```js
let sayHi = function() {
  alert("สวัสดี");
};
```

ในที่นี้ เราจะเห็นว่าตัวแปร `sayHi` ได้รับการกำหนดค่าให้เป็นฟังก์ชันใหม่ ซึ่งถูกสร้างขึ้นมาเป็น `function() { alert("สวัสดี"); }`

เนื่องจากการสร้างฟังก์ชันนี้เกิดขึ้นในบริบทของนิพจน์กำหนดค่า (ทางขวาของเครื่องหมาย `=`) จึงเรียกว่าเป็น _Function Expression_

สังเกตได้ว่า ไม่มีการระบุชื่อต่อท้ายคีย์เวิร์ด `function` ซึ่งการละชื่อนี้สามารถทำได้กับ Function Expression

ในตัวอย่างนี้ เรากำหนดค่าให้กับตัวแปรทันที นั่นหมายความว่า "สร้างฟังก์ชันขึ้นมาแล้วกำหนดลงในตัวแปร `sayHi`"

ในสถานการณ์ที่ซับซ้อนกว่าซึ่งจะได้เจอในภายหลัง ฟังก์ชันอาจจะถูกสร้างและเรียกใช้งานทันที หรือถูกกำหนดเวลาให้รันภายหลัง โดยไม่จำเป็นต้องเก็บไว้ในตัวแปร ดังนั้นจึงมักจะไม่ระบุชื่อให้กับฟังก์ชันเหล่านี้

## ฟังก์ชันก็คือค่าชนิดหนึ่ง

ขอย้ำอีกครั้งว่า ไม่ว่าจะสร้างฟังก์ชันด้วยวิธีใด มันก็ยังคงเป็นค่า (value) อยู่วันยังค่ำ ในทั้งสองตัวอย่างข้างต้น เราเก็บฟังก์ชันไว้ในตัวแปร `sayHi`

เราสามารถแสดงค่าของฟังก์ชันออกมาด้วยคำสั่ง `alert` ได้เลย:

```js run
function sayHi() {
  alert("สวัสดี");
}

*!*
alert(sayHi); // แสดงโค้ดฟังก์ชัน
*/!*
```

สังเกตว่าบรรทัดสุดท้ายไม่ได้เรียกใช้ฟังก์ชัน เพราะไม่มีวงเล็บ `()` ต่อท้ายชื่อฟังก์ชัน `sayHi` ในบางภาษา การอ้างถึงชื่อฟังก์ชันอย่างเดียวจะเท่ากับการเรียกใช้มัน แต่ในจาวาสคริปต์ไม่เป็นเช่นนั้น

ในจาวาสคริปต์ ฟังก์ชันถือเป็นค่าประเภทหนึ่ง เราจึงสามารถจัดการมันได้เหมือนกับค่าชนิดอื่นๆ ในโค้ดด้านบน เราแปลงค่าของฟังก์ชันเป็นสตริง ซึ่งก็คือโค้ดต้นฉบับของฟังก์ชันนั่นเอง

แน่นอนว่าฟังก์ชันเป็นค่าที่พิเศษกว่าค่าปกติทั่วไป ตรงที่เราสามารถเรียกใช้งานมันได้ เช่น `sayHi()`

แต่ถึงอย่างนั้น มันก็ยังคงความเป็นค่าชนิดหนึ่งอยู่ เราจึงสามารถจัดการมันได้เหมือนกับค่าประเภทอื่นๆ

เราสามารถคัดลอกฟังก์ชันไปใส่ในตัวแปรอื่นได้:

```js run no-beautify
function sayHi() { // (1) สร้าง
  alert("สวัสดี");
}

let func = sayHi; // (2) คัดลอก 

func(); // สวัสดี     // (3) เรียกใช้ฟังก์ชันที่คัดลอกมา (ทำงานได้)!

sayHi(); // สวัสดี    // เรียกใช้ฟังก์ชันต้นฉบับก็ยังทำได้
```

มาดูว่าเกิดอะไรขึ้นในรายละเอียด:

1. Function Declaration `(1)` สร้างฟังก์ชันและเก็บไว้ในตัวแปร `sayHi`

2. บรรทัด `(2)` คัดลอกฟังก์ชันไปไว้ในตัวแปร `func` สังเกตว่าไม่มีวงเล็บ `()` ต่อท้ายชื่อ `sayHi` เพราะถ้ามี จะกลายเป็นเขียน _ผลลัพธ์_ จากการเรียก `sayHi()` ไปเก็บใน `func` ไม่ใช่เขียน _ฟังก์ชัน_ `sayHi` เอง

3. ตอนนี้ฟังก์ชันก็ถูกเรียกได้ทั้งในชื่อ `sayHi()` และ `func()`

หรือเราอาจจะใช้ Function Expression ตั้งแต่ต้นก็ได้:

```js
let sayHi = function() { // (1) สร้าง
  alert("สวัสดี");  
};

let func = sayHi;
// ...
```

ทุกอย่างก็ยังทำงานได้เหมือนเดิม

```smart header="ทำไมถึงมีเครื่องหมายอัฒภาคต่อท้าย?"

คุณอาจสงสัยว่าทำไม Function Expression ถึงมีเครื่องหมายอัฒภาค `;` ต่อท้าย ส่วน Function Declaration ไม่มี:

```js
function sayHi() {
  // ...
}

let sayHi = function() {
  // ...
}*!*;*/!*
```

คำตอบคือ เพราะ Function Expression ถูกสร้างภายในคำสั่งกำหนดค่าเป็น `function(...) {...}`: `let sayHi = ...;` ซึ่งจริงๆ แล้วเครื่องหมายอัฒภาค `;` เป็นสิ่งที่แนะนำให้ใส่ต่อท้ายคำสั่ง แต่ไม่ได้เป็นส่วนหนึ่งของไวยากรณ์ฟังก์ชัน

ถ้าเป็นการกำหนดค่าแบบง่ายๆ เช่น `let sayHi = 5;` ก็ควรมีเครื่องหมายอัฒภาคอยู่ด้วย รวมถึงตอนกำหนดฟังก์ชันก็เช่นกัน
````

## ฟังก์ชันคอลแบ็ก

มาดูตัวอย่างเพิ่มเติมของการส่งฟังก์ชันเป็นค่าและการใช้ Function Expression กัน

เราจะลองเขียนฟังก์ชัน `ask(question, yes, no)` ที่รับพารามิเตอร์ 3 ตัว:

`question`
: ข้อความคำถาม

`yes`
: ฟังก์ชันที่จะทำงานเมื่อคำตอบคือ "ใช่"

`no`
: ฟังก์ชันที่จะทำงานเมื่อคำตอบคือ "ไม่"

ฟังก์ชันนี้จะถามคำถาม `question` และเรียกใช้ `yes()` หรือ `no()` ขึ้นอยู่กับคำตอบที่ได้รับจากผู้ใช้:

```js run
*!*
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}
*/!*

function showOk() {
  alert("คุณเห็นด้วย");
}

function showCancel() {
  alert("คุณยกเลิก");
}

// วิธีเรียกใช้: ส่งฟังก์ชัน showOk, showCancel เป็นอาร์กิวเมนต์ให้ ask
ask("คุณเห็นด้วยไหม?", showOk, showCancel);
```

ในทางปฏิบัติ ฟังก์ชันแบบนี้ใช้ประโยชน์ได้มาก ความต่างหลักระหว่างฟังก์ชัน `ask` ในโลกจริงกับตัวอย่างด้านบนคือ ในโลกจริงฟังก์ชันมักใช้การโต้ตอบกับผู้ใช้ที่ซับซ้อนกว่า `confirm` ธรรมดา โดยเฉพาะในเบราว์เซอร์ที่ฟังก์ชันพวกนี้มักจะแสดงหน้าต่างคำถามที่สวยงาม แต่เรื่องนั้นเป็นอีกประเด็นหนึ่ง

**อาร์กิวเมนต์ `showOk` และ `showCancel` ของฟังก์ชัน `ask` เรียกว่า *ฟังก์ชันคอลแบ็ก* หรือเรียกสั้นๆ ว่า *คอลแบ็ก***

ไอเดียหลักๆ คือเราส่งฟังก์ชันไปเป็นค่า แล้วหวังว่ามันจะถูก "เรียกกลับมา" ในภายหลังเมื่อจำเป็น ในกรณีนี้ `showOk` กลายเป็นคอลแบ็กสำหรับคำตอบ "ใช่" และ `showCancel` สำหรับคำตอบ "ไม่"

เราสามารถเขียนโค้ดให้สั้นลงด้วยการใช้ Function Expression:

```js run no-beautify
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

*!*
ask(
  "คุณเห็นด้วยไหม?",
  function() { alert("คุณเห็นด้วย"); },
  function() { alert("คุณยกเลิก"); }
);
*/!*
```

ตรงนี้ฟังก์ชันถูกประกาศไว้โดยตรงภายในการเรียกใช้ `ask(...)` โดยไม่มีการตั้งชื่อ เรียกว่าฟังก์ชันแบบ *ไม่ระบุชื่อ (anonymous)* ฟังก์ชันเหล่านี้จะเข้าถึงจากภายนอก `ask` ไม่ได้ (เพราะไม่ได้ผูกกับตัวแปรใด) แต่ในกรณีนี้เราก็ไม่ต้องการให้มันเข้าถึงได้อยู่แล้ว  

โค้ดในลักษณะนี้มักจะเห็นได้บ่อยๆ ในสคริปต์ของพวกเรา ถือเป็นไปตามสไตล์การเขียนแบบ JavaScript

```smart header="ฟังก์ชันคือค่าที่ใช้ในการแทน \"การกระทำ\""
โดยปกติแล้ว ค่าอย่างสตริงหรือตัวเลขจะใช้แทน *ข้อมูล*

ส่วนฟังก์ชันนั้น สามารถมองได้ว่าเป็น *การกระทำ*

เราสามารถส่งมันเป็นค่าไปมาในตัวแปร และเรียกใช้มันได้เมื่อไหร่ก็ได้ที่ต้องการ 
```