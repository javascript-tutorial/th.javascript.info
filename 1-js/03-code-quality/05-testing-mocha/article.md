# การทดสอบอัตโนมัติด้วย Mocha

ในงานต่อๆ ไปจะมีการใช้การทดสอบอัตโนมัติ ซึ่งเป็นสิ่งที่ใช้กันอย่างแพร่หลายในโปรเจ็กต์จริงด้วย

## ทำไมต้องมีการทดสอบ?

เวลาเขียนฟังก์ชัน เรามักจะจินตนาการได้ว่ามันควรจะทำงานอย่างไร พารามิเตอร์แบบไหนให้ผลลัพธ์แบบไหน

ระหว่างพัฒนา เราตรวจสอบฟังก์ชันได้โดยการรันและเปรียบเทียบผลลัพธ์กับสิ่งที่คาดหวังไว้ เช่น อาจทำในคอนโซล

ถ้ามีอะไรผิดพลาด ก็แก้โค้ด รันใหม่ เช็คผลลัพธ์ วนไปแบบนี้จนกว่าจะใช้ได้

แต่การ "รันซ้ำ" ด้วยมือแบบนั้นยังไม่สมบูรณ์แบบ

**เมื่อทดสอบโค้ดโดยการรันซ้ำเอง มักจะมีบางอย่างหลุดไปได้ง่าย**

ยกตัวอย่างเช่น สมมติเรากำลังเขียนฟังก์ชัน `f` เขียนโค้ดนิดหน่อย ลองทดสอบดู `f(1)` ใช้ได้ แต่ `f(2)` ไม่ทำงาน เราแก้โค้ดแล้วตอนนี้ `f(2)` ก็ใช้ได้แล้ว ดูเหมือนจะครบแล้วใช่ไหม แต่เราลืมย้อนกลับไปเทสต์ `f(1)` ใหม่ ซึ่งอาจจะมีข้อผิดพลาดโผล่ขึ้นมาก็ได้

นี่เป็นเรื่องปกติมาก ตอนที่เรากำลังพัฒนาอะไรบางอย่าง มักจะมีหลายกรณีการใช้งานที่เราต้องคำนึงถึง แต่การที่จะให้โปรแกรมเมอร์มานั่งเช็คทุกกรณีด้วยตัวเองทุกครั้งที่มีการเปลี่ยนแปลง เป็นเรื่องยาก เลยกลายเป็นว่าแก้ไขอย่างหนึ่ง แล้วไปทำให้อีกอย่างพังได้ง่าย

**การทดสอบอัตโนมัติหมายถึงการเขียนเทสต์แยกออกมาต่างหาก เป็นส่วนเสริมของโค้ด เทสต์เหล่านั้นจะรันฟังก์ชันของเราในหลากหลายวิธี และเปรียบเทียบผลลัพธ์กับสิ่งที่คาดหวัง**

## Behavior Driven Development (BDD)

เรามาเริ่มต้นด้วยเทคนิคที่เรียกว่า [Behavior Driven Development](http://en.wikipedia.org/wiki/Behavior-driven_development) หรือเรียกสั้นๆ ว่า BDD กัน

**BDD คือ 3 สิ่งในหนึ่งเดียว ทั้งเทสต์ เอกสาร และตัวอย่างการใช้งาน**

เพื่อทำความเข้าใจ BDD เราจะมาดูตัวอย่างกรณีศึกษาในการพัฒนาซอฟต์แวร์กัน

## การพัฒนา "pow": ข้อกำหนด

สมมติว่าเราอยากเขียนฟังก์ชัน `pow(x, n)` ที่คืนค่า `x` ยกกำลังด้วยเลขชี้กำลังจำนวนเต็ม `n` โดยเราสมมติว่า `n≥0`

จริงๆ แล้วนี่เป็นแค่ตัวอย่าง เพราะในจาวาสคริปต์มีตัวดำเนินการ `**` ที่ทำแบบนี้ได้อยู่แล้ว แต่ตรงนี้เราจะมุ่งเน้นไปที่วิธีการพัฒนาที่สามารถนำไปประยุกต์ใช้กับงานที่ซับซ้อนกว่านี้ได้ด้วย

ก่อนจะเขียนโค้ดของ `pow` เราสามารถจินตนาการถึงสิ่งที่ฟังก์ชันควรจะทำและบรรยายมันไว้ก่อนได้

คำบรรยายแบบนี้เรียกว่า *ข้อกำหนด (specification)* หรือเรียกสั้นๆ ว่า spec ซึ่งจะประกอบด้วยรายละเอียดกรณีการใช้งานต่างๆ ร่วมกับเทสต์สำหรับกรณีเหล่านั้น ดังนี้

```js
describe("pow", function() {

  it("ยกกำลัง n", function() {
    assert.equal(pow(2, 3), 8);
  });

});
```

spec มีองค์ประกอบหลัก 3 ส่วนตามที่เห็นข้างบน

`describe("ชื่อหัวข้อ", function() { ... })`
: เรากำลังอธิบายฟังก์ชันอะไร? ในกรณีนี้คือฟังก์ชัน `pow` ใช้เพื่อจัดกลุ่มบล็อก `it` ที่เป็น "ผู้ทำงาน"

`it("คำอธิบายกรณีการใช้งาน", function() { ... })`  
: ในชื่อของ `it` จะบรรยาย *ในรูปแบบที่คนอ่านแล้วเข้าใจ* ถึงกรณีการใช้งานเฉพาะ และอาร์กิวเมนต์ตัวที่สองก็จะเป็นฟังก์ชันที่ทดสอบกรณีดังกล่าว

`assert.equal(value1, value2)`
: โค้ดภายในบล็อก `it` ถ้าอิมพลีเมนต์ถูกต้อง ควรจะรันได้โดยไม่เกิดข้อผิดพลาด

  ฟังก์ชัน `assert.*` ถูกใช้เพื่อเช็คว่า `pow` ทำงานได้ตามที่คาดหวังหรือไม่ ตรงนี้เราใช้ตัวหนึ่งในนั้นคือ `assert.equal` มันจะเปรียบเทียบอาร์กิวเมนต์และโยนข้อผิดพลาดถ้าไม่เท่ากัน ซึ่งตรงนี้เช็คว่าผลลัพธ์ของ `pow(2, 3)` เท่ากับ `8` รึเปล่า นอกจากนี้ยังมีชนิดอื่นๆ ของการเปรียบเทียบและตรวจสอบด้วย ซึ่งเราจะมาเพิ่มภายหลัง

spec นี้สามารถรันได้ และมันจะไปรันเทสต์ที่อยู่ในบล็อก `it` เราจะมาดูเรื่องนี้กันในภายหลัง

## ขั้นตอนการพัฒนา

ขั้นตอนการพัฒนามักจะเป็นแบบนี้:

1. เขียนข้อกำหนด (spec) เบื้องต้น พร้อมกับเทสต์สำหรับฟังก์ชันที่พื้นฐานที่สุด
2. สร้างการอิมพลีเมนต์เบื้องต้น
3. เพื่อตรวจสอบว่ามันใช้ได้ไหม เราจะรันเฟรมเวิร์กการทดสอบ [Mocha](https://mochajs.org/) (จะมีรายละเอียดเพิ่มเติมเร็วๆ นี้) ที่จะรันข้อกำหนด ถ้าฟังก์ชันยังไม่ครบถ้วน ข้อผิดพลาดก็จะถูกแสดง เราจะทยอยแก้ไขจนกว่าทุกอย่างจะทำงาน
4. ตอนนี้เรามีการอิมพลีเมนต์เบื้องต้นที่ใช้ได้จริงพร้อมกับเทสต์แล้ว
5. เราเพิ่มกรณีการใช้งานเข้าไปในข้อกำหนด ซึ่งอาจยังไม่ได้รองรับโดยการอิมพลีเมนต์ เทสต์เริ่มล้มเหลว
6. กลับไปทำข้อ 3 ปรับแก้การอิมพลีเมนต์จนกระทั่งเทสต์ไม่มีข้อผิดพลาด
7. ทำข้อ 3-6 ซ้ำไปเรื่อยๆ จนกระทั่งฟังก์ชันลิตี้เสร็จสมบูรณ์

ดังนั้น การพัฒนาจึงเป็นแบบ *วนซ้ำ (iterative)* เราเขียนข้อกำหนด อิมพลีเมนต์มัน ตรวจสอบให้แน่ใจว่าเทสต์ผ่าน จากนั้นเขียนเทสต์เพิ่ม ตรวจว่าเทสต์ทำงานไหม แล้วก็ทำแบบนี้ต่อไป ท้ายที่สุดเราจะได้ทั้งการอิมพลีเมนต์ที่ใช้งานได้จริง พร้อมกับเทสต์สำหรับมัน

มาดูกระบวนการพัฒนานี้ในกรณีของเราเป็นรูปธรรมกันดีกว่า

ตอนนี้เราทำขั้นตอนแรกเสร็จแล้ว คือมีข้อกำหนดเบื้องต้นของ `pow` ซึ่งก่อนจะลงมือเขียนอิมพลีเมนต์ เรามาลองใช้ไลบรารี JavaScript บางตัวเพื่อรันเทสต์ดู แค่เพื่อจะได้เห็นว่าเทสต์เหล่านั้นทำงานอยู่ (ตอนนี้เทสต์ทั้งหมดน่าจะล้มเหลว)

## ข้อกำหนดที่ใช้งานจริง

ในบทเรียนนี้ เราจะใช้ไลบรารี JavaScript ต่อไปนี้ในการทดสอบ:

- [Mocha](https://mochajs.org/) -- เป็นเฟรมเวิร์กหลัก ให้ฟังก์ชันทดสอบทั่วไปต่างๆ รวมทั้ง `describe` และ `it` ตลอดจนฟังก์ชันหลักที่ใช้รันการทดสอบ
- [Chai](https://www.chaijs.com/) -- ไลบรารีที่มี assertions มากมาย ช่วยให้ใช้ assertions หลากหลายแบบได้ สำหรับตอนนี้เราต้องการแค่ `assert.equal` 
- [Sinon](https://sinonjs.org/) -- ไลบรารีที่ใช้เฝ้าดูฟังก์ชัน จำลองการทำงานของฟังก์ชันในตัว และอื่นๆ เราจะต้องใช้มันในภายหลัง

ไลบรารีเหล่านี้สามารถใช้ทดสอบได้ทั้งฝั่งเบราว์เซอร์และเซิร์ฟเวอร์ แต่ที่นี่เราจะพูดถึงกรณีบนเบราว์เซอร์

หน้า HTML เต็มรูปแบบที่มีเฟรมเวิร์กเหล่านี้พร้อมกับข้อกำหนดของ `pow`:

```html src="index.html"
```

หน้านี้ประกอบด้วย 5 ส่วน:

1. ส่วน `<head>` -- เพิ่มไลบรารีจากภายนอกและสไตล์สำหรับเทสต์
2. แท็ก `<script>` ที่มีฟังก์ชันที่เราต้องการทดสอบ ในกรณีนี้ก็คือโค้ดของ `pow`
3. เทสต์ -- ของเราอยู่ในสคริปต์ภายนอกชื่อ `test.js` ที่มี `describe("pow", ...)` ดังเช่นที่เห็นด้านบน
4. อิลีเมนต์ HTML `<div id="mocha">` จะถูกใช้โดย Mocha เพื่อแสดงผลลัพธ์
5. เทสต์จะเริ่มทำงานด้วยคำสั่ง `mocha.run()`

ผลที่ได้:

[iframe height=250 src="pow-1" border=1 edit]

ณ ตอนนี้ เทสต์ล้มเหลว มีข้อผิดพลาดเกิดขึ้น ซึ่งก็สมเหตุสมผล เพราะเรามีโค้ดฟังก์ชันที่ว่างเปล่าใน `pow` ดังนั้น `pow(2,3)` จึงคืนค่า `undefined` แทนที่จะเป็น `8`

เผื่อในอนาคต ขอบอกไว้ก่อนว่ายังมี test runner ระดับสูงกว่านี้อีก เช่น [karma](https://karma-runner.github.io/) และอื่นๆ อีกมากมาย ซึ่งช่วยให้รันเทสต์หลายๆ อันได้ง่ายขึ้น

## การเขียนอิมพลีเมนต์เบื้องต้น

มาเขียนอิมพลีเมนต์อย่างง่ายๆ ของ `pow` เพื่อให้เทสต์ผ่านกัน:

```js
function pow(x, n) {
  return 8; // :) เราโกงนะ!
}
```

ว้าว! ตอนนี้มันทำงานแล้ว!

[iframe height=250 src="pow-min" border=1 edit]