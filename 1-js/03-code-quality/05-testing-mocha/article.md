# การทดสอบอัตโนมัติด้วย Mocha

ในงานต่อๆ ไปจะมีการใช้การทดสอบอัตโนมัติ ซึ่งเป็นสิ่งที่ใช้กันอย่างแพร่หลายในโปรเจ็กต์จริงด้วย

## ทำไมต้องมีการทดสอบ?

เวลาเขียนฟังก์ชัน เรามักจะจินตนาการได้ว่ามันควรจะทำงานอย่างไร พารามิเตอร์แบบไหนให้ผลลัพธ์แบบไหน

ระหว่างพัฒนา เราตรวจสอบฟังก์ชันได้โดยการรันและเปรียบเทียบผลลัพธ์กับสิ่งที่คาดหวังไว้ เช่น อาจทำในคอนโซล

ถ้ามีอะไรผิดพลาด ก็แก้โค้ด รันใหม่ เช็คผลลัพธ์ วนไปแบบนี้จนกว่าจะใช้ได้

แต่การ "รันซ้ำ" ด้วยมือแบบนั้นยังไม่สมบูรณ์แบบ

**เมื่อทดสอบโค้ดโดยการรันซ้ำเอง มักจะมีบางอย่างหลุดไปได้ง่าย**

ยกตัวอย่างเช่น สมมติเรากำลังเขียนฟังก์ชัน `f` เขียนโค้ดนิดหน่อย ลองทดสอบดู `f(1)` ใช้ได้ แต่ `f(2)` ไม่ทำงาน เราแก้โค้ดแล้วตอนนี้ `f(2)` ก็ใช้ได้แล้ว ดูเหมือนจะครบแล้วใช่ไหม แต่เราลืมย้อนกลับไปเทสต์ `f(1)` ใหม่ ซึ่งอาจจะมีข้อผิดพลาดโผล่ขึ้นมาก็ได้

นี่เป็นเรื่องปกติมาก ตอนที่เรากำลังพัฒนาอะไรบางอย่าง มักจะมีหลายกรณีการใช้งานที่เราต้องคำนึงถึง แต่การที่จะให้โปรแกรมเมอร์มานั่งเช็คทุกกรณีด้วยตัวเองทุกครั้งที่มีการเปลี่ยนแปลง เป็นเรื่องยาก เลยกลายเป็นว่าแก้ไขอย่างหนึ่ง แล้วไปทำให้อีกอย่างพังได้ง่าย

**การทดสอบอัตโนมัติหมายถึงการเขียนเทสต์แยกออกมาต่างหาก เป็นส่วนเสริมของโค้ด เทสต์เหล่านั้นจะรันฟังก์ชันของเราในหลากหลายวิธี และเปรียบเทียบผลลัพธ์กับสิ่งที่คาดหวัง**

## Behavior Driven Development (BDD)

เรามาเริ่มต้นด้วยเทคนิคที่เรียกว่า [Behavior Driven Development](http://en.wikipedia.org/wiki/Behavior-driven_development) หรือเรียกสั้นๆ ว่า BDD กัน

**BDD คือ 3 สิ่งในหนึ่งเดียว ทั้งเทสต์ เอกสาร และตัวอย่างการใช้งาน**

เพื่อทำความเข้าใจ BDD เราจะมาดูตัวอย่างกรณีศึกษาในการพัฒนาซอฟต์แวร์กัน

## การพัฒนา "pow": ข้อกำหนด

สมมติว่าเราอยากเขียนฟังก์ชัน `pow(x, n)` ที่คืนค่า `x` ยกกำลังด้วยเลขชี้กำลังจำนวนเต็ม `n` โดยเราสมมติว่า `n≥0`

จริงๆ แล้วนี่เป็นแค่ตัวอย่าง เพราะในจาวาสคริปต์มีตัวดำเนินการ `**` ที่ทำแบบนี้ได้อยู่แล้ว แต่ตรงนี้เราจะมุ่งเน้นไปที่วิธีการพัฒนาที่สามารถนำไปประยุกต์ใช้กับงานที่ซับซ้อนกว่านี้ได้ด้วย

ก่อนจะเขียนโค้ดของ `pow` เราสามารถจินตนาการถึงสิ่งที่ฟังก์ชันควรจะทำและบรรยายมันไว้ก่อนได้

คำบรรยายแบบนี้เรียกว่า *ข้อกำหนด (specification)* หรือเรียกสั้นๆ ว่า spec ซึ่งจะประกอบด้วยรายละเอียดกรณีการใช้งานต่างๆ ร่วมกับเทสต์สำหรับกรณีเหล่านั้น ดังนี้

```js
describe("pow", function() {

  it("ยกกำลัง n", function() {
    assert.equal(pow(2, 3), 8);
  });

});
```

spec มีองค์ประกอบหลัก 3 ส่วนตามที่เห็นข้างบน

`describe("ชื่อหัวข้อ", function() { ... })`
: เรากำลังอธิบายฟังก์ชันอะไร? ในกรณีนี้คือฟังก์ชัน `pow` ใช้เพื่อจัดกลุ่มบล็อก `it` ที่เป็น "ผู้ทำงาน"

`it("คำอธิบายกรณีการใช้งาน", function() { ... })`  
: ในชื่อของ `it` จะบรรยาย *ในรูปแบบที่คนอ่านแล้วเข้าใจ* ถึงกรณีการใช้งานเฉพาะ และอาร์กิวเมนต์ตัวที่สองก็จะเป็นฟังก์ชันที่ทดสอบกรณีดังกล่าว

`assert.equal(value1, value2)`
: โค้ดภายในบล็อก `it` ถ้าอิมพลีเมนต์ถูกต้อง ควรจะรันได้โดยไม่เกิดข้อผิดพลาด

  ฟังก์ชัน `assert.*` ถูกใช้เพื่อเช็คว่า `pow` ทำงานได้ตามที่คาดหวังหรือไม่ ตรงนี้เราใช้ตัวหนึ่งในนั้นคือ `assert.equal` มันจะเปรียบเทียบอาร์กิวเมนต์และโยนข้อผิดพลาดถ้าไม่เท่ากัน ซึ่งตรงนี้เช็คว่าผลลัพธ์ของ `pow(2, 3)` เท่ากับ `8` รึเปล่า นอกจากนี้ยังมีชนิดอื่นๆ ของการเปรียบเทียบและตรวจสอบด้วย ซึ่งเราจะมาเพิ่มภายหลัง

spec นี้สามารถรันได้ และมันจะไปรันเทสต์ที่อยู่ในบล็อก `it` เราจะมาดูเรื่องนี้กันในภายหลัง

## ขั้นตอนการพัฒนา

ขั้นตอนการพัฒนามักจะเป็นแบบนี้:

1. เขียนข้อกำหนด (spec) เบื้องต้น พร้อมกับเทสต์สำหรับฟังก์ชันที่พื้นฐานที่สุด
2. สร้างการอิมพลีเมนต์เบื้องต้น
3. เพื่อตรวจสอบว่ามันใช้ได้ไหม เราจะรันเฟรมเวิร์กการทดสอบ [Mocha](https://mochajs.org/) (จะมีรายละเอียดเพิ่มเติมเร็วๆ นี้) ที่จะรันข้อกำหนด ถ้าฟังก์ชันยังไม่ครบถ้วน ข้อผิดพลาดก็จะถูกแสดง เราจะทยอยแก้ไขจนกว่าทุกอย่างจะทำงาน
4. ตอนนี้เรามีการอิมพลีเมนต์เบื้องต้นที่ใช้ได้จริงพร้อมกับเทสต์แล้ว
5. เราเพิ่มกรณีการใช้งานเข้าไปในข้อกำหนด ซึ่งอาจยังไม่ได้รองรับโดยการอิมพลีเมนต์ เทสต์เริ่มล้มเหลว
6. กลับไปทำข้อ 3 ปรับแก้การอิมพลีเมนต์จนกระทั่งเทสต์ไม่มีข้อผิดพลาด
7. ทำข้อ 3-6 ซ้ำไปเรื่อยๆ จนกระทั่งฟังก์ชันลิตี้เสร็จสมบูรณ์

ดังนั้น การพัฒนาจึงเป็นแบบ *วนซ้ำ (iterative)* เราเขียนข้อกำหนด อิมพลีเมนต์มัน ตรวจสอบให้แน่ใจว่าเทสต์ผ่าน จากนั้นเขียนเทสต์เพิ่ม ตรวจว่าเทสต์ทำงานไหม แล้วก็ทำแบบนี้ต่อไป ท้ายที่สุดเราจะได้ทั้งการอิมพลีเมนต์ที่ใช้งานได้จริง พร้อมกับเทสต์สำหรับมัน

มาดูกระบวนการพัฒนานี้ในกรณีของเราเป็นรูปธรรมกันดีกว่า

ตอนนี้เราทำขั้นตอนแรกเสร็จแล้ว คือมีข้อกำหนดเบื้องต้นของ `pow` ซึ่งก่อนจะลงมือเขียนอิมพลีเมนต์ เรามาลองใช้ไลบรารี JavaScript บางตัวเพื่อรันเทสต์ดู แค่เพื่อจะได้เห็นว่าเทสต์เหล่านั้นทำงานอยู่ (ตอนนี้เทสต์ทั้งหมดน่าจะล้มเหลว)

## ข้อกำหนดที่ใช้งานจริง

ในบทเรียนนี้ เราจะใช้ไลบรารี JavaScript ต่อไปนี้ในการทดสอบ:

- [Mocha](https://mochajs.org/) -- เป็นเฟรมเวิร์กหลัก ให้ฟังก์ชันทดสอบทั่วไปต่างๆ รวมทั้ง `describe` และ `it` ตลอดจนฟังก์ชันหลักที่ใช้รันการทดสอบ
- [Chai](https://www.chaijs.com/) -- ไลบรารีที่มี assertions มากมาย ช่วยให้ใช้ assertions หลากหลายแบบได้ สำหรับตอนนี้เราต้องการแค่ `assert.equal` 
- [Sinon](https://sinonjs.org/) -- ไลบรารีที่ใช้เฝ้าดูฟังก์ชัน จำลองการทำงานของฟังก์ชันในตัว และอื่นๆ เราจะต้องใช้มันในภายหลัง

ไลบรารีเหล่านี้สามารถใช้ทดสอบได้ทั้งฝั่งเบราว์เซอร์และเซิร์ฟเวอร์ แต่ที่นี่เราจะพูดถึงกรณีบนเบราว์เซอร์

หน้า HTML เต็มรูปแบบที่มีเฟรมเวิร์กเหล่านี้พร้อมกับข้อกำหนดของ `pow`:

```html src="index.html"
```

หน้านี้ประกอบด้วย 5 ส่วน:

1. ส่วน `<head>` -- เพิ่มไลบรารีจากภายนอกและสไตล์สำหรับเทสต์
2. แท็ก `<script>` ที่มีฟังก์ชันที่เราต้องการทดสอบ ในกรณีนี้ก็คือโค้ดของ `pow`
3. เทสต์ -- ของเราอยู่ในสคริปต์ภายนอกชื่อ `test.js` ที่มี `describe("pow", ...)` ดังเช่นที่เห็นด้านบน
4. อิลีเมนต์ HTML `<div id="mocha">` จะถูกใช้โดย Mocha เพื่อแสดงผลลัพธ์
5. เทสต์จะเริ่มทำงานด้วยคำสั่ง `mocha.run()`

ผลที่ได้:

[iframe height=250 src="pow-1" border=1 edit]

ณ ตอนนี้ เทสต์ล้มเหลว มีข้อผิดพลาดเกิดขึ้น ซึ่งก็สมเหตุสมผล เพราะเรามีโค้ดฟังก์ชันที่ว่างเปล่าใน `pow` ดังนั้น `pow(2,3)` จึงคืนค่า `undefined` แทนที่จะเป็น `8`

เผื่อในอนาคต ขอบอกไว้ก่อนว่ายังมี test runner ระดับสูงกว่านี้อีก เช่น [karma](https://karma-runner.github.io/) และอื่นๆ อีกมากมาย ซึ่งช่วยให้รันเทสต์หลายๆ อันได้ง่ายขึ้น

## การเขียนอิมพลีเมนต์เบื้องต้น

มาเขียนอิมพลีเมนต์อย่างง่ายๆ ของ `pow` เพื่อให้เทสต์ผ่านกัน:

```js
function pow(x, n) {
  return 8; // :) เราโกงนะ!
}
```

ว้าว! ตอนนี้มันทำงานแล้ว!

[iframe height=250 src="pow-min" border=1 edit]

## ปรับปรุงข้อกำหนด

สิ่งที่เราทำไปนั่นถือเป็นการโกงอย่างแน่นอน ฟังก์ชันไม่ได้ทำงานจริง: หากลองคำนวณ `pow(3,4)` จะได้ผลลัพธ์ที่ไม่ถูกต้อง แต่การทดสอบกลับผ่าน

...แต่สถานการณ์แบบนี้ก็พบได้บ่อยในทางปฏิบัติ การทดสอบผ่าน แต่ฟังก์ชันทำงานผิด แสดงว่าข้อกำหนดของเรายังไม่ครบถ้วน เราต้องเพิ่มกรณีการใช้งานเข้าไปอีก

มาเพิ่มการทดสอบอีกหนึ่งอันเพื่อตรวจสอบว่า `pow(3, 4) = 81` กัน

เราสามารถเลือกจัดการทดสอบตรงนี้ได้สองแบบ:

1. แบบแรก -- เพิ่ม `assert` อีกอันเข้าไปใน `it` อันเดิม:

   ```js
   describe("pow", function() {

     it("ยกกำลัง n", function() {
       assert.equal(pow(2, 3), 8);
   *!*
       assert.equal(pow(3, 4), 81);
   */!*
     });

   });
   ```

2. แบบที่สอง -- แยกเป็นสองการทดสอบ:

   ```js
   describe("pow", function() {

     it("2 ยกกำลัง 3 เท่ากับ 8", function() {
       assert.equal(pow(2, 3), 8);
     });

     it("3 ยกกำลัง 4 เท่ากับ 81", function() {
       assert.equal(pow(3, 4), 81);
     });

   });
   ```

ความแตกต่างหลักคือ เมื่อ `assert` ทำให้เกิดข้อผิดพลาด บล็อก `it` จะจบลงทันที ดังนั้นในแบบแรก ถ้า `assert` แรกล้มเหลว เราจะไม่เห็นผลของ `assert` ตัวที่สองเลย

การแยกเทสต์ออกจากกันมีประโยชน์ในการให้ข้อมูลเพิ่มเติมว่ากำลังเกิดอะไรขึ้น ดังนั้นแบบที่สองจึงดีกว่า

และนอกจากนั้น ยังมีอีกกฎหนึ่งที่ควรปฏิบัติตาม

**หนึ่งการทดสอบตรวจสอบหนึ่งสิ่ง**

ถ้าเรามองดูการทดสอบแล้วเห็นการตรวจสอบสองอย่างแยกจากกันอยู่ในนั้น การแยกมันออกเป็นสองการทดสอบที่เรียบง่ายกว่าจะดีกว่า

ดังนั้นเรามาใช้แบบที่สองกันต่อเลย

ผลลัพธ์:

[iframe height=250 src="pow-2" edit border="1"]

อย่างที่เราคาดไว้ การทดสอบที่สองล้มเหลว แน่นอน ฟังก์ชันของเราคืนค่า `8` เสมอ ในขณะที่ `assert` คาดหวัง `81`

## ปรับปรุงการอิมพลีเมนต์

มาลองเขียนอะไรที่เป็นจริงมากขึ้นเพื่อให้ผ่านเทสต์กัน: 

```js
function pow(x, n) {
  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
```

เพื่อให้มั่นใจว่าฟังก์ชันทำงานได้ถูกต้อง เรามาทดสอบกับค่าเพิ่มเติมอีก แทนที่จะเขียนบล็อก `it` ด้วยมือ เราสามารถใช้ลูป `for` ช่วยสร้างมันได้:

```js
describe("pow", function() {

  function makeTest(x) {
    let expected = x * x * x;
    it(`${x} ยกกำลัง 3 เท่ากับ ${expected}`, function() {
      assert.equal(pow(x, 3), expected);
    });
  }

  for (let x = 1; x <= 5; x++) {
    makeTest(x);
  }

});
```

ผลลัพธ์:

[iframe height=250 src="pow-3" edit border="1"]

## ขยายข้อกำหนด

ฟังก์ชันหลักของ `pow` เสร็จสมบูรณ์แล้ว การพัฒนารอบแรกจบลงแล้ว เมื่อเราฉลองและดื่มแชมเปญเสร็จ ก็ถึงเวลาพัฒนาต่อและปรับปรุงมันกัน

อย่างที่บอกไป ฟังก์ชัน `pow(x, n)` มีไว้สำหรับใช้กับค่า `n` ที่เป็นจำนวนเต็มบวก

เพื่อระบุข้อผิดพลาดทางคณิตศาสตร์ ฟังก์ชันใน JavaScript มักจะคืนค่า `NaN` เรามาทำแบบเดียวกันสำหรับค่า `n` ที่ไม่ถูกต้องกัน

อย่างแรกเรามาเพิ่มพฤติกรรมนี้ลงในข้อกำหนด (!):

```js
describe("pow", function() {

  // ...

  it("สำหรับ n ติดลบ ผลลัพธ์คือ NaN", function() {
*!*
    assert.isNaN(pow(2, -1));
*/!*
  });

  it("สำหรับ n ที่ไม่ใช่จำนวนเต็ม ผลลัพธ์คือ NaN", function() {
*!*
    assert.isNaN(pow(2, 1.5));    
*/!*
  });

});
```

ผลลัพธ์กับเทสต์ใหม่:

[iframe height=530 src="pow-nan" edit border="1"]

เทสต์ที่เพิ่มเข้ามาใหม่ล้มเหลว เพราะการอิมพลีเมนต์ของเรายังไม่รองรับกรณีเหล่านี้ นี่แหละคือวิธีการทำงานของ BDD: อย่างแรกเราเขียนเทสต์ที่ล้มเหลวก่อน แล้วค่อยไปเขียนอิมพลีเมนต์ให้มันผ่าน

```smart header="Assertion อื่นๆ"
สังเกตการใช้ assertion `assert.isNaN`: มันตรวจสอบค่า `NaN`

ใน [Chai](https://www.chaijs.com/) ยังมี assertion อื่นๆ อีกด้วย เช่น:

- `assert.equal(value1, value2)` -- ตรวจสอบความเท่ากัน `value1 == value2`
- `assert.strictEqual(value1, value2)` -- ตรวจสอบความเท่ากันแบบเข้มงวด `value1 === value2`
- `assert.notEqual`, `assert.notStrictEqual` -- ตรวจสอบแบบตรงข้ามกับด้านบน
- `assert.isTrue(value)` -- ตรวจสอบว่า `value === true`
- `assert.isFalse(value)` -- ตรวจสอบว่า `value === false`
- ...ดูรายการทั้งหมดได้ใน [เอกสาร](https://www.chaijs.com/api/assert/)
```

ดังนั้นเราควรเพิ่มโค้ดอีกสองสามบรรทัดใน `pow`:

```js
function pow(x, n) {
*!*
  if (n < 0) return NaN;
  if (Math.round(n) != n) return NaN;
*/!*

  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
```

ตอนนี้มันใช้ได้แล้ว เทสต์ทั้งหมดผ่าน:

[iframe height=300 src="pow-full" edit border="1"]

[edit src="pow-full" title="เปิดตัวอย่างสมบูรณ์ใน sandbox"]

## สรุป

ใน BDD ข้อกำหนดจะมาก่อน ตามด้วยการอิมพลีเมนต์ ในท้ายที่สุดเราจะได้ทั้งข้อกำหนดและโค้ด

ข้อกำหนดสามารถใช้ได้ใน 3 ลักษณะ:

1. เป็น **การทดสอบ** - รับประกันว่าโค้ดทำงานได้ถูกต้อง
2. เป็น **เอกสาร** -- ชื่อของ `describe` และ `it` บอกว่าฟังก์ชันทำอะไร
3. เป็น **ตัวอย่าง** -- การทดสอบจริงๆ แล้วคือตัวอย่างการใช้งานที่แสดงวิธีใช้ฟังก์ชัน

ด้วยข้อกำหนด เราสามารถปรับปรุง เปลี่ยนแปลง หรือแม้กระทั่งเขียนฟังก์ชันใหม่ทั้งหมดได้อย่างปลอดภัย และมั่นใจได้ว่ามันยังคงทำงานได้ถูกต้อง

สิ่งนี้สำคัญมากโดยเฉพาะในโปรเจ็กต์ขนาดใหญ่ที่มีการใช้ฟังก์ชันในหลายๆ ที่ เมื่อเราเปลี่ยนแปลงฟังก์ชันแบบนั้น การตรวจสอบด้วยมือว่าทุกที่ที่ใช้มันยังทำงานถูกต้องหรือไม่นั้นเป็นไปไม่ได้เลย 

หากไม่มีการทดสอบ คนเรามีทางเลือกอยู่สองทาง:

1. ทำการเปลี่ยนแปลงอย่างไม่คิดอะไร แล้วผู้ใช้ของเราจะเจอบั๊ก เพราะเราอาจพลาดไม่ได้ตรวจอะไรบางอย่างด้วยตัวเอง
2. หรือถ้าการลงโทษสำหรับข้อผิดพลาดรุนแรง เนื่องจากไม่มีการทดสอบ คนก็จะกลัวที่จะแก้ไขฟังก์ชันเหล่านั้น ทำให้โค้ดล้าสมัย ไม่มีใครอยากยุ่ง ไม่ดีต่อการพัฒนา

**การทดสอบอัตโนมัติช่วยหลีกเลี่ยงปัญหาเหล่านี้!**

ถ้าโปรเจ็กต์มีการทดสอบครอบคลุม ก็จะไม่มีปัญหาดังกล่าวเกิดขึ้นอีก หลังจากมีการเปลี่ยนแปลงใดๆ เราสามารถรันการทดสอบและเห็นการตรวจสอบเป็นจำนวนมากที่ทำภายในเพียงไม่กี่วินาที

**นอกจากนี้ โค้ดที่ผ่านการทดสอบอย่างดียังมีสถาปัตยกรรมที่ดีกว่าด้วย**

แน่นอนว่านั่นเป็นเพราะโค้ดที่ผ่านการทดสอบอัตโนมัติจะปรับเปลี่ยนและปรับปรุงได้ง่ายกว่า แต่ก็ยังมีเหตุผลอื่นอีก 

ในการเขียนการทดสอบ โค้ดควรจัดระเบียบในลักษณะที่ฟังก์ชันแต่ละตัวมีหน้าที่ที่อธิบายไว้ชัดเจน มีอินพุตและเอาต์พุตที่กำหนดไว้ดี นั่นหมายถึงการมีสถาปัตยกรรมที่ดีตั้งแต่ต้น 

ในชีวิตจริง บางครั้งการเขียนข้อกำหนดก่อนเขียนโค้ดจริงก็ไม่ได้ง่ายเสมอไป เพราะอาจยังไม่ชัดเจนว่ามันควรจะทำงานอย่างไร แต่โดยทั่วไปแล้วการเขียนการทดสอบจะทำให้การพัฒนาเร็วขึ้นและมั่นคงขึ้น

ต่อไปในบทเรียน คุณจะพบกับหลากหลายแบบฝึกหัดที่มีการทดสอบรวมอยู่ด้วย ดังนั้นคุณจะได้เห็นตัวอย่างที่เป็นรูปธรรมมากขึ้น

การเขียนการทดสอบต้องอาศัยความรู้ JavaScript ที่ดี แต่ตอนนี้เรากำลังเริ่มเรียนรู้มัน ดังนั้นเพื่อให้ทุกอย่างลงตัว ณ ตอนนี้คุณยังไม่จำเป็นต้องเขียนการทดสอบ แต่คุณควรสามารถอ่านการทดสอบออกได้บ้างแล้ว ถึงแม้มันจะซับซ้อนกว่าในบทนี้เล็กน้อยก็ตาม