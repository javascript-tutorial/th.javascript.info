## ทดสอบโค้ดแบบอัตโนมัติกับ Mocha

โค้ดที่เราจะเขียนต่อไปนี้ จะมีการทดสอบอัตโนมัติด้วยนะ ซึ่งเป็นเทคนิคที่ใช้กันทั่วไปในโปรเจ็กต์จริงด้วย

## ทำไมเราต้องทดสอบ?

เวลาเขียนฟังก์ชัน เรานึกออกว่ามันควรจะทำงานยังไง ใส่อะไรเข้าไป แล้วได้อะไรออกมา

ตอนพัฒนา เราก็จะทดสอบโดยการรันฟังก์ชัน แล้วดูว่าผลลัพธ์เป็นอย่างที่คาดหวังไว้หรือเปล่า เช่น รันใน console อะไรแบบนั้น

ถ้าอะไรผิด ก็แก้โค้ด รันใหม่ ดูผลลัพธ์... วนๆ ไปจนกว่ามันจะเวิร์ค

แต่การ "รันซ้ำ" แบบแมนนวลเนี่ย มันไม่ค่อยเวิร์คอะดิ

**เวลาทดสอบโค้ดแบบรันซ้ำเอง มันง่ายมากที่จะพลาดอะไรบางอย่าง**

เช่น เราสร้างฟังก์ชัน `f` เขียนโค้ดเสร็จ ทดสอบ: `f(1)` ทำงาน แต่ `f(2)` ไม่ทำงาน เราแก้โค้ด แล้วตอนนี้ `f(2)` ทำงานแล้ว ดูเหมือนเสร็จแล้วใช่ไหม? แต่เราลืมทดสอบ `f(1)` อีกที อาจจะเจอ error ก็ได้

นี่เป็นเรื่องปกติมาก เวลาเราพัฒนาอะไร เรามักจะคิดถึงกรณีต่างๆ ที่อาจเกิดขึ้น แต่การคาดหวังให้นักเขียนโค้ดทดสอบทุกกรณีด้วยตัวเองหลังจากทุกการเปลี่ยนแปลง แต่มันเป็นไปได้ยาก ดังนั้น จึงง่ายที่จะแก้สิ่งหนึ่ง แล้วดันไปทำอีกสิ่งเสีย

**การทดสอบอัตโนมัติ หมายถึงการเขียนทดสอบแยกต่างหากจากโค้ด พวกมันจะรันฟังก์ชันของเราในหลายๆ กรณี แล้วเปรียบเทียบผลลัพธ์กับที่คาดหวัง**

## Behavior Driven Development (BDD)

เราจะเริ่มต้นด้วยเทคนิคที่เรียกว่า Behavior Driven Development: [http://en.wikipedia.org/wiki/Behavior-driven_development](http://en.wikipedia.org/wiki/Behavior-driven_development) หรือเรียกสั้นๆ ว่า BDD

**BDD คือสามสิ่งในหนึ่งเดียว: ทดสอบ + เอกสาร + ตัวอย่าง**

เพื่อให้เข้าใจ BDD เราจะดูตัวอย่างการพัฒนาในทางปฏิบัติ

## ปฏิบัติการสร้าง "pow": รู้จัก "spec" ก่อน

สมมติว่าเราอยากสร้างฟังก์ชัน `pow(x, n)` ที่เอา x ยกกำลัง n โดยที่ n ต้องเป็นเลขเต็มบวกนะ

ฟังดูน่าเบื่อใช่มั้ย? จริงๆ แล้วเจ้านี่มีตัว `**` ใน JavaScript ที่ทำได้อยู่แล้ว แต่เดี๋ยวก่อน! เราจะใช้ตัวอย่างนี้ฝึกฝนวิธีคิดในการสร้างฟังก์ชันที่ซับซ้อนกว่านี้ได้ด้วยนะ

ก่อนเขียนโค้ด `pow` เราต้องรู้จักมันก่อนว่ามันจะทำอะไรบ้าง และอธิบายมันออกมาเป็นคำพูด

คำอธิบายนี้เรียกว่า *specification* หรือเรียกสั้นๆ ว่า *spec* ซึ่งจะรวมถึงวิธีการใช้งานและการทดสอบว่ามันทำงานถูกต้องหรือเปล่า

```js
describe("pow", function() {

  it("ยกกำลัง n ได้", function() {
    assert.equal(pow(2, 3), 8);
  });

});
```

spec จะมี 3 ส่วนหลักๆ ตามที่เห็นเลย:

`describe("ชื่อ", function() { ... })`
: บอกเราว่ากำลังอธิบายอะไร ในกรณีนี้เรากำลังอธิบายฟังก์ชัน `pow` นั่นเอง เหมือนหัวข้อของกลุ่มคนงานที่กำลังจะมาทำงานในบล็อก `it`

`it("คำอธิบายการใช้งาน", function() { ... })`
: ในหัวข้อของ `it` เราจะ *อธิบายด้วยภาษาคน* ว่าฟังก์ชันนี้ควรทำงานอย่างไรในสถานการณ์นั้นๆ และตัว argument ที่สองเป็นฟังก์ชันทดสอบ

`assert.equal(ค่า1, ค่า2)`
: โค้ดภายในบล็อก `it` ถ้าการทำงานของฟังก์ชันถูกต้อง จะต้องทำงานโดยไม่มี error

    ฟังก์ชัน `assert.*` ใช้ตรวจสอบว่า `pow` ทำงานตามที่คาดหวังหรือไม่ ในตัวอย่างนี้เราใช้ `assert.equal` เพื่อเปรียบเทียบค่าสองค่า ถ้าไม่เท่ากัน จะมี error แสดงขึ้นมา ที่นี่เราทดสอบว่าผลลัพธ์ของ `pow(2, 3)` เท่ากับ `8` หรือเปล่า นอกจากนี้ยังมีฟังก์ชันอื่นๆ สำหรับการเปรียบเทียบและตรวจสอบ อันนี้ไว้ค่อยมาดูกันทีหลัง

spec สามารถเรียกใช้เพื่อทดสอบฟังก์ชันของเราได้ เราจะมาดูวิธีการนั้นในตอนต่อไป!

## ขั้นตอนการพัฒนา

ขั้นตอนการพัฒนาโดยทั่วไปมีหน้าตาแบบนี้:

1. เขียน spec เบื้องต้นพร้อมทดสอบสำหรับฟังก์ชันเบสิก
2. สร้างการทำงานเบื้องต้น
3. เพื่อตรวจสอบว่ามันทำงานหรือเปล่า เราจะรันเฟรมเวิร์คทดสอบ Mocha: [http://mochajs.org/](http://mochajs.org/) (เดี๋ยวจะอธิบายเพิ่มเติม) ซึ่งจะรัน spec ตอนนี้ฟังก์ชันยังไม่เสร็จ ก็อาจจะมี error ขึ้นมา เราก็แก้โค้ดไปเรื่อยๆ จนกว่ามันจะเวิร์ค
4. ตอนนี้เรามีการทำงานเบื้องต้นที่ใช้ได้พร้อมกับทดสอบแล้ว
5. เราเพิ่มกรณีการใช้งานเพิ่มเติมลงใน spec ซึ่งอาจจะยังไม่รองรับโดยการทำงานตอนนี้ ทดสอบก็จะล้มเหลวก่อน
6. กลับไปข้อ 3 อัปเดตการทำงานจนกระทั่งทดสอบผ่าน
7. ทำซ้ำข้อ 3-6 จนกว่าฟังก์ชันพร้อมใช้งาน

ดังนั้นการพัฒนาเป็นแบบ *วนซ้ำ* เราเขียน spec ทำงาน ทดสอบ จนผ่าน แล้วก็เขียนทดสอบเพิ่ม ทำให้มันผ่านอีก จนสุดท้ายเราก็ได้ทั้งการทำงานที่ใช้ได้และทดสอบสำหรับมัน

มาดูขั้นตอนการพัฒนานี้ในกรณีตัวอย่างของเรา

ขั้นตอนแรกเสร็จไปแล้ว: เรามี spec เบื้องต้นสำหรับ `pow` ตอนนี้ก่อนที่จะสร้างการทำงาน ลองใช้ไลบรารี่ JavaScript สักสองสามตัวเพื่อรันทดสอบดู แค่เพื่อดูว่ามันทำงาน (ก็จะล้มเหลวหมดแหละ)

## ทดสอบ spec กัน!

ในบทช่วยสอนนี้ เราจะใช้ไลบรารี JavaScript สำหรับทดสอบดังต่อไปนี้:

- Mocha: [http://mochajs.org/](http://mochajs.org/) -- เฟรมเวิร์คหลัก: มันให้ฟังก์ชันการทดสอบทั่วไปรวมถึง `describe` และ `it` และฟังก์ชันหลักที่รันทดสอบ
- Chai: [http://chaijs.com](http://chaijs.com) -- ไลบรารีที่มี assertions มากมาย มันช่วยให้ใช้ assertions ที่แตกต่างกันได้มากมาย ตอนนี้เราต้องการแค่ `assert.equal`
- Sinon: [http://sinonjs.org/](http://sinonjs.org/) -- ไลบรารีสำหรับสอดแนมฟังก์ชัน เลียนแบบฟังก์ชันในตัวและอื่นๆ เราจะใช้มันในภายหลัง

ไลบรารีเหล่านี้เหมาะสำหรับการทดสอบทั้งในเบราว์เซอร์และฝั่งเซิร์ฟเวอร์ ในที่นี้เราจะพิจารณาตัวแปรเบราว์เซอร์

หน้า HTML เต็มรูปแบบพร้อมเฟรมเวิร์คเหล่านี้และ spec ของ `pow`:

```html src="index.html"
```

หน้าแบ่งออกเป็น 5 ส่วน:

1. `<head>` -- เพิ่มไลบรารีของบุคคลที่สามและสไตล์สำหรับการทดสอบ
2. `<script>` พร้อมฟังก์ชันที่จะทดสอบ ในกรณีของเรา -- พร้อมโค้ดสำหรับ `pow`
3. ทดสอบ -- ในกรณีของเราเป็นสคริปต์ภายนอก `test.js` ที่มี `describe("pow", ...)` จากข้างบน
4. HTML element `<div id="mocha">` จะใช้โดย Mocha เพื่อแสดงผลลัพธ์
5. การทดสอบเริ่มต้นโดยคำสั่ง `mocha.run()`

ผลลัพธ์:

[iframe height=250 src="pow-1" border=1 edit]

ตอนนี้ การทดสอบจะล้มเหลว มีข้อผิดพลาด นั่นเป็นเรื่องปกติ: เรามีโค้ดฟังก์ชันว่างเปล่าใน `pow` ดังนั้น `pow(2,3)` จะส่งคืน `undefined` แทนที่จะเป็น `8`

สำหรับอนาคต โปรดทราบว่ามีตัวเรียกใช้ทดสอบระดับสูงมากกว่านี้ เช่น karma: [https://karma-runner.github.io/](https://karma-runner.github.io/) และอื่นๆ ที่ทำให้การรันทดสอบต่างๆ โดยอัตโนมัติเป็นเรื่องง่าย

## เริ่มต้นใช้งานกันเถอะ

งั้นมาสร้างการทำงานเบื้องต้นของ `pow` เพื่อให้ทดสอบผ่านดู:

```js
function pow(x, n) {
  return 8; // :) เราโกง!
}
```

เย้ ตอนนี้ผ่านแล้ว!

[iframe height=250 src="pow-min" border=1 edit]

## ปรับปรุง spec ให้ดีขึ้น

สิ่งที่เราทำไปนั้นมันโกงชัดๆ ฟังก์ชันยังทำงานไม่ถูกต้อง: การพยายามคำนวณ `pow(3,4)` จะให้ผลลัพธ์ที่ไม่ถูกต้อง แต่ทดสอบผ่าน...

...แต่สถานการณ์นี้ค่อนข้างธรรมดา มันเกิดขึ้นในทางปฏิบัติ ทดสอบผ่าน แต่ฟังก์ชันทำงานผิดพลาด spec ของเรายังไม่สมบูรณ์ เราจำเป็นต้องเพิ่มกรณีการใช้งานเพิ่มเติม

มาเพิ่มการทดสอบอีกหนึ่งข้อเพื่อตรวจสอบว่า `pow(3, 4) = 81`

เราสามารถเลือกหนึ่งในสองวิธีในการจัดระเบียบการทดสอบที่นี่:

1. วิธีแรก -- เพิ่ม `assert` อีกอันลงใน `it` เดียวกัน:

```js
describe("pow", function() {

  it("ยกกำลัง n", function() {
    assert.equal(pow(2, 3), 8);
    *!*
    assert.equal(pow(3, 4), 81);
    */!*
  });

});
```

2. วิธีที่สอง -- สร้างสองการทดสอบ:

```js
describe("pow", function() {

  it("2 ยกกำลัง 3 เท่ากับ 8", function() {
    assert.equal(pow(2, 3), 8);
  });

  it("3 ยกกำลัง 4 เท่ากับ 81", function() {
    assert.equal(pow(3, 4), 81);
  });

});
```

ความแตกต่างหลักคือ เมื่อ `assert` ทริกเกอร์ข้อผิดพลาด บล็อก `it` จะยุติทันที ดังนั้น ในวิธีแรก หาก `assert` แรกล้มเหลว เราจะไม่เห็นผลลัพธ์ของ `assert` ที่สอง

การแยกการทดสอบออกจากกันนั้นมีประโยชน์ในการรับข้อมูลเพิ่มเติมเกี่ยวกับสิ่งที่เกิดขึ้น ดังนั้นวิธีที่สองจึงดีกว่า

และนอกจากนั้น ยังมีกฎอีกข้อหนึ่งที่ควรปฏิบัติตาม

**การทดสอบหนึ่งครั้ง ตรวจสอบสิ่งหนึ่ง**

ถ้าเราดูการทดสอบและเห็นการตรวจสอบอิสระสองข้อในนั้น ควรแยกมันออกเป็นสองข้อที่ง่ายกว่า

ดังนั้น มาต่อกันด้วยวิธีที่สอง

ผลลัพธ์:

[iframe height=250 src="pow-2" edit border="1"]

อย่างที่เราคาดไว้ การทดสอบที่สองล้มเหลว แน่นอน ฟังก์ชันของเราส่งคืน `8` เสมอ ในขณะที่ `assert` คาดหวัง `81`

## อัพเกรดการทำงานให้เทพ!

งั้นมาเขียนอะไรที่จริงจังกว่านี้ให้ทดสอบผ่านกันดีกว่า:

```js
function pow(x, n) {
  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
```

เพื่อให้แน่ใจว่าฟังก์ชันทำงานได้ดี เราจะทดสอบมันสำหรับค่าอื่นๆ แทนที่จะเขียนบล็อก `it` ด้วยมือ เราสามารถสร้างมันใน `for` ได้:

```js
describe("pow", function() {

  function makeTest(x) {
    let expected = x * x * x;
    it(`${x} ยกกำลัง 3 เท่ากับ ${expected}`, function() {
      assert.equal(pow(x, 3), expected);
    });
  }

  for (let x = 1; x <= 5; x++) {
    makeTest(x);
  }

});
```

ผลลัพธ์:

[iframe height=250 src="pow-3" edit border="1"]

## describe ซ้อนกัน

เราจะเพิ่มการทดสอบอีกมากมาย แต่ก่อนหน้านั้น โปรดทราบว่าฟังก์ชันช่วยเหลือ `makeTest` และ `for` ควรจัดกลุ่มไว้ด้วยกัน เราไม่ต้องการ `makeTest` ในการทดสอบอื่น ๆ มันจำเป็นเฉพาะใน `for` เท่านั้น: ภารกิจทั่วไปของพวกมันคือการตรวจสอบว่า `pow` ยกกำลังตามที่กำหนด

การจัดกลุ่มทำได้ด้วย `describe` ซ้อนกัน:

```js
describe("pow", function() {

*!*
  describe("ยก x ยกกำลัง 3", function() {
*/!*

    function makeTest(x) {
      let expected = x * x * x;
      it(`${x} ยกกำลัง 3 เท่ากับ ${expected}`, function() {
        assert.equal(pow(x, 3), expected);
      });
    }

    for (let x = 1; x <= 5; x++) {
      makeTest(x);
    }

*!*
  });
*/!*

  // ... จะมีการทดสอบเพิ่มเติมที่นี่ ทั้ง describe และ it สามารถเพิ่มได้
});
```

`describe` ซ้อนกันกำหนด "กลุ่มย่อย" ใหม่ของการทดสอบ ในผลลัพธ์ เราจะเห็นการเยื้องหัวข้อ:

[iframe height=250 src="pow-4" edit border="1"]

ในอนาคต เราสามารถเพิ่ม `it` และ `describe` เพิ่มเติมในระดับบนสุดพร้อมฟังก์ชันช่วยเหลือของตัวเอง พวกมันจะไม่เห็น `makeTest`

````smart header="`เทคนิคเสริม: `before/after` กับ `beforeEach/afterEach`"

นอกจากการทดสอบแบบปกติ เรายังมีเทคนิคเสริมที่ช่วยให้การทดสอบสะดวกขึ้น นั่นคือ `before/after` และ `beforeEach/afterEach`

* `before/after`: ฟังก์ชันเหล่านี้จะทำงานก่อน/หลังการรันการทดสอบทั้งหมด ตัวอย่างเช่น เราอาจจะใช้ `before` เพื่อเตรียมข้อมูลเบื้องต้น หรือใช้ `after` เพื่อล้างข้อมูลหลังจากรันการทดสอบเสร็จ

* `beforeEach/afterEach`: ฟังก์ชันเหล่านี้จะทำงานก่อน/หลังการรัน *ทุก* `it` ตัวอย่างเช่น เราอาจจะใช้ `beforeEach` เพื่อสร้าง mock object หรือใช้ `afterEach` เพื่อล้าง mock object

**ตัวอย่างการใช้งาน:**

```js
describe("test", function() {

  before(() => alert("เริ่มทดสอบ – ก่อนทดสอบทั้งหมด"));
  after(() => alert("ทดสอบเสร็จ – หลังทดสอบทั้งหมด"));

  beforeEach(() => alert("ก่อนการทดสอบ – เข้าสู่การทดสอบ"));
  afterEach(() => alert("หลังการทดสอบ – ออกจากการทดสอบ"));

  it('test 1', () => alert(1));
  it('test 2', () => alert(2));

});
```

ลำดับการทำงานจะเป็น:

```
เริ่มทดสอบ – ก่อนทดสอบทั้งหมด (before)
ก่อนการทดสอบ – เข้าสู่การทดสอบ (beforeEach)
1
หลังการทดสอบ – ออกจากการทดสอบ   (afterEach)
ก่อนการทดสอบ – เข้าสู่การทดสอบ (beforeEach)
2
หลังการทดสอบ – ออกจากการทดสอบ   (afterEach)
ทดสอบเสร็จ – หลังทดสอบทั้งหมด (after)
```

[iframe src="beforeafter" height=250 edit border="1"]

โดยทั่วไป เราใช้ `beforeEach/afterEach` กับ `before/after` เพื่อ:

* ทำการเตรียมข้อมูลเบื้องต้น
* รีเซ็ตค่าตัวแปร
* หรือทำอะไรบางอย่างระหว่างการทดสอบ (หรือกลุ่มการทดสอบ)
````

## ยกระดับสเปค (ให้มันเจ๋ง!)

ฟังก์ชัน `pow` พื้นฐานเสร็จเรียบร้อยแล้ว! ได้เวลาปาร์ตี้ฉลองดื่มแชมเปญกัน -- เอ้ย! ยังๆๆ เรายังพัฒนาต่อได้อีก

อย่างที่บอกไว้ ฟังก์ชัน `pow(x, n)` ทำงานกับค่า `n` ที่เป็นจำนวนเต็มบวกเท่านั้น

เพื่อบอกข้อผิดพลาดทางคณิตศาสตร์ ฟังก์ชัน JavaScript มักจะคืนค่า `NaN` (Not a Number) เรามาทำแบบเดียวกันสำหรับค่า `n` ที่ไม่ถูกต้อง

ก่อนอื่นมาอัปเดตสเปคกันก่อน!

```js
describe("pow", function() {

  // ...

  it("สำหรับ n ติดลบ ผลลัพธ์คือ NaN", function() {
*!*
    assert.isNaN(pow(2, -1));
*/!*
  });

  it("สำหรับ n ไม่ใช่จำนวนเต็ม ผลลัพธ์คือ NaN", function() {
*!*
    assert.isNaN(pow(2, 1.5));    
*/!*
  });

});
```

ผลลัพธ์กับเทสต์ใหม่:

[iframe height=530 src="pow-nan" edit border="1"]

เอ๊ะ! เทสต์ที่เราเพิ่มใหม่ล้มเหลวซะงั้น เพราะเรายังไม่ได้เขียนโค้ดให้รองรับค่าที่กำหนดไว้ นี่แหละคือวิธี BDD เราเขียนเทสต์ที่ล้มเหลวก่อน แล้วค่อยกลับไปเขียนโค้ดให้ผ่านเทสต์นั้น

```smart header="การยืนยันอื่นๆ"
โปรดสังเกตฟังก์ชัน `assert.isNaN` ที่ใช้ตรวจสอบว่าค่าเป็น `NaN` หรือไม่

ใน [Chai](http://chaijs.com) ยังมีฟังก์ชันการยืนยันอื่นๆ อีกเช่น

- `assert.equal(value1, value2)` -- ตรวจสอบความเท่าเทียม `value1 == value2`
- `assert.strictEqual(value1, value2)` -- ตรวจสอบความเท่าเทียมแบบเข้มงวด `value1 === value2`
- `assert.notEqual`, `assert.notStrictEqual` -- ตรวจสอบความไม่เท่าเทียมกับตัวอย่างข้างต้น
- `assert.isTrue(value)` -- ตรวจสอบว่า `value === true`
- `assert.isFalse(value)` -- ตรวจสอบว่า `value === false`
- ...ดูรายการทั้งหมดได้ที่ [คู่มือ](http://chaijs.com/api/assert/)
```

มาเพิ่มโค้ดสองสามบรรทัดให้กับ `pow`:

```js
function pow(x, n) {
*!*
  if (n < 0) return NaN;
  if (Math.round(n) != n) return NaN;
*/!*

  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
```

เย้! ตอนนี้โค้ดทำงานได้แล้ว เทสต์ผ่านหมดเลย:

[iframe height=300 src="pow-full" edit border="1"]

[edit src="pow-full" title="เปิดตัวอย่างสุดท้ายแบบเต็มใน sandbox."]

## สรุป

ใน BDD เราเขียนสเปคก่อน แล้วค่อยเขียนโค้ด ท้ายที่สุดเราก็จะได้ทั้งคู่!

สเปคมีประโยชน์ 3 อย่าง:

1. **เทสต์** - เพื่อให้แน่ใจว่าโค้ดทำงานได้อย่างถูกต้อง
2. **เอกสาร** - ชื่อของ `describe` และ `it` บอกว่าฟังก์ชันทำอะไร
3. **ตัวอย่าง** - เทสต์เป็นเหมือนตัวอย่างการทำงานที่แสดงวิธีใช้ฟังก์ชัน

ด้วยสเปค เราสามารถปรับปรุง เปลี่ยนแปลง หรือแม้กระทั่งเขียนฟังก์ชันใหม่จากศูนย์ได้อย่างปลอดภัย และมั่นใจว่ามันยังคงทำงานได้อย่างถูกต้อง

สิ่งนี้มีความสำคัญอย่างยิ่งในโครงการขนาดใหญ่ เมื่อมีการใช้ฟังก์ชันในหลายๆ ส่วน หากเราเปลี่ยนฟังก์ชันนั้น ไม่มีทางที่จะตรวจสอบด้วยตนเองได้ว่าทุกส่วนที่ใช้ฟังก์ชันนั้นยังคงทำงานได้อย่างถูกต้อง

หากไม่มีการทดสอบ ผู้คนจะมีสองทางเลือก:

1. **เปลี่ยนโค้ดโดยไม่สนใจอะไร** และผู้ใช้ของเราจะพบข้อผิดพลาด เพราะเราน่าจะลืมตรวจสอบอะไรบางอย่างแบบแมนนวล
2. **กลัวที่จะแก้ไขฟังก์ชันดังกล่าว** เพราะการลงโทษสำหรับข้อผิดพลาดนั้นรุนแรง เนื่องจากไม่มีการทดสอบ ทำให้โค้ดล้าสมัย ไม่มีใครอยากเข้าไปยุ่ง ไม่ดีต่อการพัฒนา

**การทดสอบอัตโนมัติช่วยหลีกเลี่ยงปัญหาเหล่านี้!**

หากโครงการมีการทดสอบอย่างครอบคลุม ก็จะไม่มีปัญหาแบบนี้ หลังจากการเปลี่ยนแปลงใดๆ เราสามารถเรียกใช้การทดสอบและดูการตรวจสอบจำนวนมากได้ภายในเวลาไม่กี่วินาที

**นอกจากนี้ โค้ดที่ผ่านการทดสอบอย่างดีแล้วยังมีโครงสร้างที่ดีกว่า**

นั่นเป็นเพราะโค้ดที่ผ่านการทดสอบอัตโนมัติง่ายต่อการปรับปรุงและแก้ไข แต่ยังมีเหตุผลอื่นอีก

ในการเขียนเทสต์ โค้ดควรได้รับการจัดระเบียบในลักษณะที่ฟังก์ชันแต่ละฟังก์ชันมีภารกิจที่อธิบายไว้ชัดเจน มีอินพุตและเอาต์พุตที่กำหนดไว้อย่างดี ซึ่งหมายถึงโครงสร้างที่ดีตั้งแต่เริ่มต้น

ในชีวิตจริงบางครั้งก็ไม่ง่ายนัก บางครั้งการเขียนสเปคก่อนโค้ดจริงทำได้ยาก เพราะยังไม่ชัดเจนว่ามันควรทำงานอย่างไร แต่โดยทั่วไปการเขียนเทสต์จะช่วยให้การพัฒนารวดเร็วและเสถียรมากขึ้น

ในบทเรียนต่อๆ ไป คุณจะได้พบกับงานต่างๆ ที่มีการทดสอบแบบเบิร์นอิน ดังนั้นคุณจะได้เห็นตัวอย่างจริงมากขึ้น

การเขียนเทสต์ต้องใช้ความรู้ JavaScript ที่ดี แต่เรากำลังเริ่มต้นเรียนรู้ ดังนั้น ณ ตอนนี้ คุณไม่จำเป็นต้องเขียนเทสต์ แต่คุณควรสามารถอ่านเทสต์ได้แม้ว่ามันจะซับซ้อนกว่าในบทนี้นิดหน่อย
