# ชนิดข้อมูล Symbol

ตามข้อกำหนด มีเพียงชนิดข้อมูลพื้นฐานสองประเภทเท่านั้นที่สามารถใช้เป็นคีย์ของพร็อพเพอร์ตี้ในอ็อบเจ็กต์ได้:

- ชนิด string หรือ
- ชนิด symbol

มิฉะนั้น ถ้าใช้ชนิดอื่น เช่น number มันจะถูกแปลงเป็น string โดยอัตโนมัติ เพื่อให้ `obj[1]` เหมือนกับ `obj["1"]` และ `obj[true]` เหมือนกับ `obj["true"]` 

จนถึงตอนนี้ เราใช้แต่ string มาตลอด 

ตอนนี้มาสำรวจ symbol กันดูว่ามันมีประโยชน์อย่างไรบ้าง

## Symbol

"Symbol" แทนตัวระบุที่ไม่ซ้ำกัน (unique identifier)

ค่าของชนิดนี้สร้างได้โดยใช้ `Symbol()`:

```js
let id = Symbol();
```

เมื่อสร้าง เราสามารถให้คำอธิบาย (หรือเรียกว่าชื่อ symbol) ซึ่งส่วนใหญ่มีประโยชน์ในการดีบั๊ก:

```js
// id คือ symbol ที่มีคำอธิบายว่า "id"
let id = Symbol("id");
```

Symbol ได้รับการรับประกันว่าจะมีค่าไม่ซ้ำกัน แม้เราจะสร้าง symbol หลายตัวด้วยคำอธิบายเหมือนกันก็ตาม มันจะมีค่าที่แตกต่างกัน คำอธิบายเป็นเพียงป้ายกำกับที่ไม่ส่งผลอะไร

ตัวอย่างเช่น ต่อไปนี้คือ symbol สองตัวที่มีคำอธิบายเหมือนกัน -- แต่ไม่เท่ากัน:

```js run
let id1 = Symbol("id");
let id2 = Symbol("id");

*!*
alert(id1 == id2); // false
*/!*
```

ถ้าคุณคุ้นเคยกับ Ruby หรือภาษาอื่นที่มีอะไรบางอย่างคล้ายๆ "symbol" -- อย่าสับสน symbol ใน JavaScript นั้นแตกต่าง

สรุปคือ symbol เป็น "ค่าพื้นฐานที่ไม่ซ้ำกัน" ที่อาจมีคำอธิบายกำกับ มาดูกันว่าเราจะใช้มันที่ไหนได้บ้าง

````warn header="Symbol ไม่แปลงเป็น string โดยอัตโนมัติ"
ค่าส่วนใหญ่ใน JavaScript รองรับการแปลงเป็น string แบบโดยปริยาย เช่น เราสามารถ `alert` ค่าเกือบทุกอย่าง และมันจะทำงาน แต่ symbol นั้นพิเศษ จะไม่ถูกแปลงโดยอัตโนมัติ

เช่น `alert` นี้จะแสดงข้อผิดพลาด:

```js run
let id = Symbol("id");
*!*
alert(id); // TypeError: ไม่สามารถแปลงค่า Symbol เป็น string ได้ 
*/!*
```

นี่คือ "การป้องกันของภาษา" เพื่อหลีกเลี่ยงความผิดพลาด เพราะ string และ symbol นั้นแตกต่างกันโดยพื้นฐาน และไม่ควรแปลงเป็นกันและกันโดยไม่ได้ตั้งใจ

หากเราต้องการแสดง symbol ออกมาจริงๆ เราต้องเรียก `.toString()` กับมันอย่างชัดเจน แบบนี้:

```js run
let id = Symbol("id");
*!*
alert(id.toString()); // Symbol(id), ตอนนี้ทำงานแล้ว
*/!*  
```

หรือใช้คุณสมบัติ `symbol.description` เพื่อแสดงแค่คำอธิบาย:

```js run
let id = Symbol("id");
*!*
alert(id.description); // id  
*/!*
```
````

## พร็อพเพอร์ตี้ที่ "ซ่อนอยู่"

Symbol ช่วยให้เราสร้างพร็อพเพอร์ตี้ที่ "ซ่อนอยู่" ในอ็อบเจ็กต์ได้ โดยที่ส่วนอื่นของโค้ดจะไม่สามารถเข้าถึงหรือเขียนทับโดยไม่ได้ตั้งใจ

ยกตัวอย่างเช่น สมมติเรากำลังทำงานกับอ็อบเจ็กต์ `user` ที่เป็นของโค้ดจากที่อื่น เราอยากเพิ่มตัวระบุ (identifier) ให้มัน

เรามาใช้ symbol เป็นคีย์กัน:

```js run
let user = { // เป็นของโค้ดอื่น  
  name: "John"
};

let id = Symbol("id");

user[id] = 1;

alert( user[id] ); // เราสามารถเข้าถึงข้อมูลได้โดยใช้ symbol เป็นคีย์
```  

ข้อดีของการใช้ `Symbol("id")` เหนือกว่า string `"id"` คืออะไร?

เนื่องจากอ็อบเจ็กต์ `user` เป็นของโค้ดอื่น การเพิ่มฟิลด์ (field) ใหม่ลงไปจึงไม่ปลอดภัย เพราะเราอาจกระทบพฤติกรรมที่กำหนดไว้ล่วงหน้าในโค้ดอื่นนั้น อย่างไรก็ตาม symbol จะไม่สามารถเข้าถึงได้โดยบังเอิญ โค้ดบุคคลที่สามจะไม่รู้เกี่ยวกับ symbol ที่พึ่งกำหนดขึ้นใหม่ ดังนั้นจึงปลอดภัยที่จะเพิ่ม symbol ลงในอ็อบเจ็กต์ `user`  

สมมติอีกว่า สคริปต์อื่นอยากใช้ตัวระบุของตัวเองใน `user` เพื่อจุดประสงค์อะไรสักอย่าง

สคริปต์นั้นก็สามารถสร้าง `Symbol("id")` ของตัวเองได้ แบบนี้:  

```js
// ...
let id = Symbol("id");

user[id] = "ค่า id ของพวกเขา";
```

จะไม่เกิดการขัดแย้งระหว่างตัวระบุของเราและของพวกเขา เพราะ symbol จะต่างกันเสมอ แม้จะมีชื่อเหมือนกันก็ตาม

...แต่ถ้าเราใช้ string `"id"` แทน symbol สำหรับจุดประสงค์เดียวกัน ก็*จะ*เกิดการขัดแย้ง:

```js
let user = { name: "John" };  

// สคริปต์ของเราใช้คุณสมบัติ "id"
user.id = "ค่า id ของเรา"; 

// ...สคริปต์อื่นก็ต้องการ "id" เพื่อจุดประสงค์ของตัวเอง...

user.id = "ค่า id ของพวกเขา"  
// บูม! ถูกสคริปต์อื่นเขียนทับแล้ว! 
```

### Symbol ใน object literal

ถ้าเราต้องการใช้ symbol ใน object literal `{...}` เราต้องครอบมันด้วยวงเล็บก้ามปู (square brackets)

แบบนี้:

```js
let id = Symbol("id");

let user = {
  name: "John",
*!*
  [id]: 123 // ไม่ใช่ "id": 123
*/!*
};  
```

เพราะเราต้องการค่าจากตัวแปร `id` เป็นคีย์ ไม่ใช่ string "id"

### Symbol ถูกข้ามโดย for..in

พร็อพเพอร์ตี้ symbol จะไม่มีส่วนร่วมใน loop `for..in` 

ตัวอย่างเช่น:

```js run
let id = Symbol("id");
let user = {
  name: "John",
  age: 30,
  [id]: 123
};

*!*  
for (let key in user) alert(key); // name, age (ไม่มี symbol)
*/!*

// การเข้าถึงโดยตรงด้วย symbol จะใช้งานได้
alert( "Direct: " + user[id] ); // Direct: 123
```

[Object.keys(user)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys) ก็ละเว้น symbol ด้วย นี่คือส่วนหนึ่งของหลักการ "ซ่อนพร็อพเพอร์ตี้ symbol" ถ้าสคริปต์หรือไลบรารีอื่นวนลูปอ็อบเจ็กต์ของเรา มันจะไม่เจอพร็อพเพอร์ตี้ symbol โดยไม่คาดคิด

ตรงข้ามกัน [Object.assign](mdn:js/Object/assign) คัดลอกทั้งพร็อพเพอร์ตี้ string และ symbol:

```js run
let id = Symbol("id");
let user = {
  [id]: 123
};

let clone = Object.assign({}, user);

alert( clone[id] ); // 123
```

ไม่มีความขัดแย้งที่นี่ นั่นคือสิ่งที่ออกแบบไว้ แนวคิดคือ เมื่อเราโคลนอ็อบเจ็กต์หรือรวมอ็อบเจ็กต์ เรามักต้องการให้*ทุก*พร็อพเพอร์ตี้ถูกคัดลอก (รวมถึง symbol อย่าง `id` ด้วย)

## Global symbol

อย่างที่เห็น ปกติ symbol ทุกตัวจะต่างกัน แม้จะมีชื่อเหมือนกันก็ตาม แต่บางครั้งเราอยากให้ symbol ที่มีชื่อเดียวกันนั้นเป็นอันเดียวกัน เช่น ส่วนต่างๆ ของแอปของเราต้องการเข้าถึง symbol `"id"` โดยหมายถึงพร็อพเพอร์ตี้เดียวกันพอดี

เพื่อทำแบบนั้น มี *global symbol registry* เราสามารถสร้าง symbol ไว้ในนั้น และเข้าถึงมันได้ภายหลัง โดยมันรับประกันว่าการเข้าถึงโดยชื่อเดียวกันซ้ำๆ จะคืน symbol ตัวเดียวกันแน่นอน  

ในการอ่าน (สร้างถ้าไม่มี) symbol จาก registry ให้ใช้ `Symbol.for(key)`

การเรียกนั้นจะตรวจสอบ global registry และถ้ามี symbol อธิบายด้วย `key` ก็จะคืน symbol นั้น ไม่งั้นจะสร้าง symbol ใหม่ `Symbol(key)` และเก็บไว้ใน registry ด้วย `key` ที่ระบุ

ตัวอย่างเช่น:

```js run
// อ่านจาก global registry  
let id = Symbol.for("id"); // ถ้า symbol ไม่มีอยู่ ก็จะสร้างขึ้นมา

// อ่านอีกครั้ง (อาจจากส่วนอื่นของโค้ด)
let idAgain = Symbol.for("id");

// คือ symbol ตัวเดียวกัน
alert( id === idAgain ); // true
```

Symbol ภายใน registry เรียกว่า *global symbol* ถ้าเราต้องการ symbol ระดับแอปพลิเคชันที่เข้าถึงได้จากทุกที่ในโค้ด นั่นคือสิ่งที่มันมีไว้ให้

```smart header="นั่นฟังดูเหมือนใน Ruby"
ในบางภาษาโปรแกรม เช่น Ruby จะมี symbol เดียวต่อชื่อเดียว

ใน JavaScript อย่างที่เราเห็น เรื่องนั้นเป็นจริงสำหรับ global symbol
```

### Symbol.keyFor

เราเห็นแล้วว่าสำหรับ global symbol `Symbol.for(key)` คืน symbol ตามชื่อ ส่วนในทางกลับกัน เพื่อคืนชื่อโดยใช้ global symbol เราสามารถใช้: `Symbol.keyFor(sym)`:

ตัวอย่างเช่น:

```js run
// รับ symbol ตามชื่อ
let sym = Symbol.for("name");
let sym2 = Symbol.for("id");

// รับชื่อตาม symbol
alert( Symbol.keyFor(sym) ); // name
alert( Symbol.keyFor(sym2) ); // id
```

`Symbol.keyFor` ภายในจะใช้ global symbol registry เพื่อค้นหาคีย์ของ symbol ดังนั้นมันจะไม่ทำงานกับ non-global symbol ถ้า symbol ไม่ใช่แบบ global มันจะหาไม่เจอและคืน `undefined`

กล่าวคือ symbol ทุกตัวมีคุณสมบัติ `description`

ตัวอย่างเช่น:

```js run
let globalSymbol = Symbol.for("name");
let localSymbol = Symbol("name");

alert( Symbol.keyFor(globalSymbol) ); // name, global symbol
alert( Symbol.keyFor(localSymbol) ); // undefined, ไม่ใช่ global

alert( localSymbol.description ); // name
```

## System symbol

มี "system" symbol จำนวนมากที่ JavaScript ใช้ภายใน และเราสามารถใช้มันเพื่อปรับแต่งแง่มุมต่างๆ ของอ็อบเจ็กต์ได้

พวกมันอยู่ในสเปคที่ตาราง [Well-known symbols](https://tc39.github.io/ecma262/#sec-well-known-symbols):

- `Symbol.hasInstance`
- `Symbol.isConcatSpreadable`
- `Symbol.iterator`
- `Symbol.toPrimitive`
- ...และอื่นๆ

ตัวอย่างเช่น `Symbol.toPrimitive` ให้เราอธิบายการแปลงอ็อบเจ็กต์เป็นค่าพื้นฐาน (primitive) ได้ เราจะเห็นการใช้งานของมันเร็วๆ นี้

Symbol อื่นๆ ก็จะดูคุ้นเคยเมื่อเราศึกษาคุณลักษณะของภาษาที่เกี่ยวข้อง

## สรุป

`Symbol` เป็นชนิดข้อมูลพื้นฐานสำหรับตัวระบุเฉพาะ

Symbol ถูกสร้างโดยการเรียก `Symbol()` พร้อมคำอธิบาย (ชื่อ) เป็นตัวเลือก

Symbol จะมีค่าต่างกันเสมอ แม้จะมีชื่อเหมือนกัน ถ้าเราต้องการให้ symbol ที่มีชื่อเดียวกันมีค่าเท่ากัน เราควรใช้ global registry: `Symbol.for(key)` คืนค่า (สร้างถ้าจำเป็น) global symbol พร้อม `key` เป็นชื่อ การเรียก `Symbol.for` หลายครั้งด้วย `key` เดียวกันจะคืน symbol ตัวเดียวกันเสมอ

Symbol มีสองกรณีการใช้งานหลักๆ:

1. พร็อพเพอร์ตี้ของอ็อบเจ็กต์ที่ "ซ่อนอยู่"

    ถ้าเราอยากเพิ่มพร็อพเพอร์ตี้ลงในอ็อบเจ็กต์ที่ "เป็นของ" สคริปต์หรือไลบรารีอื่น เราสามารถสร้าง symbol และใช้เป็นคีย์ของพร็อพเพอร์ตี้ พร็อพเพอร์ตี้ symbol จะไม่ปรากฏใน `for..in` ดังนั้นมันจะไม่ถูกประมวลผลร่วมกับพร็อพเพอร์ตี้อื่นโดยไม่ตั้งใจ และจะไม่ถูกเข้าถึงโดยตรงเพราะสคริปต์อื่นไม่มี symbol ของเรา ดังนั้นพร็อพเพอร์ตี้จะได้รับการป้องกันจากการใช้โดยไม่ได้ตั้งใจหรือการถูกเขียนทับ

    เพราะฉะนั้นเราสามารถ "ซุกซ่อน" อะไรบางอย่างลงในอ็อบเจ็กต์ ซึ่งเราต้องการแต่คนอื่นไม่ควรเห็น โดยใช้พร็อพเพอร์ตี้ symbol

2. มี system symbol หลายตัวที่ JavaScript ใช้และเราสามารถเข้าถึงได้ผ่าน `Symbol.*` เราสามารถใช้มันเพื่อเปลี่ยนแปลงพฤติกรรมในตัวบางอย่าง ตัวอย่างเช่น ในบทเรียนต่อๆ ไป เราจะใช้ `Symbol.iterator` สำหรับ [iterable](info:iterable), `Symbol.toPrimitive` เพื่อตั้งค่า [การแปลงอ็อบเจ็กต์เป็นค่าพื้นฐาน](info:object-toprimitive) และอื่นๆ

ในทางเทคนิค symbol ไม่ได้ถูกซ่อนไว้ 100% มีเมท็อดในตัวอย่าง [Object.getOwnPropertySymbols(obj)](mdn:js/Object/getOwnPropertySymbols) ที่ให้เราเข้าถึง symbol ทั้งหมดได้ และมีเมท็อดอย่าง [Reflect.ownKeys(obj)](mdn:js/Reflect/ownKeys) ที่คืน *ทุก* คีย์ของอ็อบเจ็กต์ รวมถึง symbol ด้วย แต่ไลบรารีส่วนใหญ่ ฟังก์ชันในตัว และโครงสร้างวากยสัมพันธ์ไม่ได้ใช้เมท็อดเหล่านี้