# ชนิดข้อมูล Symbol

ในภาษา JavaScript นั้น มีเพียงชนิดข้อมูลพื้นฐานสองประเภทเท่านั้นที่สามารถใช้เป็น key ของ property ในออบเจ็กต์ได้ นั่นคือ:

- string และ
- symbol 

สำหรับชนิดข้อมูลอื่นๆ เช่น number เมื่อใช้เป็น key มันจะถูกแปลงเป็น string โดยอัตโนมัติ ซึ่งหมายความว่า `obj[1]` จะเท่ากับ `obj["1"]` และ `obj[true]` จะเท่ากับ `obj["true"]`

ที่ผ่านมา เราใช้แต่ string เป็น key มาโดยตลอด 

คราวนี้ลองมาทำความรู้จักกับ symbol และประโยชน์ของมันกันดูบ้าง

## Symbol คืออะไร

"Symbol" เป็นตัวแทนของ unique identifier หรือตัวระบุที่ไม่ซ้ำกัน

เราสามารถสร้างค่า symbol ได้โดยใช้ฟังก์ชัน `Symbol()` ดังนี้:

```js
let id = Symbol();
```

เวลาสร้าง symbol เรายังสามารถให้คำอธิบาย (description) หรือชื่อให้กับมันได้ด้วย ซึ่งส่วนใหญ่จะมีประโยชน์ในการดีบั๊ก:

```js
// id คือ symbol ที่มีคำอธิบายว่า "id"
let id = Symbol("id");
```

Symbol รับประกันว่าจะมีค่าไม่ซ้ำกันเสมอ ถึงแม้จะสร้าง symbol หลายตัวด้วยคำอธิบายเดียวกัน ค่าของมันก็จะไม่เหมือนกัน เพราะคำอธิบายเป็นเพียงป้ายชื่อ (label) ที่ไม่ได้กำหนดค่าจริงของ symbol แต่อย่างใด 

ยกตัวอย่างเช่น symbol สองตัวด้านล่างนี้ แม้จะมีคำอธิบายเหมือนกัน แต่ค่าจะไม่เท่ากัน:

```js run
let id1 = Symbol("id");
let id2 = Symbol("id");

*!*
alert(id1 == id2); // false
*/!*
```

ถ้าคุณคุ้นเคยกับ symbol ในภาษา Ruby หรือภาษาอื่นที่มีแนวคิดคล้ายๆ กัน อย่าสับสน เพราะ symbol ใน JavaScript นั้นแตกต่างออกไป

โดยสรุปคือ symbol คือค่าพื้นฐานที่ unique ซึ่งอาจมี description กำกับไว้ก็ได้ มาดูกันว่าเราจะประยุกต์ใช้มันได้อย่างไรบ้าง

````warn header="Symbol ไม่ถูกแปลงเป็น string โดยอัตโนมัติ"
ค่าส่วนใหญ่ใน JavaScript รองรับการถูกแปลงเป็น string โดยอัตโนมัติ เช่น เราสามารถ `alert(value)` ค่าอะไรก็ได้ออกมา และมันจะทำงาน

แต่ symbol นั้นพิเศษกว่า มันจะไม่ยอมถูกแปลงเป็น string โดยอัตโนมัติ เช่นถ้าเรา alert symbol ตรงๆ แบบนี้:

```js run
let id = Symbol("id");
*!*
alert(id); // TypeError: ไม่สามารถแปลง Symbol เป็น string ได้
*/!*
```

จะเกิด error ขึ้น เพราะภาษาต้องการป้องกันไม่ให้เราแปลง string และ symbol ให้กันและกันโดยไม่ตั้งใจ เนื่องจากมันเป็นคนละประเภทกันโดยสิ้นเชิง

ถ้าเราต้องการจะแสดง symbol จริงๆ เราต้องเรียกเมท็อด `.toString()` อย่างชัดเจน แบบนี้:

```js run
let id = Symbol("id");
*!*
alert(id.toString()); // Symbol(id) ตอนนี้โอเคแล้ว
*/!*
```

หรือถ้าเราอยากได้แค่ description ของ symbol ก็ใช้ `.description` ได้:

```js run
let id = Symbol("id");
*!*
alert(id.description); // id
*/!*
```
````

## Property ที่ "ซ่อนอยู่"

Symbol ช่วยให้เราสร้าง "hidden" property ใส่ในออบเจ็กต์ได้ โดยที่โค้ดส่วนอื่นๆ จะไม่สามารถเข้าถึงหรือเขียนทับโดยไม่ได้ตั้งใจ

สมมติว่าเรากำลังทำงานกับออบเจ็กต์ `user` ซึ่งเป็นของโค้ดจากที่อื่นมา แล้วเราอยากเพิ่ม identifier ใส่ลงไป เพื่อให้ identifier นั้นไม่ไปซ้ำกับ property ที่มีอยู่แล้ว เราเลยใช้ symbol แทนการใช้ชื่อ string ปกติ:

```js run
let user = { // เป็นของโค้ดจากที่อื่น
  name: "John"
};

let id = Symbol("id");

user[id] = 1;

alert( user[id] ); // เราสามารถเข้าถึงข้อมูลโดยใช้ symbol เป็น key
```

ข้อดีของการใช้ `Symbol("id")` แทนที่จะเป็น `"id"` string ธรรมดาคือ มันจะไม่ไปทับ property ที่มีอยู่ก่อน

เนื่องจากออบเจ็กต์ `user` เป็นของคนอื่น การไปเพิ่ม field ใหม่ลงไปในนั้นโดยตรงอาจไม่ปลอดภัย เพราะอาจไปขัดแย้งกับลอจิกที่เขาเขียนไว้ได้ แต่ symbol จะไม่มีทางถูกเข้าถึงจากโค้ดอื่นโดยบังเอิญ เพราะโค้ดอื่นจะไม่มี symbol ตัวนี้ ดังนั้นเราจึงสามารถใช้ symbol เพิ่มอะไรลงไปในออบเจ็กต์ `user` ได้อย่างปลอดภัย  

จินตนาการว่า ถ้ามีอีกสคริปต์นึงอยากใช้ identifier ของมันเองกับ `user` เพื่อวัตถุประสงค์บางอย่าง สคริปต์นั้นก็แค่สร้าง `Symbol("id")` ของมันเอง ดังนี้:

```js
// ...
let id = Symbol("id");

user[id] = "ไอดีของสคริปต์นั้น";
```

ไม่มีการชนกันเกิดขึ้นระหว่าง identifier ของเรากับของอีกสคริปต์ เพราะ symbol จะไม่ซ้ำกันเสมอ แม้จะใช้ชื่อคำอธิบายเดียวกันก็ตาม

...แต่ถ้าเราใช้ string `"id"` ตรงๆ แทนที่จะเป็น symbol ในกรณีนี้ มันก็*จะ* เกิดการชนกันขึ้นแน่ๆ:

```js
let user = { name: "John" };

// สคริปต์ของเราใช้ property "id" 
user.id = "ไอดีของเรา";

// ...สคริปต์อื่นก็อยากใช้ "id" เหมือนกัน

user.id = "ไอดีของอีกสคริปต์"
// บูม! โดนสคริปต์อื่นเขียนทับแล้ว!
```

### ใช้ Symbol ใน Object Literal

ถ้าเราต้องการใช้ symbol ใน object literal `{...}` จะต้องครอบมันไว้ด้วยวงเล็บก้ามปู (square bracket) แบบนี้:

```js
let id = Symbol("id");

let user = {
  name: "John",
*!*
  [id]: 123 // ไม่ใช่ "id": 123
*/!*
};
```

เพราะเราต้องการใช้ค่าที่เก็บอยู่ในตัวแปร `id` เป็น key ไม่ใช่ string "id"

### Symbol จะถูกข้ามโดย for..in

Property ที่เป็น symbol จะไม่เข้าร่วมในการ loop `for..in` 

ลองดูตัวอย่าง:

```js run
let id = Symbol("id");
let user = {
  name: "John",
  age: 30,
  [id]: 123
};

*!*
for (let key in user) alert(key); // name, age (ไม่มี symbol)
*/!*

// ถ้าเข้าถึงโดยตรง symbol ก็ยังใช้งานได้
alert( "Direct: " + user[id] ); // Direct: 123
```

`Object.keys(user)` ก็จะละเว้น symbol เช่นกัน นี่คือส่วนหนึ่งของหลักการ "ซ่อน symbol property" ที่ว่า ถ้ามีไลบรารีอื่นมา for..in ออบเจ็กต์ของเรา มันจะไม่เจอ property ที่เป็น symbol โดยไม่ได้ตั้งใจ

ในทางตรงกันข้าม `Object.assign` นั้นจะคัดลอกทั้ง string และ symbol property:

```js run
let id = Symbol("id");
let user = {
  [id]: 123
};

let clone = Object.assign({}, user);

alert( clone[id] ); // 123
```

ไม่มีอะไรแปลกตรงนี้ เพราะนั่นคือสิ่งที่มันถูกออกแบบมาให้ทำ แนวคิดคือ เวลาเรา clone หรือ merge ออบเจ็กต์ เราก็มักจะอยากให้มัน copy *ทุก* property (string และ symbol) นั่นเอง