# ชนิดข้อมูล Symbol

ตามข้อกำหนด มีเพียงชนิดข้อมูลพื้นฐานสองประเภทเท่านั้นที่สามารถใช้เป็นคีย์ของพร็อพเพอร์ตี้ในอ็อบเจ็กต์ได้:

- ชนิด string หรือ
- ชนิด symbol

มิฉะนั้น ถ้าใช้ชนิดอื่น เช่น number มันจะถูกแปลงเป็น string โดยอัตโนมัติ เพื่อให้ `obj[1]` เหมือนกับ `obj["1"]` และ `obj[true]` เหมือนกับ `obj["true"]` 

จนถึงตอนนี้ เราใช้แต่ string มาตลอด 

ตอนนี้มาสำรวจ symbol กันดูว่ามันมีประโยชน์อย่างไรบ้าง

## Symbol

"Symbol" แทนตัวระบุที่ไม่ซ้ำกัน (unique identifier)

ค่าของชนิดนี้สร้างได้โดยใช้ `Symbol()`:

```js
let id = Symbol();
```

เมื่อสร้าง เราสามารถให้คำอธิบาย (หรือเรียกว่าชื่อ symbol) ซึ่งส่วนใหญ่มีประโยชน์ในการดีบั๊ก:

```js
// id คือ symbol ที่มีคำอธิบายว่า "id"
let id = Symbol("id");
```

Symbol ได้รับการรับประกันว่าจะมีค่าไม่ซ้ำกัน แม้เราจะสร้าง symbol หลายตัวด้วยคำอธิบายเหมือนกันก็ตาม มันจะมีค่าที่แตกต่างกัน คำอธิบายเป็นเพียงป้ายกำกับที่ไม่ส่งผลอะไร

ตัวอย่างเช่น ต่อไปนี้คือ symbol สองตัวที่มีคำอธิบายเหมือนกัน -- แต่ไม่เท่ากัน:

```js run
let id1 = Symbol("id");
let id2 = Symbol("id");

*!*
alert(id1 == id2); // false
*/!*
```

ถ้าคุณคุ้นเคยกับ Ruby หรือภาษาอื่นที่มีอะไรบางอย่างคล้ายๆ "symbol" -- อย่าสับสน symbol ใน JavaScript นั้นแตกต่าง

สรุปคือ symbol เป็น "ค่าพื้นฐานที่ไม่ซ้ำกัน" ที่อาจมีคำอธิบายกำกับ มาดูกันว่าเราจะใช้มันที่ไหนได้บ้าง

````warn header="Symbol ไม่แปลงเป็น string โดยอัตโนมัติ"
ค่าส่วนใหญ่ใน JavaScript รองรับการแปลงเป็น string แบบโดยปริยาย เช่น เราสามารถ `alert` ค่าเกือบทุกอย่าง และมันจะทำงาน แต่ symbol นั้นพิเศษ จะไม่ถูกแปลงโดยอัตโนมัติ

เช่น `alert` นี้จะแสดงข้อผิดพลาด:

```js run
let id = Symbol("id");
*!*
alert(id); // TypeError: ไม่สามารถแปลงค่า Symbol เป็น string ได้ 
*/!*
```

นี่คือ "การป้องกันของภาษา" เพื่อหลีกเลี่ยงความผิดพลาด เพราะ string และ symbol นั้นแตกต่างกันโดยพื้นฐาน และไม่ควรแปลงเป็นกันและกันโดยไม่ได้ตั้งใจ

หากเราต้องการแสดง symbol ออกมาจริงๆ เราต้องเรียก `.toString()` กับมันอย่างชัดเจน แบบนี้:

```js run
let id = Symbol("id");
*!*
alert(id.toString()); // Symbol(id), ตอนนี้ทำงานแล้ว
*/!*  
```

หรือใช้คุณสมบัติ `symbol.description` เพื่อแสดงแค่คำอธิบาย:

```js run
let id = Symbol("id");
*!*
alert(id.description); // id  
*/!*
```
````

## พร็อพเพอร์ตี้ที่ "ซ่อนอยู่"

Symbol ช่วยให้เราสร้างพร็อพเพอร์ตี้ที่ "ซ่อนอยู่" ในอ็อบเจ็กต์ได้ โดยที่ส่วนอื่นของโค้ดจะไม่สามารถเข้าถึงหรือเขียนทับโดยไม่ได้ตั้งใจ

ยกตัวอย่างเช่น สมมติเรากำลังทำงานกับอ็อบเจ็กต์ `user` ที่เป็นของโค้ดจากที่อื่น เราอยากเพิ่มตัวระบุ (identifier) ให้มัน

เรามาใช้ symbol เป็นคีย์กัน:

```js run
let user = { // เป็นของโค้ดอื่น  
  name: "John"
};

let id = Symbol("id");

user[id] = 1;

alert( user[id] ); // เราสามารถเข้าถึงข้อมูลได้โดยใช้ symbol เป็นคีย์
```  

ข้อดีของการใช้ `Symbol("id")` เหนือกว่า string `"id"` คืออะไร?

เนื่องจากอ็อบเจ็กต์ `user` เป็นของโค้ดอื่น การเพิ่มฟิลด์ (field) ใหม่ลงไปจึงไม่ปลอดภัย เพราะเราอาจกระทบพฤติกรรมที่กำหนดไว้ล่วงหน้าในโค้ดอื่นนั้น อย่างไรก็ตาม symbol จะไม่สามารถเข้าถึงได้โดยบังเอิญ โค้ดบุคคลที่สามจะไม่รู้เกี่ยวกับ symbol ที่พึ่งกำหนดขึ้นใหม่ ดังนั้นจึงปลอดภัยที่จะเพิ่ม symbol ลงในอ็อบเจ็กต์ `user`  

สมมติอีกว่า สคริปต์อื่นอยากใช้ตัวระบุของตัวเองใน `user` เพื่อจุดประสงค์อะไรสักอย่าง

สคริปต์นั้นก็สามารถสร้าง `Symbol("id")` ของตัวเองได้ แบบนี้:  

```js
// ...
let id = Symbol("id");

user[id] = "ค่า id ของพวกเขา";
```

จะไม่เกิดการขัดแย้งระหว่างตัวระบุของเราและของพวกเขา เพราะ symbol จะต่างกันเสมอ แม้จะมีชื่อเหมือนกันก็ตาม

...แต่ถ้าเราใช้ string `"id"` แทน symbol สำหรับจุดประสงค์เดียวกัน ก็*จะ*เกิดการขัดแย้ง:

```js
let user = { name: "John" };  

// สคริปต์ของเราใช้คุณสมบัติ "id"
user.id = "ค่า id ของเรา"; 

// ...สคริปต์อื่นก็ต้องการ "id" เพื่อจุดประสงค์ของตัวเอง...

user.id = "ค่า id ของพวกเขา"  
// บูม! ถูกสคริปต์อื่นเขียนทับแล้ว! 
```

### Symbol ใน object literal

ถ้าเราต้องการใช้ symbol ใน object literal `{...}` เราต้องครอบมันด้วยวงเล็บก้ามปู (square brackets)

แบบนี้:

```js
let id = Symbol("id");

let user = {
  name: "John",
*!*
  [id]: 123 // ไม่ใช่ "id": 123
*/!*
};  
```

เพราะเราต้องการค่าจากตัวแปร `id` เป็นคีย์ ไม่ใช่ string "id"

### Symbol ถูกข้ามโดย for..in

พร็อพเพอร์ตี้ symbol จะไม่มีส่วนร่วมใน loop `for..in` 

ตัวอย่างเช่น:

```js run
let id = Symbol("id");
let user = {
  name: "John",
  age: 30,
  [id]: 123
};

*!*  
for (let key in user) alert(key); // name, age (ไม่มี symbol)
*/!*

// การเข้าถึงโดยตรงด้วย symbol จะใช้งานได้
alert( "Direct: " + user[id] ); // Direct: 123
```

[Object.keys(user)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys) ก็ละเว้น symbol ด้วย นี่คือส่วนหนึ่งของหลักการ "ซ่อนพร็อพเพอร์ตี้ symbol" ถ้าสคริปต์หรือไลบรารีอื่นวนลูปอ็อบเจ็กต์ของเรา มันจะไม่เจอพร็อพเพอร์ตี้ symbol โดยไม่คาดคิด

ตรงข้ามกัน [Object.assign](mdn:js/Object/assign) คัดลอกทั้งพร็อพเพอร์ตี้ string และ symbol:

```js run
let id = Symbol("id");
let user = {
  [id]: 123
};

let clone = Object.assign({}, user);

alert( clone[id] ); // 123
```

ไม่มีความขัดแย้งที่นี่ นั่นคือสิ่งที่ออกแบบไว้ แนวคิดคือ เมื่อเราโคลนอ็อบเจ็กต์หรือรวมอ็อบเจ็กต์ เรามักต้องการให้*ทุก*พร็อพเพอร์ตี้ถูกคัดลอก (รวมถึง symbol อย่าง `id` ด้วย)

## Global symbol

อย่างที่เห็น ปกติ symbol ทุกตัวจะต่างกัน แม้จะมีชื่อเหมือนกันก็ตาม แต่บางครั้งเราอยากให้ symbol ที่มีชื่อเดียวกันนั้นเป็นอันเดียวกัน เช่น ส่วนต่างๆ ของแอปของเราต้องการเข้าถึง symbol `"id"` โดยหมายถึงพร็อพเพอร์ตี้เดียวกันพอดี

เพื่อทำแบบนั้น มี *global symbol registry* เราสามารถสร้าง symbol ไว้ในนั้น และเข้าถึงมันได้ภายหลัง โดยมันรับประกันว่าการเข้าถึงโดยชื่อเดียวกันซ้ำๆ จะคืน symbol ตัวเดียวกันแน่นอน  

ในการอ่าน (สร้างถ้าไม่มี) symbol จาก registry ให้ใช้ `Symbol.for(key)`

การเรียกนั้นจะตรวจสอบ global registry และถ้ามี symbol อธิบายด้วย `key` ก็จะคืน symbol นั้น ไม่งั้นจะสร้าง symbol ใหม่ `Symbol(key)` และเก็บไว้ใน registry ด้วย `key` ที่ระบุ

ตัวอย่างเช่น:

```js run
// อ่านจาก global registry  
let id = Symbol.for("id"); // ถ้า symbol ไม่มีอยู่ ก็จะสร้างขึ้นมา

// อ่านอีกครั้ง (อาจจากส่วนอื่นของโค้ด)
let idAgain = Symbol.for("id");

// คือ symbol ตัวเดียวกัน
alert( id === idAgain ); // true
```

Symbol ภายใน registry เรียกว่า *global symbol* ถ้า