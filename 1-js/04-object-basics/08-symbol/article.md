# Symbol ชนิดข้อมูล

ตามข้อกำหนด มีเพียงข้อมูลชนิดพื้นฐาน (primitive) สองชนิดที่ใช้เป็นคีย์ (key) ของคุณสมบัติ (property) ในออบเจ็กต์ได้:

- string หรือ
- symbol 

มิฉะนั้น หากใช้ชนิดอื่น เช่น number มันจะถูกแปลงเป็น string โดยอัตโนมัติ ดังนั้น `obj[1]` จะเหมือนกับ `obj["1"]` และ `obj[true]` จะเหมือนกับ `obj["true"]`

จนถึงตอนนี้เราใช้แต่ string มาตลอด

ตอนนี้มาสำรวจ symbol กัน ดูว่ามันทำอะไรให้เราได้บ้าง

## Symbol

"Symbol" แทนตัวระบุเฉพาะ (unique identifier)

ค่าของชนิดนี้สามารถสร้างได้โดยใช้ `Symbol()`:

```js
let id = Symbol();
```

เมื่อสร้าง เราสามารถให้คำอธิบาย (เรียกอีกอย่างว่าชื่อ symbol) ซึ่งมักจะมีประโยชน์สำหรับการดีบั๊ก:

```js
// id เป็น symbol ที่มีคำอธิบายว่า "id"
let id = Symbol("id");
```

Symbol ได้รับการรับประกันว่าเป็นค่าเฉพาะเสมอ แม้ว่าเราจะสร้าง symbol ด้วยคำอธิบายเหมือนกันหลายตัว พวกมันก็จะเป็นค่าที่แตกต่างกัน คำอธิบายเป็นแค่ป้ายกำกับที่ไม่ส่งผลอะไร

ตัวอย่างเช่น ที่นี่มี symbol สองตัวที่มีคำอธิบายเหมือนกัน -- แต่พวกมันไม่เท่ากัน:

```js run
let id1 = Symbol("id");
let id2 = Symbol("id");

*!*
alert(id1 == id2); // false
*/!*
```

ถ้าคุณคุ้นเคยกับ Ruby หรือภาษาอื่นที่มีบางอย่างคล้ายๆ "symbol" โปรดอย่าสับสน symbol ใน JavaScript นั้นแตกต่าง 

ดังนั้น โดยสรุปแล้ว symbol เป็น "ค่าพื้นฐานที่เป็นเอกลักษณ์" ที่อาจมีคำอธิบายกำกับ มาดูกันว่าเราสามารถใช้มันที่ไหนได้บ้าง

````warn header="Symbol ไม่ถูกแปลงเป็น string โดยอัตโนมัติ"
ค่าส่วนใหญ่ใน JavaScript สนับสนุนการแปลงเป็น string แบบโดยนัย (implicit) เช่น เราสามารถใช้ `alert` กับค่าเกือบทุกอย่าง และมันจะทำงาน symbol นั้นพิเศษ พวกมันไม่แปลงเป็น string อัตโนมัติ

ตัวอย่างเช่น `alert` นี้จะแสดง error:

```js run
let id = Symbol("id");
*!*
alert(id); // TypeError: Cannot convert a Symbol value to a string
*/!*
```

นี่เป็น "การป้องกันของภาษา" เพื่อป้องกันความผิดพลาด เพราะ string และ symbol นั้นแตกต่างกันโดยสิ้นเชิง และไม่ควรแปลงเป็นกันและกันโดยไม่ได้ตั้งใจ

ถ้าเราต้องการแสดง symbol จริงๆ เราต้องเรียก `.toString()` กับมันอย่างชัดเจน เช่นนี้:

```js run
let id = Symbol("id");
*!*
alert(id.toString()); // Symbol(id), ตอนนี้ทำงานแล้ว
*/!*
```

หรือใช้คุณสมบัติ `symbol.description` เพื่อแสดงเฉพาะคำอธิบาย:

```js run
let id = Symbol("id");
*!*
alert(id.description); // id
*/!*
```
````

## คุณสมบัติที่ "ซ่อนอยู่"

Symbol ช่วยให้เราสร้างคุณสมบัติที่ "ซ่อนอยู่" ของออบเจ็กต์ได้ ซึ่งส่วนอื่นของโค้ดจะไม่สามารถเข้าถึงหรือเขียนทับโดยบังเอิญ

ตัวอย่างเช่น ถ้าเรากำลังทำงานกับออบเจ็กต์ `user` ที่มาจากโค้ดของบุคคลที่สาม เราอยากเพิ่มตัวระบุ (identifier) ให้กับมัน

เรามาใช้ symbol เป็นคีย์สำหรับเรื่องนี้กัน:

```js run
let user = { // เป็นของโค้ดอื่น
  name: "John"
};

let id = Symbol("id");

user[id] = 1;

alert( user[id] ); // เราสามารถเข้าถึงข้อมูลโดยใช้ symbol เป็นคีย์ได้
```

ประโยชน์ของการใช้ `Symbol("id")` มีอะไรบ้างเหนือกว่าใช้ string `"id"`?

เนื่องจากออบเจ็กต์ `user` เป็นของโค้ดฐานอื่น มันจึงไม่ปลอดภัยที่จะเพิ่มฟิลด์ (field) ให้กับมัน เพราะเราอาจไปกระทบพฤติกรรมที่กำหนดไว้ก่อนในโค้ดฐานอื่นนั้น อย่างไรก็ตาม symbol ไม่สามารถถูกเข้าถึงได้โดยบังเอิญ โค้ดของบุคคลที่สามจะไม่ทราบถึง symbol ที่เพิ่งถูกกำหนดขึ้นใหม่ ดังนั้นจึงปลอดภัยที่จะเพิ่ม symbol ให้กับออบเจ็กต์ `user`

นอกจากนี้ ลองจินตนาการว่า script อื่นอยากมีตัวระบุของตัวเองอยู่ใน `user` เพื่อจุดประสงค์ของมันเอง

script นั้นก็สามารถสร้าง `Symbol("id")` ของตัวมันเองได้ แบบนี้:

```js
// ...
let id = Symbol("id");

user[id] = "ค่า id ของพวกเขา";
```

จะไม่มีการขัดแย้งกันระหว่างตัวระบุของเรากับของพวกเขา เพราะ symbol จะต่างกันเสมอ แม้ว่าจะมีชื่อเหมือนกันก็ตาม

...แต่ถ้าเราใช้ string `"id"` แทน symbol สำหรับจุดประสงค์เดียวกัน ก็*จะ*เกิดการขัดแย้ง:

```js
let user = { name: "John" };

// script ของเราใช้คุณสมบัติ "id"
user.id = "ค่า id ของเรา";

// ...script อื่นก็อยากใช้ "id" สำหรับจุดประสงค์ของพวกเขา...

user.id = "ค่า id ของพวกเขา"
// บูม! ถูก script อื่นเขียนทับ!
```

### Symbol ใน object literal

ถ้าเราอยากใช้ symbol ใน object literal `{...}` เราต้องใส่วงเล็บเหลี่ยม (square brackets) ครอบมัน

แบบนี้:

```js
let id = Symbol("id");

let user = {
  name: "John",
*!*
  [id]: 123 // ไม่ใช่ "id": 123
*/!*
};
```

เพราะเราต้องการใช้ค่าจากตัวแปร `id` เป็นคีย์ ไม่ใช่ string "id"

### Symbol จะถูกข้ามโดย for..in

คุณสมบัติ symbol จะไม่มีส่วนร่วมใน loop `for..in`

ตัวอย่างเช่น:

```js run
let id = Symbol("id");
let user = {
  name: "John",
  age: 30,
  [id]: 123
};

*!*
for (let key in user) alert(key); // name, age (ไม่มี symbol)
*/!*

// การเข้าถึงโดยตรงด้วย symbol จะใช้ได้
alert( "Direct: " + user[id] ); // Direct: 123
```

[Object.keys(user)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys) ก็ละเว้น symbol เช่นกัน นี่เป็นส่วนหนึ่งของหลักการ "ซ่อนคุณสมบัติ symbol" ถ้า script หรือไลบรารีอื่นวนรอบออบเจ็กต์ของเรา มันจะไม่เข้าถึงคุณสมบัติ symbol โดยไม่คาดคิด

ในทางตรงกันข้าม [Object.assign](mdn:js/Object/assign) คัดลอกทั้งคุณสมบัติ string และ symbol:

```js run
let id = Symbol("id");
let user = {
  [id]: 123
};

let clone = Object.assign({}, user);

alert( clone[id] ); // 123
```

ไม่มีความขัดแย้งใดๆ ที่นี่ เป็นไปตามที่ออกแบบไว้ แนวคิดคือ เมื่อเราโคลนออบเจ็กต์หรือผสานออบเจ็กต์ เรามักจะต้องการ*ทุก*คุณสมบัติถูกคัดลอก (รวมถึง symbol เช่น `id`)

## Global symbol

อย่างที่เราเห็น ปกติ symbol ทั้งหมดจะแตกต่างกัน แม้ว่าจะมีชื่อเหมือนกันก็ตาม แต่บางครั้งเราอยากให้ symbol ที่มีชื่อเดียวกันเป็น entity เดียวกัน ตัวอย่างเช่น ส่วนต่างๆ ของแอปพลิเคชันของเราอยากเข้าถึง symbol `"id"` โดยหมายถึงคุณสมบัติ

เดียวกันพอดี

เพื่อทำเช่นนั้น มี *global symbol registry* ให้ใช้ เราสามารถสร้าง symbol ในนั้น และเข้าถึงมันได้ในภายหลัง และมันรับประกันว่าการเข้าถึงซ้ำโดยใช้ชื่อเดียวกันจะคืน symbol ตัวเดียวกันเสมอ

เพื่ออ่าน (สร้างถ้าไม่มี) symbol จาก registry ให้ใช้ `Symbol.for(key)`

การเรียกนั้นจะตรวจสอบ global registry และถ้ามี symbol ที่มีคำอธิบายเป็น `key` ก็จะคืน symbol นั้น มิฉะนั้นจะสร้าง symbol ใหม่ `Symbol(key)` และเก็บไว้ใน registry ด้วย `key` ที่กำหนด

ตัวอย่างเช่น:

```js run
// อ่านจาก global registry
let id = Symbol.for("id"); // ถ้า symbol ไม่มีอยู่ มันจะถูกสร้างขึ้น

// อ่านอีกครั้ง (อาจจากส่วนอื่นของโค้ด)
let idAgain = Symbol.for("id");

// เป็น symbol เดียวกัน
alert( id === idAgain ); // true
```

Symbol ภายใน registry เรียกว่า *global symbol* ถ้าเราต้องการ symbol ระดับแอปพลิเคชัน ที่เข้าถึงได้จากทุกที่ในโค้ด -- นั่นคือจุดประสงค์ของมัน

```smart header="นั่นฟังดูเหมือน Ruby"
ในบางภาษาโปรแกรม เช่น Ruby จะมี symbol เดียวต่อชื่อเดียว

ใน JavaScript อย่างที่เราเห็น เรื่องนั้นเป็นจริงสำหรับ global symbol
```

### Symbol.keyFor

เราได้เห็นว่าสำหรับ global symbol `Symbol.for(key)` คืน symbol ด้วยชื่อ เพื่อทำในทางกลับกัน -- คืนชื่อโดย global symbol -- เราสามารถใช้ `Symbol.keyFor(sym)`:

ตัวอย่างเช่น:

```js run
// ได้ symbol ด้วยชื่อ
let sym = Symbol.for("name");
let sym2 = Symbol.for("id");

// ได้ชื่อด้วย symbol
alert( Symbol.keyFor(sym) ); // name
alert( Symbol.keyFor(sym2) ); // id
```

`Symbol.keyFor` ใช้ global symbol registry ภายในเพื่อมองหาคีย์สำหรับ symbol ดังนั้นมันจะไม่ทำงานกับ non-global symbol ถ้า symbol ไม่ใช่แบบ global มันจะไม่สามารถหาได้และจะคืน `undefined`

นั่นแสดงว่า symbol ทั้งหมดมีคุณสมบัติ `description`

ตัวอย่างเช่น:

```js run
let globalSymbol = Symbol.for("name");
let localSymbol = Symbol("name");

alert( Symbol.keyFor(globalSymbol) ); // name, global symbol
alert( Symbol.keyFor(localSymbol) ); // undefined, ไม่ใช่ global

alert( localSymbol.description ); // name
```

## System symbol

มี "system" symbol จำนวนมากที่ JavaScript ใช้ภายใน และเราสามารถใช้มันเพื่อปรับแต่งแง่มุมต่างๆ ของออบเจ็กต์ได้

พวกมันอยู่ในข้อกำหนดในตาราง [Well-known symbols](https://tc39.github.io/ecma262/#sec-well-known-symbols):

- `Symbol.hasInstance`
- `Symbol.isConcatSpreadable`
- `Symbol.iterator`
- `Symbol.toPrimitive`
- ...และอื่นๆ

ตัวอย่างเช่น `Symbol.toPrimitive` ช่วยให้เราอธิบายการแปลงออบเจ็กต์เป็นค่าปฐมภูมิ (primitive) ได้ เราจะเห็นการใช้งานของมันในเร็วๆ นี้

Symbol อื่นๆ ก็จะคุ้นเคยเมื่อเราศึกษาคุณลักษณะของภาษาที่เกี่ยวข้อง

## สรุป

`Symbol` เป็นชนิดข้อมูลพื้นฐานสำหรับตัวระบุที่เป็นเอกลักษณ์

Symbol ถูกสร้างโดยการเรียก `Symbol()` พร้อมคำอธิบาย (ชื่อ) ที่เป็นตัวเลือก 

Symbol จะมีค่าที่แตกต่างกันเสมอ แม้จะมีชื่อเดียวกัน ถ้าเราต้องการให้ symbol ที่มีชื่อเดียวกันนั้นเท่ากัน เราควรใช้ global registry: `Symbol.for(key)` จะคืน (สร้างถ้าจำเป็น) global symbol ที่มีชื่อ `key` การเรียก `Symbol.for` หลายครั้งด้วย `key` เดียวกันจะคืน symbol ตัวเดียวกันเสมอ

Symbol มีสองกรณีการใช้งานหลักๆ:

1. คุณสมบัติออบเจ็กต์ที่ "ซ่อนอยู่"

    ถ้าเราอยากเพิ่มคุณสมบัติลงในออบเจ็กต์ที่ "เป็นของ" script หรือไลบรารีอื่น เราสามารถสร้าง symbol และใช้เป็นคีย์ของคุณสมบัติได้ คุณสมบัติ symbol จะไม่ปรากฏใน `for..in` ดังนั้นมันจะไม่ถูกประมวลผลร่วมกับคุณสมบัติอื่นๆ โดยไม่ได้ตั้งใจ นอกจากนี้ script อื่นจะไม่สามารถเข้าถึงมันได้โดยตรง เพราะไม่มี symbol ของเรา ดังนั้นคุณสมบัตินั้นจะได้รับการปกป้องจากการใช้หรือเขียนทับโดยไม่ได้ตั้งใจ

    เพราะฉะนั้น เราสามารถ "ซุกซ่อน" อะไรบางอย่างเข้าไปในออบเจ็กต์ที่เราต้องการ แต่คนอื่นไม่ควรเห็น โดยใช้คุณสมบัติ symbol

2. มี system symbol จำนวนมากที่ JavaScript ใช้ซึ่งเข้าถึงได้จาก `Symbol.*` เราสามารถใช้พวกมันเพื่อเปลี่ยนแปลงพฤติกรรมในตัวบางอย่าง ตัวอย่างเช่น ในภายหลังของบทเรียน เราจะใช้ `Symbol.iterator` สำหรับ [iterable](info:iterable), `Symbol.toPrimitive` เพื่อตั้งค่า [การแปลงออบเจ็กต์เป็นค่าปฐมภูมิ](info:object-toprimitive) และอื่นๆ

ในทางเทคนิค symbol ไม่ได้ซ่อน 100% มีเมท็อดในตัวคือ [Object.getOwnPropertySymbols(obj)](mdn:js/Object/getOwnPropertySymbols) ที่ช่วยให้เราได้ symbol ทั้งหมด มีเมท็อดอื่นที่ชื่อ [Reflect.ownKeys(obj)](mdn:js/Reflect/ownKeys) ที่คืน *ทุก* คีย์ของออบเจ็กต์ รวมถึง symbol ด้วย แต่ไลบรารีส่วนใหญ่ ฟังก์ชันในตัว และโครงสร้างไวยากรณ์ไม่ได้ใช้เมท็อดเหล่านี้