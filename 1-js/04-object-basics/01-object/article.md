
# Object

ตามที่เราได้รู้จากบท <info:types> แล้วว่า JavaScript มีข้อมูลอยู่ 8 ชนิดด้วยกัน โดยจะมี 7 ชนิดที่เป็นข้อมูลแบบ "primitive" เนื่องจากเก็บค่าข้อมูลเพียงหน่วยเดียวเท่านั้น (อาจเป็นข้อความสตริงหรือตัวเลขหรืออะไรก็ตาม)

ในทางกลับกันข้อมูลชนิดที่ 8 คือ objects เป็นชนิดของข้อมูลที่เก็บกลุ่มข้อมูลที่ประกอบด้วยข้อมูลประเภทต่างๆ และข้อมูลที่มีความซับซ้อนมากขึ้น (โดยมี key เป็นตัวอ้างอิงถึงข้อมูลแต่ละตัวใน object) ในภาษา JavaScript มีการใช้แนวคิดของ object อยู่เต็มไปหมด ดังนั้นเราต้องเข้าใจหลักการของ object ให้ดีเสียก่อนที่จะศึกษาเรื่องอื่นๆ ของ JavaScript แบบลงลึกได้

เราสามารถสร้าง object ขึ้นมาได้ด้วยการสร้างวงเล็บปีกกา `{…}` โดยภายในวงเล็บปีกกา จะมีรายชื่อของ *property* ต่างๆ ที่อยู่ภายใน object นั้น โดย object หนึ่ง จะมี property กี่ตัวก็ได้ หรือไม่มีเลยสักตัวก็ได้  โดยโครงสร้าง property แต่ละตัวจะอยู่ในรูปคู่อันดับของ "key: value" มี `key` เป็นข้อความสตริง (เรียกว่า "property name") และ `value` จะเป็นข้อมูลประเภทใดก็ได้

เราอาจคิดเสียว่า object ก็เหมือนกับตู้ใส่เอกสารที่เก็บแฟ้มตู้หนึ่ง โดยที่แต่ละแฟ้มนั้นจะมีป้ายชื่อกำกับไว้ ในแต่ละแฟ้มก็จะมีข้อมูลเก็บอยู่โดยมี key กำกับไว้ เฟื่อให้ผู้ที่ต้องการใช้สามารถค้นหา หรือ เพิ่ม/ลบ แฟ้มได้โดยง่าย

![](object.svg)

เราสามารถสร้าง object ว่างๆ ขึ้นมาตัวหนึ่ง ("object ว่างๆ ก็เหมือนกับตู้เอกสารที่ยังไม่มีเอกสารอะไรเก็บอยู่เลย") ได้ด้วยการประกาศ object ซึ่งมีด้วยกันสองวิธี โดยใช้ syntax แบบใดแบบหนึ่งก็ได้จาก 2 แบบนี้:

```js
let user = new Object(); // "object constructor" syntax
let user = {};  // "object literal" syntax
```

![](object-user-empty.svg)

โดยทั่วไปจะใช้วิธีที่มีวงเล็บปีกกา `{...}` กันมากกว่า จะมีชื่อเรียกของการประกาศ object ด้วยวิธีนี้ว่า *object literal*

## Literal และ property

เราสามารถระบุ property ของ object ตอนที่เราประกาศ object นั้นเลยก็ได้ ด้วยการใส่ property เข้าไประหว่างปีกกาสองอัน `{...}` โดย property ที่ใส่จะต้องอยู่รูปแบบคู่อันดับของ "key: value":

```js
let user = {     // object
  name: "John",  // key ชื่อ "name" เก็บค่า "John"
  age: 30        // key ชื่อ "age" เก็บค่า 30
};
```

property แต่ละตัวจะมี key (หรือบางทีก็เรียกกันว่า "name" หรือ "identifier" ก็ได้) เขียนก่อนเครื่องหมาย colon `":"` และมี value เขียนอยู่ฝั่งขวาของเครื่องหมาย colon

object ชื่อ `user` ที่เราสร้างขึ้นมาประกอบไปด้วย property 2 ตัว:

1. property ตัวแรกมี key ชื่อว่า `"name"` และมี value เป็น String ที่มีข้อความว่า `"John"`
2. property ตัวที่สองมี key ชื่อว่า `"age"` แบะมี value เป็นเลขมีค่าเท่ากับ `30`

ทำให้เราสามารถเปรียบ object ที่ชื่อ `user` ที่มี property สองตัวนี้ เสมือนกับตู้เอกสาร และที่ประกอบไปด้วยแฟ้ม 2 แฟ้มที่มีป้ายชื่อกำกับไว้ว่า "name" และ "age"

![user object](object-user.svg)

เราสามารถ เพิ่ม ลบและอ่านแฟ้มในตู้นี้ได้ตลอดเวลา

โดยเราเรียกใช้ value ของ property (ก็คือข้อมูลในแฟ้มเอกสาร) โดยการใช้ dot notation ดังนี้:

```js
// alert ค่า value ของ property ใน object:
alert( user.name ); // John
alert( user.age ); // 30
```

ข้อมูลที่เก็บในแฟ้มจะเป็นข้อมูลชนิดไหนก็ได้ ทีนี้เราจะลองเพิ่มข้อมูลชนิด boolean เข้าไป 1 ตัว:

```js
user.isAdmin = true;
```

![user object 2](object-user-isadmin.svg)

ถ้าต้องการลบ property ตัวใดตัวหนึ่งออกจาก `object` เราสามารถใช้คำสั่ง delete เพื่อลบ property ตัวนั้นออกไป:

```js
delete user.age;
```

![user object 3](object-user-delete.svg)

เราสามารถตั้งชื่อของ property เป็นชื่อแบบ  multiword ก็คือชื่อที่มีคำหลายๆ คำที่แยกกันด้วยช่องว่างได้ แต่ทุกคำที่เป็นชื่อนั้นจะต้องอยู่ในเครื่องหมายคำพูดเดียวกัน:

```js
let user = {
  name: "John",
  age: 30,
  "likes birds": true  // ชื่อ property แบบ multiword ต้องอยู่ในเครื่องหมายคำพูด
};
```

![](object-user-props.svg)


เราสามารถใส่เครื่องหมาย comma ตามหลัง property ตัวสุดท้ายก็ได้:
```js
let user = {
  name: "John",
  age: 30*!*,*/!*
}
```
เครื่องหมาย comma ที่ปิดท้าย property ตัวหลังสุดเรียกว่า "trailing" หรือ "hanging" comma ทำให้เรา เพิ่ม/ลบ/ย้ายลำดับ propperty ได้ง่ายขึ้น เนื่องจากแต่ละบรรทัดจะมีเครื่องหมาย comma ปิดท้ายเหมือนกันทุกบรรทัด

## Square brackets

เราไม่สามารถใช้ dot notation เรียกใช้ property แบบ multiword ได้:

```js run
// เกิด syntax error
user.likes birds = true
```

JavaScript ไม่เข้าใจคำสั่งนี้ เนื่องจาก JavaScript จะเข้าใจไปว่าเราต้องการใช้ค่าข้อมูลจาก `user.likes` ทำให้เกิด syntax error เมื่อพบคำว่า `birds` ซึ่งเป็นข้อความที่ทำให้โปรแกรมไม่สามารถแปลภาษาต่อไปได้

การใช้ dot notation เพื่อเข้าถึง property ต่างๆ ของ object หลังจากชื่อ objct และเครื่องหมาย dot จะต้องต่อด้วย key ของ property ที่ถูกต้องตามรูปแบบของการตั้งชื่อตัวแปร กล่าวคือ: ห้ามมีวรรค ไม่ขึ้นต้นด้วยตัวเลข และไม่มีอักขระพิเศษ (ยกเว้นเครื่องหมาย `$` กับ `_` สองตัวที่สามารถมีได้)

ด้วยเหตุนี้ จึงมีอีกวิธีในการเข้าถึง property ของ object ก็คือใช้วงเล็บเหลี่ยม หรือ "square bracket notation" โดยวิธีนี้สามารถใช้ได้กับชื่อ property แบบ multiword:

```js run
let user = {};

// กำหนดค่า
user["likes birds"] = true;

// อ่านค่า
alert(user["likes birds"]); // true

// ลบ
delete user["likes birds"];
```

ถึงตอนนี้เราก็สามารถเรียกใช้งาน property ทีมีชื่อเป็น multiword ได้แล้ว ต้องระวังว่า ข้อความสตริงในวงเล็บเหลี่ยมนี้จะต้องต้องอยู่ภายในระหว่างเครื่องหมายคำพูดหรือเครื่องหมายอัญประกาศ (จะใช้เครื่องหมายคำพูดแบบฟันเดี่ยว-single quoe หรือแบบฟันคู่-doule quoteก็ได้)

นอกจากนี้เรายังสามารถใช้วงเล็บเหลี่ยมเพื่ออ้างถึงชื่อของ property จากผลลัพธ์ของกระบวนการอะไรสักอย่างได้ แทนที่ใส่ชื่อเป็นข้อความตัวอักษรตายตัว คล้ายๆ กับว่าเราตั้งตัวแปรตัวหนึ่งขึ้นมาเพื่ออ้างถึงชื่อของ property ดังตัวอย่างข้างล่างนี้:

```js
let key = "likes birds";

// เหมือนกันกับ user["likes birds"] = true;
user[key] = true;
```

ตามตัวอย่างข้างบนนี้ ตัวแปร `key` อาจถูกกำหนดค่าขึ้นมาตอน run-time หรือจะเป็นการรับค่าจาก user ใส่เข้ามาก็ได้  จากนั้นก็ใช้ค่าของตัวแปรเพื่อเข้าถึง property คุณสมบัติที่ว่ามานี้ทำให้เกิดความยึดหยุ่นในการใช้งานมากทีเดียว

ตัวอย่างเช่น:

```js run
let user = {
  name: "John",
  age: 30
};

let key = prompt("คุณต้องการทราบข้อมูลใดของ user?", "name");

// เข้าถึงข้อมูลด้วยตัวแปร
alert( user[key] ); // John (กรณีที่ผู้ใช้งานป้อนค่า "name")
```

แต่การนำตัวแปรมาใช้แทนชื่อของ property นี้ จะใช้ในวิธีแบบ dot notation ไม่ได้:

```js run
let user = {
  name: "John",
  age: 30
};

let key = "name";
alert( user.key ) // undefined
```

### Computed property

ตอนที่ประกาศ object เราสามารถใช้วงเล็บเหลี่ยมใน object literal ได้ เรียกว่า *computed propertiy*

ตัวอย่างเช่น:

```js run
let fruit = prompt("ซื้อผลไม้อะไรดี?", "apple");

let bag = {
*!*
  [fruit]: 5, // ชื่อของ property จะรับมาจาก ตัวแปร fruit
*/!*
};

alert( bag.apple ); // 5 กรณีที่ fruit="apple"
```

การใช้งาน computed property ในลักษณะนี้ก็เข้าใจได้ไม่ยาก: `[fruit]` หมายถึง ชื่อของ property ซึ่งชื่อนี้จะถูกตั้งตามค่าของตัวแปร `fruit` ที่รับค่าเข้ามา

ดังนั้นเมื่อผู้เยี่ยมชมเว็บไซต์ป้อนข้อมูลว่า `"apple"` ค่าของ `bag` จะเป็น `{apple: 5}`

หลักๆ แล้ว การทำงานจะเป็นไปตามนี้:
```js run
let fruit = prompt("Which fruit to buy?", "apple");
let bag = {};

// ใช้ชื่อ property จากตั้วแปร fruit
bag[fruit] = 5;
```

...แต่ดูดีกว่า

เราสามารถเขียนนิพจน์ที่ซับซ้อนในวงเล็บเหลี่ยมได้ด้วย:

```js
let fruit = 'apple';
let bag = {
  [fruit + 'Computers']: 5 // bag.appleComputers = 5
};
```

เราสามารถใช้งานวิธีแบบที่มีวงเล็บเหลี่ยมได้หลายแบบกว่าวิธีการ dot notation ทำให้เราสามารถตั้งชื่อ property และชื่อตัวแปรอย่างไรก็ได้ แต่การเขียนด้วยวิธีแบบวงเล็บเหลี่ยมมีความยุ่งยากมากกว่า

ดังนั้น หากชื่อ property เป็นชื่อตายตัวที่ทราบอยู่ก่อนแล้วและเป็นชื่อที่ไม่มีช่องว่าง เราจะใช้ dot เกือบจะทุกครั้ง แต่เมื่อไรก็ตามที่การอ้างอิงชื่อมีความซับซ้อนมากขึ้นเกินกว่าที่จะยังคงใช้แบบ dot ได้ เราก็จะเปลี่ยนมาใช้แบบวงเล็บเหลี่ยมแทน

## Property value shorthand

ในการเขียนโค้ดจริง เรามักใช้ชื่อตัวแปรสำหรับค่าของ property เป็นชื่อเดียวกันกับชื่อของ propperty นั้น

ตัวอย่างเช่น:

```js run
function makeUser(name, age) {
  return {
    name: name,
    age: age,
    // ...property อื่นๆ
  };
}

let user = makeUser("John", 30);
alert(user.name); // John
```

จากตัวอย่างข้างบน จะเห็นว่าชื่อของ property เป็นชื่อเดียวกันกับชื่อของตัวแปร ลักษณะการใช้งานที่สร้าง property ขึ้นจากตัวแปรนี้พบได้ทั่วไป จนทำให้มีวิธีการเขียน property แบบย่อขึ้นมาเป็นการเฉพาะ เรียกว่า *property value shorthand*

แทนที่จะเขียนว่า `name:name` เราสามารถเขียนแค่ `name` ตามนี้:

```js
function makeUser(name, age) {
*!*
  return {
    name, // เหมือนกับเขียนว่า name: name
    age,  // เหมือนกับเขียนว่า age: age
    // ...
  };
*/!*
}
```

เราสามารถเขียน property แบบปรกติและแบบ shorthands ใน object เดียวกันได้:

```js
let user = {
  name,  // เหมือนกับเขียนว่า name:name
  age: 30
};
```


## ข้อจำกัดการตั้งชื่อ property

เราได้ทราบกันดีแล้วว่า เราไม่สามารถตั้งชื่อตัวแปรให้เหมือนกับ reserved words คำใดๆ ของภาษาได้ เช่น คำว่า "for" "let" "return" เป็นต้น

แต่ข้อห้ามเหล่านี้ ไม่ได้ใช้ห้ามในการตั้งชื่อ property ของ object:

```js run
// สามารถตั้งชื่อ property เหล่านี้ได้
let obj = {
  for: 1,
  let: 2,
  return: 3
};

alert( obj.for + obj.let + obj.return );  // 6
```

โดยสรุป ไม่มีข้อจำกัดในการตั้งชื่อ property สามารถใช้เป็นข้อความสตริงหรือสัญลักษณ์ (identifier ชนิดพิเศษซึ่งจะกล่าวถึงภายหลัง) ก็ได้

หากใช้ข้อมูลชนิดอื่นเป็นชื่อ จะถูกแปลงเป็นข้อความสริงอัตโนมัติ

ตั้วอย่างเช่น ตัวเลข `0` จะกลายเป็นข้อความสตริง `"0"` เมื่อถูกใช้เป็น key ของ property:

```js run
let obj = {
  0: "test" // same as "0": "test"
};

// function alert ทั้ง 2 เข้าถึง property เดียวกัน (ตัวเลข 0 ถูกแปลงเป็นข้อความสตริง "0")
alert( obj["0"] ); // test
alert( obj[0] ); // test (ได้ property เดียวกัน)
```

มีข้อห้ามเล็กน้อยกับชื่อ property กรณีพิศษ ได้แก่ชื่อ `__proto__` โดยเราไม่สามารถใส่ค่าที่ไม่เป็น object ให้กับ property ตัวนี้ได้:

```js run
let obj = {};
obj.__proto__ = 5; // กำหนดค่าเป็นตัวเลข
alert(obj.__proto__); // [object Object] - ได้ค่าออกมาเป็น object ไม่ตรงกับที่ตั้งใจไว้
```

จากโค้ดจะเห็นว่า กำหนดค่าให้เป็น primitive `5` แต่ไม่เป็นผลสำเร็จ

เราจะกล่าวถึงความพิเศษของ `__proto__` ในบท [subsequent chapters](info:prototype-inheritance) และ [วิธีแก้](info:prototype-methods) ปัญหานี้

## การทดสอบ Property ด้วยตัวกำเนินการ "in"

คุณลักษณะหนึ่งของ object ในภาษา JavaScript ซึ่งไม่เหมือนกับในอีกหลายๆ   ภาษาที่ควรหมายเหตุไว้ได้แก่การที่สามารถเข้าถึง property ใดก็ได้ โดยที่จะไม่เกิด error ขึ้นแม้ว่า property นั้นไม่ถูกประกาศไว้ก่อนก็ตาม!

เราจะได้ค่า `undefined` เมื่ออ่านค่า property ที่ไม่มีอยู่ ดังนั้นเราสามารถทดสอบการมีอยู่ของ property ได้อย่างง่ายดังนี้:

```js run
let user = {};

alert( user.noSuchProperty === undefined ); // หากได้ค่า true หมายถึง "object user ไม่มี property ชื่อ noSuchProperty"
```

หรือจะเขียนโดยใช้ตัวกำเนินการ `"in"` ก็ได้

ดังนี้:
```js
"key" in object
```

ตัวอย่างเช่น:

```js run
let user = { name: "John", age: 30 };

alert( "age" in user ); // ได้ true เพราะ object user มี age
alert( "blabla" in user ); // ได้ false เพราะ object user ไม่มี blabla
```

โปรดทราบว่า ข้อมูลฝั่งซ้ายของ `in` ต้องเป็นชื่อของ property ซึ่งโดยปรกติแล้วจะเป็นข้อความสตริงอยู่ในเครื่องหมายคำพูด

หรือถ้าไม่เขียนแบบมีเครื่องหมายคำพูด ค่านั้นจะต้องเป็นตัวแปรซึ่งเก็บชื่อที่เราต้องการทดสอบ ตัวอย่างเช่น:

```js run
let user = { age: 30 };

let key = "age";
alert( *!*key*/!* in user ); // ได้ true เพราะ object user มี property "age"
```

เพราะเหตุใดจึงยังต้องมีตัวดำเนินการ `in` ให้ใช้อีก การเปรียบเทียบด้วยค่า `undefined` นั้นไม่เพียงพอหรืออย่างไร?

การเทียบด้วย `undefined` นั้นจะใช้ได้ในเกือบทุกกรณี แต่มีกรณีพิเศษที่ให้ผลไม่ถูกต้องจะต้องใช้ `"in"` แทน

ได้แก่ เมื่อ object มี property ที่เก็บค่าเป็น `undefined`:

```js run
let obj = {
  test: undefined
};

alert( obj.test ); // ได้ undefined แล้วจะสรุปว่าไม่มี property test ได้หรือไม่?

alert( "test" in obj ); // ได้ true obj มี property test!
```

ในโค้ดด้านบน property `obj.test` นั้นมีอยู่จริง ซึ่งกรณีนี้ตัวดำเนินการ `in` ทำงานได้ถูกต้อง

สถานการณ์เช่นนี้เกิดขึ้นน้อยมาก เนื่องจากค่า `undefined` นั้นไม่ควรที่จะกำหนดให้โดยตรง เราควรใช้ `null` ในการกำหนดสิ่งที่ยังไม่ทราบค่าหรือค่าว่าง ดังนั้นตัวดำเนินการ `in` จึงถูกใช้ในโค้ดน้อยมาก


## "for..in" ลูป

กรณีที่ต้องการวนลูปแต่ละ key ของ object เราใช้ลูปในรูปพิเศษได้แก่: `for..in` ซึ่งต่างกันกับลูปในรูปของ for ลูป `for(;;)` ที่เราได้เรียนรู้มาก่อนหน้านี้

syntax ดังนี้:

```js
for (key in object) {
  // ทำทุก key ของ property ใน object
}
```

ตัวอย่าง แสดงทุก property ของ `user`:

```js run
let user = {
  name: "John",
  age: 30,
  isAdmin: true
};

for (let key in user) {
  // แสดง key
  alert( key );  // ได้ name age และ isAdmin ตามลำดับ
  // แสดงค่าของแต่ละ key
  alert( user[key] ); // ได้ John 30 และ true ตามลำดับ
}
```

โปรดทราบว่า "for" ทุกแบบอนุญาตให้เราประกาศตัวแปรในลูปได้ จากตัวอย่างข้างบนได้แก่ `let key`

ดังนั้นเราจึงสามารถตั้งชื่อตัวแปรลูปเป็นอย่างอื่นนอกจาก `key` ก็ได้ เช่น `"for (let prop in obj)"` เป็นปบบที่ใช้กันอย่างกว้างขวาง

### การเรียงลำดับของ object

เมื่อทำการลูป object เราจะได้ property ตามลำดับที่เราประกาศไว้หรือไม่?

คำตอบอย่างสั้นคือ: "จะเรียงลำดับแบบพิเศษ": โดย interger property หรือ property ที่มี key เป็นค่าจำนวนเต็มจะถูกเรียงลำดับ ส่วน property ที่เหลือจะเรียงตามลำดับที่สร้าง

ตัวอย่าง พิจารณา object ที่เก็บค่ารหัสโทรศัพท์:

```js run
let codes = {
  "49": "Germany",
  "41": "Switzerland",
  "44": "Great Britain",
  // ..,
  "1": "USA"
};

*!*
for (let code in codes) {
  alert(code); // จะได้ 1, 41, 44, 49 ตามลำดับ
}
*/!*
```

object ด้านบนอาจถูกใช้เก็บตัวเลือกให้ user เลือก สมมติเรากำลังทำเว็บสำหรับชาวเยอรมันเป็นหลัก เราย่อมต้องการให้ `49` แสดงเป็นตัวเลือกแรก

แต่เมื่อเรารันโค้ดเรากลับได้ผลลำดับที่แตกต่างกันกับตอนประกาศอย่างสิ้นเชิง ดังนี้:

- USA (1) มาก่อน
- ตามด้วย Switzerland (41) และอื่นๆ ตามลำดับ

เนื่องมาจากรหัสโทรศัพท์มีค่าเป็นจำนวนเต็มถึงถูกเรียงลำดับจากน้อยไปมาก ดังนี้ `1, 41, 44, 49`

````smart header="Integer properties? What's that?"
คำว่า "integer property" ในที่นี้หมายถึงข้อความสตริงที่สามารถ แปลงเป็นและแปลงจาก จำนวนเต็มได้โดยค่าไม่เปลี่ยนไป

"49" เป็น key ชนิด integer property เพราะไม่ว่าจะแปลงไปหรือแปลงกลับก็จะได้ค่าเดิม แต่สำหรับ "+49" and "1.2" นั้นเมื่อแปลงไปมา จะไม่ได้ค่าเดิม ดังนี้:

```js run
// Math.trunc เป็น built-in function ใช้ตัดส่วนทศนิยมออก
alert( String(Math.trunc(Number("49"))) ); // ได้ "49" เหมือนเดิม เป็น integer property
alert( String(Math.trunc(Number("+49"))) ); // ได้ "49" ไม่เท่ากับ "+49" ⇒ ไม่เป็น integer property
alert( String(Math.trunc(Number("1.2"))) ); // ได้ "1" ไม่เท่ากับ "1.2" ⇒ ไม่เป็น integer property
```
````

...ในทางกลับกัน หาก key เป็นชนิด non-integer หรือก็คือไม่เป็นจำนวนเต็ม จะถูกเรียงตามลำดับของการประกาศ ตัวอย่างเช่น:

```js run
let user = {
  name: "John",
  surname: "Smith"
};
user.age = 25; // เพิ่ม property

*!*
// key ของ property เป็น non-integer จะถูกเรียงตามลำดับการประกาศ
*/!*
for (let prop in user) {
  alert( prop ); // ได้ name surname และ age ตามลำดับ
}
```

ดังนั้น เพื่อแก้ปัญหากรณีรหัสโทรศัพท์ เราสามารถ "โกง" ด้วยการทำให้ key เป็น non-integer โดยการเติมเครื่องหมายบวก `"+"` เข้าไป

Like this:

```js run
let codes = {
  "+49": "Germany",
  "+41": "Switzerland",
  "+44": "Great Britain",
  // ..,
  "+1": "USA"
};

for (let code in codes) {
  alert( +code ); // ได้ 49 41 44 และ 1 เป็นลำดับตามการประกาศ
}
```

ได้โค้ดที่ทำงานตามตั้งใจแล้ว

## สรุป

Object เป็น associative array พร้อมด้วยคุณลักษณะพิเศษหลายอย่าง

ใช้เก็บค่า property (ในรูปแบบคู่ของ key-value) ดังนี้:
- key ของ property ต้องเป็น ข้อความสตริงหรือสัญลักษณ์ (ปรกติจะเป็นข้อความสตริง)
- value เป็นค่าชนิดใดก็ได้

เราสามารถเข้าถึง property โดยการใช้งาน:
- dot notation: `obj.property`.
- วงเล็บเหลี่ยม `obj["property"]` ซึ่งยังอนุญาตให้เราแทนค่า key จากตัวแปร เช่น `obj[varWithKey]` ได้ด้วย

ตัวดำเนินการเพิ่มเติม:
- ลบ property ด้วยตัวกำเนินการ delete: `delete obj.prop`.
- ทดสอบว่ามี property ที่เราสนใจใน object หรือไม่ด้วยตัวดำเนินการ in: `"key" in obj`.
- วนลูปด้วย property ใน object: `for (let key in obj)`

สิ่งที่เราได้ศึกษากันในบทนี้เรียกว่า "plain object" หรือแค่ `Object` เฉยๆ ก็ได้

ยังมี object อยู่อีกหลายชนิดใน JavaScript:

- `Array` สำหรับเก็บข้อมูลเป็นชุดตามลำดับ
- `Date` สำหรับเก็บข้อมูลของวันที่และเวลา
- `Error` สำหรับเก็บข้อมูลของ error
- ...และอื่นๆ อีก

โดยแต่ละชนิดจะมีคุณลักษณะพิเศษที่เราจะศึกษากันต่อไป ในบางครั้งที่มีการพูดถึง "ข้อมูลชนิด array" "ข้อมูลชนิด date" นั้น โดยแท้จริงแล้วไม่ได้มีชนิดข้อมูลเหลานี้แต่อย่างใดแต่เป็นข้อมูลชนิดเดียวกันก็คือ object ซึ่งแต่ละแบบก็ต่อขยายคุณลักษณะเพิ่มเติมแตกต่างกันไป

Object ใน JavaScript มีประโยชน์มาก เราเพิ่งจะได้เรียนรู้หัวข้อที่มีขนาดใหญ่นี้เพียงผิวเผินเท่านั้น เราจะได้ใช้งาน object อยู่ตลอดและจะได้เรียนรู้เพิ่มเติมในส่วนอื่นๆ ของ tutorial ชุดนี้ต่อไปในภายหน้า
