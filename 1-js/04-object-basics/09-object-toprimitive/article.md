# การแปลงออบเจ็กต์เป็นค่าปฐมภูมิ

เมื่อออบเจ็กต์เกี่ยวข้องกับการดำเนินการ เช่น การบวก (`obj1 + obj2`), การลบ (`obj1 - obj2`), หรือการแสดงผลด้วย `alert(obj)`, JavaScript จะแปลงออบเจ็กต์เป็นค่าปฐมภูมิ (primitive) โดยอัตโนมัติก่อนที่จะทำการดำเนินการ

JavaScript ไม่อนุญาตให้กำหนดวิธีการทำงานของตัวดำเนินการบนออบเจ็กต์โดยตรง แตกต่างจากภาษาโปรแกรมอื่นๆ บางภาษา เช่น Ruby หรือ C++ เราไม่สามารถใช้เมท็อดพิเศษของออบเจ็กต์เพื่อจัดการการบวกหรือตัวดำเนินการอื่นๆ ได้

ในกรณีเหล่านี้ ออบเจ็กต์จะถูกแปลงเป็นค่าปฐมภูมิโดยอัตโนมัติ และจากนั้นการดำเนินการก็จะเกิดขึ้นบนค่าปฐมภูมิเหล่านี้ ส่งผลเป็นค่าปฐมภูมิ

นี่เป็นข้อจำกัดสำคัญ: ผลลัพธ์ของ `obj1 + obj2` (หรือการดำเนินการทางคณิตศาสตร์อื่นๆ) ไม่สามารถเป็นออบเจ็กต์อีกอันได้!

ตัวอย่างเช่น เราไม่สามารถสร้างออบเจ็กต์ที่แทนเวกเตอร์หรือเมทริกซ์ แล้วบวกพวกมันเข้าด้วยกัน และคาดหวังให้ได้ออบเจ็กต์ที่ "ผสมกัน" เป็นผลลัพธ์ สิ่งนี้ไม่สามารถทำได้ใน JavaScript 

เนื่องจากข้อจำกัดนี้ จึงไม่ค่อยมีการใช้งานการดำเนินการทางคณิตศาสตร์กับออบเจ็กต์ในโปรเจ็กต์จริงๆ เท่าไหร่ เมื่อมันเกิดขึ้น มักจะเป็นเพราะข้อผิดพลาดในการเขียนโค้ด

ในบทนี้ เราจะกล่าวถึงวิธีที่ออบเจ็กต์ถูกแปลงเป็นค่าปฐมภูมิ และวิธีกำหนดเองให้กับการแปลง

เรามีจุดประสงค์สองอย่าง:

1. เข้าใจสิ่งที่เกิดขึ้นในกรณีที่เกิดข้อผิดพลาดในการเขียนโค้ด เมื่อการดำเนินการดังกล่าวเกิดขึ้นโดยไม่ได้ตั้งใจ
2. รู้จักข้อยกเว้นที่การดำเนินการดังกล่าวสามารถทำได้และดูดี เช่น การลบหรือเปรียบเทียบวันที่ (ออบเจ็กต์ `Date`) 

## กฎการแปลง

ในบทเรียนเกี่ยวกับการแปลงชนิดข้อมูล เราได้เห็นกฎสำหรับการแปลงเป็นตัวเลข สตริง และบูลีนของค่าปฐมภูมิ อย่างไรก็ตาม เราทิ้งช่องว่างไว้สำหรับออบเจ็กต์ ตอนนี้เรารู้เกี่ยวกับเมท็อดและสัญลักษณ์แล้ว เราสามารถเติมช่องว่างนั้นได้

1. ไม่มีการแปลงเป็นบูลีน ออบเจ็กต์ทั้งหมดเป็น `true` ในบริบทบูลีน เรียบง่ายแค่นั้น มีเพียงการแปลงเป็นตัวเลขและสตริงเท่านั้น
2. การแปลงเป็นตัวเลขเกิดขึ้นเมื่อเราลบออบเจ็กต์หรือใช้ฟังก์ชันทางคณิตศาสตร์ ตัวอย่างเช่น ออบเจ็กต์ `Date` สามารถนำมาลบกันได้ และผลลัพธ์ของ `date1 - date2` คือผลต่างของเวลาระหว่างสองวันที่
3. การแปลงเป็นสตริงมักจะเกิดขึ้นเมื่อเราแสดงผลออบเจ็กต์ด้วย `alert(obj)` และในบริบทที่คล้ายกัน

เราสามารถใช้เมท็อดพิเศษของออบเจ็กต์เพื่อดำเนินการแปลงเป็นสตริงและตัวเลขด้วยตัวเองได้

ตอนนี้ มาดำดิ่งลงไปในรายละเอียดทางเทคนิคเพื่อครอบคลุมหัวข้อนี้อย่างลึกซึ้งกัน

## คำใบ้ (Hints)

JavaScript ตัดสินใจอย่างไรว่าจะใช้การแปลงแบบใด?

มีสามรูปแบบของการแปลงชนิดข้อมูลที่เกิดขึ้นในสถานการณ์ต่างๆ พวกมันถูกเรียกว่า "คำใบ้" (hints) ตามที่ระบุในข้อกำหนด:

`"string"`
: สำหรับการแปลงออบเจ็กต์เป็นสตริง เมื่อเรากำลังทำการดำเนินการกับออบเจ็กต์ที่คาดหวังสตริง เช่น `alert`:

    ```js
    // แสดงผล 
    alert(obj);

    // ใช้ออบเจ็กต์เป็นคีย์ของคุณสมบัติ
    anotherObj[obj] = 123;
    ```

`"number"`
: สำหรับการแปลงออบเจ็กต์เป็นตัวเลข เช่นเมื่อเรากำลังคำนวณทางคณิตศาสตร์: 

    ```js
    // แปลงโดยชัดแจ้ง
    let num = Number(obj);

    // คณิตศาสตร์ (ยกเว้นบวกเลขฐานสอง)
    let n = +obj; // บวกเอกภาคี 
    let delta = date1 - date2;

    // การเปรียบเทียบน้อยกว่า/มากกว่า
    let greater = user1 > user2;
    ```

    ฟังก์ชันทางคณิตศาสตร์ในตัวส่วนใหญ่ก็รวมการแปลงดังกล่าวด้วย

`"default"`
: เกิดขึ้นในกรณีที่พบน้อย เมื่อตัวดำเนินการ "ไม่แน่ใจ" ว่าคาดหวังข้อมูลชนิดใด

    ตัวอย่างเช่น บวกเลขฐานสอง `+` สามารถทำงานได้ทั้งกับสตริง (เชื่อมต่อพวกมัน) และตัวเลข (บวกพวกมัน) ดังนั้นถ้าการบวกเลขฐานสองได้รับออบเจ็กต์เป็นอาร์กิวเมนต์ มันจะใช้คำใบ้ `"default"` เพื่อแปลงออบเจ็กต์นั้น

    นอกจากนี้ ถ้าออบเจ็กต์ถูกเปรียบเทียบด้วย `==` กับสตริง ตัวเลข หรือสัญลักษณ์ มันจะไม่ชัดเจนว่าควรทำการแปลงแบบใด ดังนั้นคำใบ้ `"default"` จะถูกใช้ 

    ```js
    // การบวกเลขฐานสองใช้คำใบ้ "default"
    let total = obj1 + obj2;

    // obj == number ใช้คำใบ้ "default"  
    if (user == 1) { ... };
    ```

    ตัวดำเนินการเปรียบเทียบน้อยกว่าและมากกว่า เช่น `<` `>` ก็สามารถทำงานได้ทั้งกับสตริงและตัวเลขเช่นกัน แต่พวกมันใช้คำใบ้ `"number"` ไม่ใช่ `"default"` ด้วยเหตุผลทางประวัติศาสตร์

ในทางปฏิบัติ สิ่งต่างๆ เรียบง่ายกว่านั้นเล็กน้อย

ออบเจ็กต์ในตัวทั้งหมด ยกเว้นหนึ่งกรณี (ออบเจ็กต์ `Date`) จะใช้การแปลง `"default"` แบบเดียวกับ `"number"` และเราก็ควรทำแบบเดียวกันนั้น

แต่ก็ยังสำคัญที่จะต้องรู้เกี่ยวกับคำใบ้ทั้งสามแบบและเหตุผลที่พวกมันมีอยู่

**เพื่อดำเนินการแปลง JavaScript พยายามค้นหาและเรียกเมท็อดสามอย่างของออบเจ็กต์:**

1. เรียก `obj[Symbol.toPrimitive](hint)` - เมท็อดที่มีคีย์สัญลักษณ์ `Symbol.toPrimitive` (สัญลักษณ์ของระบบ) ถ้ามีเมท็อดดังกล่าวอยู่
2. มิฉะนั้น ถ้าคำใบ้เป็น `"string"`:
    - ลองเรียก `obj.toString()` หรือ `obj.valueOf()` อย่างใดอย่างหนึ่งที่มีอยู่  
3. มิฉะนั้น ถ้าคำใบ้เป็น `"number"` หรือ `"default"`:
    - ลองเรียก `obj.valueOf()` หรือ `obj.toString()` อย่างใดอย่างหนึ่งที่มีอยู่

## Symbol.toPrimitive

มาเริ่มต้นด้วยเมท็อดแรกกัน มีสัญลักษณ์ในตัวที่เรียกว่า `Symbol.toPrimitive` ซึ่งควรใช้เป็นชื่อเมท็อดการแปลง แบบนี้:

```js
obj[Symbol.toPrimitive] = function(hint) {
  // โค้ดเพื่อแปลงออบเจ็กต์นี้เป็นค่าปฐมภูมิ
  // ต้องคืนค่าปฐมภูมิ
  // hint = "string", "number", หรือ "default" อย่างใดอย่างหนึ่ง
};
```

ถ้าเมท็อด `Symbol.toPrimitive` มีอยู่ มันจะถูกใช้สำหรับทุกคำใบ้ และไม่จำเป็นต้องใช้เมท็อดอื่นๆ อีก

ตัวอย่างเช่น ที่นี่ออบเจ็กต์ `user` ใช้เมท็อดนี้:

```js
let user = {
  name: "John",
  money: 1000,

  [Symbol.toPrimitive](hint) {
    alert(`hint: ${hint}`);
    return hint == "string" ? `{name: "${this.name}"}` : this.money;
  }
};

// ตัวอย่างการแปลง:
alert(user); // hint: string -> {name: "John"}
alert(+user); // hint: number -> 1000
alert(user + 500); // hint: default -> 1500
```

อย่างที่เราเห็นจากโค้ด `user` จะกลายเป็นสตริงที่อธิบายตัวเองหรือจำนวนเงิน ขึ้นอยู่กับการแปลง เมท็อดเดียวคือ `user[Symbol.toPrimitive]` จัดการกับทุกกรณีการแปลง

## toString/valueOf

ถ้าไม่มี `Symbol.toPrimitive` JavaScript จะพยายามหาเมท็อด `toString` และ `valueOf`:

- สำหรับคำใบ้ `"string"`: เรียก `toString` ก่อน และถ้ามันไม่มีหรือคืนค่าออบเจ็กต์แทนค่าปฐมภูมิ ก็จะเรียก `valueOf` (ดังนั้น `toString` จะมีความสำคัญมากกว่าสำหรับการแปลงเป็นสตริง)
- สำหรับคำใบ้อื่นๆ: เรียก `valueOf` ก่อน และถ้ามันไม่มีหรือคืนค่าออบเจ็กต์แทนค่าปฐมภูมิ ก็จะเรียก `toString` (ดังนั้น `valueOf` จะมีความสำคัญมากกว่าสำหรับการคำนวณทางคณิตศาสตร์)

เมท็อด `toString` และ `valueOf` มาจากสมัยโบราณ พวกมันไม่ใช่สัญลักษณ์ (สัญลักษณ์ยังไม่มีในอดีต) แต่เป็นเมท็อดชื่อสตริง "ปกติ" พวกมันให้วิธีการ "แบบเก่า" อีกแบบในการใช้การแปลง

เมท็อดเหล่านี้ต้องคืนค่าปฐมภูมิเพื่อให้ทำงาน (ถ้ามีการกำหนด)

โดยค่าเริ่มต้น ออบเจ็กต์ธรรมดาจะมีเมท็อด `toString` และ `valueOf` ดังนี้:

- `toString` คืนสตริง `"[object Object]"`
- `valueOf` คืนออบเจ็กต์ตัวมันเอง

นี่คือตัวอย่าง:

```js
let user = {name: "John"};

alert(user); // [object Object]
alert(user.valueOf() === user); // true
```

ดังนั้นถ้าเราพยายามใช้ออบเจ็กต์เป็นสตริง เช่นใน `alert` หรืออะไรทำนองนั้น โดยค่าเริ่มต้นเราจะเห็น `[object Object]`

`valueOf` เริ่มต้นถูกกล่าวถึงที่นี่เพื่อความครบถ้วนเท่านั้น เพื่อหลีกเลี่ยงความสับสน อย่างที่คุณเห็น มันคืนออบเจ็กต์ตัวมันเอง และดังนั้นจึงถูกเพิกเฉย อย่าถามฉันว่าทำไม -- นั่นเป็นเหตุผลทางประวัติศาสตร์ เราสามารถสมมติว่ามันไม่มีอยู่ก็ได้

มาเพิ่มเมท็อดเหล่านี้เพื่อกำหนดการแปลงเองกัน

ตัวอย่างเช่น ที่นี่ `user` ทำแบบเดียวกับด้านบนโดยใช้ `toString` และ `valueOf` ร่วมกันแทน `Symbol.toPrimitive`:

```js
let user = {
  name: "John",
  money: 1000,

  // สำหรับคำใบ้ "string"
  toString() {
    return `{name: "${this.name}"}`;
  },

  // สำหรับคำใบ้ "number" หรือ "default"
  valueOf() {
    return this.money;
  }
};

alert(user); // toString -> {name: "John"}
alert(+user); // valueOf -> 1000
alert(user + 500); // valueOf -> 1500
```

อย่างที่เราเห็น พฤติกรรมจะเหมือนกับตัวอย่างก่อนหน้าที่ใช้ `Symbol.toPrimitive`

บ่อยครั้งที่เราต้องการจุดเดียวที่ "รวมทุกอย่าง" เพื่อจัดการกับการแปลงเป็นค่าปฐมภูมิทั้งหมด ในกรณีนี้ เราสามารถใช้แค่ `toString` อย่างเดียว แบบนี้:

```js
let user = {
  name: "John",

  toString() {
    return this.name;
  }
};

alert(user); // toString -> John
alert(user + 500); // toString -> John500
```

เมื่อไม่มี `Symbol.toPrimitive` และ `valueOf`, `toString` จะจัดการการแปลงเป็นค่าปฐมภูมิทั้งหมด

### การแปลงสามารถคืนค่าปฐมภูมิชนิดใดก็ได้

สิ่งสำคัญที่ควรรู้เกี่ยวกับเมท็อดการแปลงเป็นค่าปฐมภูมิทั้งหมดคือ พวกมันไม่จำเป็นต้องคืนค่าปฐมภูมิที่ "ตรงตามคำใบ้"

ไม่มีการควบคุมว่า `toString` จะคืนสตริงหรือไม่ หรือว่าเมท็อด `Symbol.toPrimitive` จะคืนตัวเลขสำหรับคำใบ้ `"number"` หรือไม่

สิ่งเดียวที่บังคับคือ เมท็อดเหล่านี้ต้องคืนค่าปฐมภูมิ ไม่ใช่ออบเจ็กต์

```smart header="หมายเหตุทางประวัติศาสตร์"
ด้วยเหตุผลทางประวัติศาสตร์ ถ้า `toString` หรือ `valueOf` คืนออบเจ็กต์ จะไม่เกิด error แต่ค่าดังกล่าวจะถูกเพิกเฉย (เหมือนกับว่าเมท็อดไม่มีอยู่) นั่นเป็นเพราะในสมัยโบราณ ไม่มีแนวคิด "error" ที่ดีใน JavaScript 

ในทางตรงกันข้าม `Symbol.toPrimitive` เข้มงวดกว่า มัน *ต้อง* คืนค่าปฐมภูมิ มิฉะนั้นจะเกิด error
```

## การแปลงเพิ่มเติม

ตามที่เรารู้แล้ว ตัวดำเนินการและฟังก์ชันหลายตัวทำการแปลงชนิดข้อมูล เช่น คูณ `*` จะแปลงตัวถูกดำเนินการเป็นตัวเลข

ถ้าเราส่งออบเจ็กต์เป็นอาร์กิวเมนต์ จะมีสองขั้นตอนในการคำนวณ:
1. ออบเจ็กต์ถูกแปลงเป็นค่าปฐมภูมิ (โดยใช้กฎที่อธิบายไว้ด้านบน)
2. หากจำเป็นสำหรับการคำนวณต่อไป ค่าปฐมภูมิที่ได้จะถูกแปลงอีกด้วย

ตัวอย่างเช่น:

```js
let obj = {
  // toString จัดการการแปลงทั้งหมดเมื่อไม่มีเมท็อดอื่น
  toString() {
    return "2";
  }
};

alert(obj * 2); // 4, ออบเจ็กต์ถูกแปลงเป็นค่าปฐมภูมิ "2" จากนั้นการคูณทำให้มันเป็นตัวเลข
```

1. การคูณ `obj * 2` แปลงออบเจ็กต์เป็นค่าปฐมภูมิก่อน (ซึ่งเป็นสตริง `"2"`)
2. จากนั้น `"2" * 2` กลายเป็น `2 * 2` (สตริงถูกแปลงเป็นตัวเลข)

การบวกเลขฐานสองจะเชื่อมต่อสตริงในสถานการณ์เดียวกัน เพราะมันยอมรับสตริงด้วยความยินดี:

```js
let obj = {
  toString() {
    return "2";
  }
};

alert(obj + 2); // 22 ("2" + 2), การแปลงเป็นค่าปฐมภูมิคืนสตริง => เชื่อมต่อ
```

## สรุป

การแปลงออบเจ็กต์เป็นค่าปฐมภูมิจะถูกเรียกโดยอัตโนมัติโดยฟังก์ชันและตัวดำเนินการในตัวหลายตัวที่คาดหวังค่าปฐมภูมิ 

มีสามชนิด (คำใบ้) ของการแปลง:
- `"string"` (สำหรับ `alert` และการดำเนินการอื่นๆ ที่ต้องการสตริง)  
- `"number"` (สำหรับการคำนวณทางคณิตศาสตร์)
- `"default"` (สำหรับตัวดำเนินการไม่กี่ตัว ปกติออบเจ็กต์จะใช้มันแบบเดียวกับ `"number"`)

ข้อกำหนดระบุอย่างชัดเจนว่าตัวดำเนินการใดใช้คำใบ้ใด

อัลกอริทึมการแปลงคือ:

1. เรียก `obj[Symbol.toPrimitive](hint)` ถ้าเมท็อดมีอยู่
2. มิฉะนั้น ถ้าคำใบ้เป็น `"string"`: 
    - ลองเรียก `obj.toString()` หรือ `obj.valueOf()` อย่างใดอย่างหนึ่งที่มีอยู่
3. มิฉะนั้น ถ้าคำใบ้เป็น `"number"` หรือ `"default"`:
    - ลองเรียก `obj.valueOf()` หรือ `obj.toString()` อย่างใดอย่างหนึ่งที่มีอยู่

ในทางปฏิบัติ มักจะเพียงพอที่จะใช้แค่ `obj.toString()` เป็นเมท็อด "รวมทุกอย่าง" สำหรับการแปลงเป็นสตริง ซึ่งควรคืนตัวแทนของออบเจ็กต์ที่ "อ่านได้โดยมนุษย์" เพื่อวัตถุประสงค์ในการบันทึกหรือการดีบั๊ก