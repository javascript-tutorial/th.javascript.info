# การแปลงออบเจ็กต์เป็นค่าปฐมภูมิ

เกิดอะไรขึ้นเมื่อเรานำออบเจ็กต์ไปบวก (`obj1 + obj2`) ลบ (`obj1 - obj2`) หรือแสดงผลด้วย `alert(obj)`?

ใน JavaScript เราไม่สามารถกำหนดพฤติกรรมของตัวดำเนินการเมื่อใช้กับออบเจ็กต์ได้เอง แตกต่างจากบางภาษาเช่น Ruby หรือ C++ ที่สามารถใช้เมท็อดพิเศษเพื่อควบคุมการทำงานของตัวดำเนินการได้ 

ในกรณีเหล่านี้ ออบเจ็กต์จะถูกแปลงเป็นค่าปฐมภูมิ (primitive value) โดยอัตโนมัติก่อน จากนั้นการดำเนินการจะเกิดขึ้นกับค่าปฐมภูมินั้น และส่งผลลัพธ์กลับมาเป็นค่าปฐมภูมิเช่นกัน

นี่เป็นข้อจำกัดที่สำคัญ: ผลลัพธ์ของ `obj1 + obj2` (หรือการดำเนินการทางคณิตศาสตร์อื่นๆ) ไม่สามารถเป็นออบเจ็กต์ได้ 

ดังนั้น เราจึงไม่สามารถนิยามออบเจ็กต์ที่แทนเวกเตอร์หรือเมทริกซ์ แล้วคาดหวังให้การบวกออบเจ็กต์เหล่านั้นเข้าด้วยกัน ทำให้ได้เวกเตอร์หรือเมทริกซ์ใหม่ที่ "รวม" ค่าเข้าด้วยกัน ข้อจำกัดนี้ทำให้ไม่สามารถเขียนโค้ดในลักษณะนั้นได้เลย

ด้วยเหตุนี้ การทำงานทางคณิตศาสตร์โดยใช้ออบเจ็กต์จึงมีใช้น้อยมากในโปรเจ็กต์จริง และถ้าเกิดขึ้นมักจะเป็นเพราะข้อผิดพลาดในการเขียนโค้ดมากกว่า

ในบทความนี้ เราจะเรียนรู้กระบวนการแปลงออบเจ็กต์เป็นค่าปฐมภูมิ และวิธีควบคุมกระบวนการนั้นด้วยตัวเอง โดยมีจุดประสงค์ 2 ประการ:

1. เพื่อเข้าใจสิ่งที่เกิดขึ้นเมื่อมีข้อผิดพลาดในการเขียนโค้ด ที่ทำให้เกิดการแปลงโดยไม่ตั้งใจ
2. เพื่อศึกษากรณียกเว้นที่การแปลงดังกล่าวมีประโยชน์และให้ผลลัพธ์ที่ถูกต้อง เช่น การลบหรือเปรียบเทียบวันที่ (Date)

## ขั้นตอนการแปลง

ใน JavaScript มี 3 ประเภทของการแปลงออบเจ็กต์เป็นค่าปฐมภูมิ ซึ่งเรียกว่า "hint" (คำใบ้) ขึ้นอยู่กับสถานการณ์ที่เกิดขึ้น ดังนี้:

`"string"`
: สำหรับการแปลงเป็น string เมื่อเราต้องการนำออบเจ็กต์ไปใช้ในบริบทที่คาดหวังค่า string เช่น `alert(obj)`

`"number"`
: สำหรับการแปลงเป็นตัวเลข เช่น ในการคำนวณทางคณิตศาสตร์ `let num = Number(obj)`, `let n = +obj`, `let delta = date1 - date2`, `let greater = user1 > user2` เป็นต้น ฟังก์ชันคณิตศาสตร์ส่วนใหญ่ก็ใช้การแปลงแบบนี้ด้วย

`"default"`
: เกิดขึ้นน้อยครั้ง เมื่อตัวดำเนินการ "ไม่แน่ใจ" ว่าคาดหวังข้อมูลประเภทใด เช่น ตัวดำเนินการบวกเลขฐานสอง `+` ที่ยอมรับทั้ง string และตัวเลข ดังนั้นจึงใช้ hint นี้เมื่อได้รับออบเจ็กต์มา นอกจากนี้ตัวดำเนินการเปรียบเทียบ `==` กับ string, number หรือ symbol ก็ใช้ hint `"default"` เช่นกัน

ในทางปฏิบัติ สถานการณ์อาจง่ายกว่านี้เล็กน้อย ออบเจ็กต์ส่วนใหญ่ (ยกเว้น Date) จะใช้การแปลงแบบ `"default"` เหมือนกับ `"number"` และเราก็ควรทำเช่นนั้น แต่ก็ยังจำเป็นต้องรู้จักทั้ง 3 ประเภท เพื่อให้เข้าใจว่ามันมีประโยชน์อย่างไร

**เมื่อต้องการแปลงออบเจ็กต์เป็นค่าปฐมภูมิ JavaScript จะพยายามค้นหาและเรียกใช้เมท็อดต่างๆ ตามลำดับดังนี้:**

1. เรียกใช้ `obj[Symbol.toPrimitive](hint)` หากมีการกำหนดเมท็อดนี้ไว้ โดย `Symbol.toPrimitive` เป็นสัญลักษณ์ในตัวของระบบ
2. มิฉะนั้น ถ้า hint เป็น `"string"` จะลองเรียก `obj.toString()` และ `obj.valueOf()` อย่างใดอย่างหนึ่งที่มีอยู่
3. มิฉะนั้น ถ้า hint เป็น `"number"` หรือ `"default"` จะลองเรียก `obj.valueOf()` และ `obj.toString()` อย่างใดอย่างหนึ่งที่มีอยู่

## Symbol.toPrimitive

วิธีแรกคือใช้ symbol ในตัว `Symbol.toPrimitive` เป็นชื่อเมท็อดสำหรับแปลงออบเจ็กต์ โดยใช้ดังนี้:

```js
obj[Symbol.toPrimitive] = function(hint) {
  // โค้ดสำหรับแปลงออบเจ็กต์นี้เป็นค่าปฐมภูมิ
  // ต้องคืนค่าเป็นค่าปฐมภูมิ
  // hint จะเป็นหนึ่งใน "string", "number", "default"
};
```

ถ้ามีเมท็อด `Symbol.toPrimitive` มันจะถูกเรียกใช้สำหรับทุก hint และไม่จำเป็นต้องใช้เมท็อดอื่นอีก

ตัวอย่างเช่น ออบเจ็กต์ `user` ใช้เมท็อดนี้:

```js
let user = {
  name: "John",
  money: 1000,

  [Symbol.toPrimitive](hint) {
    alert(`hint: ${hint}`);
    return hint == "string" ? `{name: "${this.name}"}` : this.money;
  }
};

// ตัวอย่างการแปลง:
alert(user); // hint: string -> {name: "John"}
alert(+user); // hint: number -> 1000
alert(user + 500); // hint: default -> 1500
```

จะเห็นว่า `user` กลายเป็น string หรือตัวเลข ขึ้นอยู่กับรูปแบบการแปลง โดยใช้แค่เมท็อดเดียว `user[Symbol.toPrimitive]` ในการจัดการทุกกรณี

## toString/valueOf

ถ้าไม่มี `Symbol.toPrimitive` JavaScript จะมองหาเมท็อด `toString` และ `valueOf` แทน:

- สำหรับ hint ชนิด `"string"` จะเรียก `toString` ก่อน หากไม่มีหรือคืนค่าเป็นออบเจ็กต์ จะไปเรียก `valueOf` แทน (ดังนั้น `toString` จึงมีความสำคัญมากกว่าในการแปลงเป็น string)
- สำหรับ hint ชนิด `"number"` หรือ `"default"` จะเรียก `valueOf` ก่อน หากไม่มีหรือคืนค่าเป็นออบเจ็กต์ จะไปเรียก `toString` แทน (ดังนั้น `valueOf` จึงมีความสำคัญมากกว่าในการคำนวณ)

เมท็อด `toString` และ `valueOf` มาจากสมัยเก่า ก่อนที่จะมีแนวคิดเรื่อง symbol เป็นเมท็อดชื่อ string ธรรมดาที่ให้วิธีการแปลงแบบ "โบราณ"

โดยเมท็อดเหล่านี้ต้องคืนค่าปฐมภูมิ หาก `toString` หรือ `valueOf` คืนค่าเป็นออบเจ็กต์ ก็จะถูกละเลยเสมือนไม่มีการกำหนดเมท็อดนั้นไว้เลย

ออบเจ็กต์ทั่วไปมีเมท็อด `toString` และ `valueOf` ค่าเริ่มต้นดังนี้:

- `toString` คืนค่าเป็น string `"[object Object]"`
- `valueOf` คืนออบเจ็กต์ตัวมันเอง

ตัวอย่างเช่น:

```js
let user = {name: "John"};

alert(user); // [object Object]
alert(user.valueOf() === user); // true
```

ดังนั้น หากใช้ออบเจ็กต์แทนที่ที่คาดหวังค่า string เช่นใน `alert` โดยปกติแล้วจะแสดงผลเป็น `[object Object]`

ส่วน `valueOf` ที่คืนออบเจ็กต์ตัวมันเองนั้น ไม่มากมีประโยชน์ มีการกล่าวถึงไว้ที่นี่เพื่อความครบถ้วนเท่านั้น ซึ่งเป็นแบบนี้มาตั้งแต่สมัยแรกด้วยบางเหตุผล ส่วนใหญ่แล้วมักจะถือว่ามันไม่มีอยู่

มาลองใช้เมท็อดเหล่านี้ในการกำหนดพฤติกรรมการแปลงเป็นแบบของเราเองกัน

ตัวอย่างเช่น ที่นี่ `user` จะทำงานแบบเดียวกับตัวอย่างก่อนหน้า แต่ใช้ `toString` กับ `valueOf` แทน `Symbol.toPrimitive`:

```js
let user = {
  name: "John",
  money: 1000,

  // สำหรับ hint "string"
  toString() {
    return `{name: "${this.name}"}`;
  },

  // สำหรับ hint "number" หรือ "default"
  valueOf() {
    return this.money;
  }
};

alert(user); // toString -> {name: "John"}
alert(+user); // valueOf -> 1000
alert(user + 500); // valueOf -> 1500
```

โดยทั่วไปแล้ว มักต้องการจุดรวมศูนย์เดียวในการจัดการการแปลงออบเจ็กต์ให้เป็นค่าปฐมภูมิทั้งหมด ในกรณีนี้เราจะใช้แค่ `toString` อย่างเดียว ทำให้มันเป็นตัวจัดการหลักในการแปลง ดังตัวอย่าง:

```js
let user = {
  name: "John",

  toString() {
    return this.name;
  }
};

alert(user); // toString -> John
alert(user + 500); // toString -> John500
```

หากไม่มี `Symbol.toPrimitive` และ `valueOf` เมท็อด `toString` ก็จะรับผิดชอบการแปลงออบเจ็กต์เป็นค่าปฐมภูมิทั้งหมดเอง

### การแปลงสามารถคืนค่าปฐมภูมิประเภทใดก็ได้

สิ่งสำคัญที่ต้องทราบเกี่ยวกับเมท็อดทั้งหมดที่ใช้ในการแปลงออบเจ็กต์ คือ พวกมันไม่จำเป็นต้องคืนค่าปฐมภูมิประเภทที่ตรงกับ hint เสมอไป

ไม่มีข้อบังคับว่า `toString` ต้องคืนค่าเป็น string เสมอ หรือ `Symbol.toPrimitive` ต้องคืนตัวเลขเมื่อ hint เป็น `"number"` 

สิ่งเดียวที่จำเป็นคือ เมท็อดเหล่านั้นต้องคืนค่าปฐมภูมิ ไม่ใช่ออบเจ็กต์

```smart header="หมายเหตุทางประวัติศาสตร์"
สมัยก่อน ถ้า `toString` หรือ `valueOf` คืนออบเจ็กต์ ก็จะไม่เกิด error แต่ค่านั้นจะถูกละเลย (เสมือนไม่มีการกำหนดเมท็อดนั้นไว้) นั่นเป็นเพราะไม่มีแนวคิดเรื่อง "error" ที่ดีพอใน JavaScript สมัยนั้น

ในทางตรงข้าม `Symbol.toPrimitive` มีกฎเข้มงวดกว่า มันต้องคืนค่าปฐมภูมิเท่านั้น ไม่เช่นนั้นจะเกิด error
```

## การแปลงอื่นๆ

อย่างที่เราได้เรียนรู้มา มีตัวดำเนินการและฟังก์ชันหลายตัวที่ดำเนินการแปลงชนิดข้อมูล เช่น การคูณ `*` จะแปลงตัวถูกดำเนินการให้เป็นตัวเลข

หากเราส่งออบเจ็กต์เป็นอาร์กิวเมนต์ การคำนวณจะประกอบด้วย 2 ขั้นตอน:
1. ออบเจ็กต์จะถูกแปลงให้เป็นค่าปฐมภูมิ (ตามกฎที่อธิบายข้างต้น)
2. หากจำเป็นสำหรับการดำเนินการต่อไป ค่าปฐมภูมินั้นจะถูกแปลงอีกครั้ง

ตัวอย่างเช่น:

```js
let obj = {
  // toString จัดการการแปลงทั้งหมดเมื่อไม่มีเมท็อดอื่น
  toString() {
    return "2";
  }
};

alert(obj * 2); // 4 ออบเจ็กต์ถูกแปลงเป็น "2", จากนั้น "2" จึงถูกคูณด้วย 2
```

1. การคูณ `obj * 2` ขั้นแรกจะแปลง `obj` ให้เป็นค่าปฐมภูมิ ซึ่งจะเป็น string `"2"` (จาก `toString`)
2. จากนั้น `"2" * 2` จะกลายเป็น `2 * 2` (string ถูกแปลงเป็นตัวเลข)

บวกด้วย `+` ก็มีกฎพิเศษเหมือนกัน:

```js
let obj = {
  toString() {
    return "2";
  }
};

alert(obj + 2); // 22 ("2" + 2), การแปลงเป็น string เกิดขึ้น
```

การบวก `obj + 2` ในตอนแรกจะแปลง `obj` เป็นค่าปฐมภูมิ (ซึ่งเป็น string `"2"`) จากนั้นจึงเกิดการต่อ string `"2" + 2 = "22"`

ในทางตรงข้าม การลบ `-` และตัวดำเนินการเปรียบเทียบอื่นๆ เช่น `<` `>` จะแปลงทั้งสอง operand ให้เป็นตัวเลขเสมอ:

```js
let obj = {
  toString() {
    return "2";
  }
};

alert(obj - 2); // 0 ("2" - 2), การแปลงเป็นตัวเลขเกิดขึ้น
```

นี่คือตารางสรุประบุว่าตัวดำเนินการใช้การแปลงแบบใด:

| ตัวดำเนินการ | การแปลงตัวถูกดำเนินการ |
|--------------|----------------------|
| + | ทำการต่อ string ถ้าสามารถแปลงได้ เช่น `"1" + "2" = "12"`, `"1" + 2 = "12"` |
| - | แปลงเป็นตัวเลข |
| * / | แปลงเป็นตัวเลข |
| == | แปลงเป็นตัวเลข แต่ `null` กับ `undefined` จะถูกเปรียบเทียบโดยไม่มีการแปลง |
| < > >= <= | แปลงเป็นตัวเลข |
| + (unary) | แปลงเป็นตัวเลข |


## สรุป

การแปลงออบเจ็กต์เป็นค่าปฐมภูมิจะถูกเรียกใช้โดยอัตโนมัติ โดยฟังก์ชันและตัวดำเนินการหลายตัวที่คาดหวังให้ข้อมูลเป็นค่าปฐมภูมิ

มีการแปลง 3 แบบ:
- `"string"` (สำหรับ `alert` และตัวดำเนินการที่ต้องการ string)  
- `"number"` (สำหรับการคำนวณทางคณิตศาสตร์)
- `"default"` (สำหรับตัวดำเนินการบางตัวเท่านั้น)

ซึ่งมีระบุไว้ชัดเจนในสเปคว่าตัวดำเนินการแต่ละตัวใช้การแปลงแบบใด

ลำดับขั้นตอนการแปลงคือ:

1. เรียกใช้ `obj[Symbol.toPrimitive](hint)` หากมีการกำหนดไว้
2. มิฉะนั้น ถ้า hint คือ `"string"`
    - ลองเรียก `obj.toString()` และ `obj.valueOf()` ตามลำดับ เลือกอันแรกที่ใช้ได้ 
3. มิฉะนั้น ถ้า hint คือ `"number"` หรือ `"default"`
    - ลองเรียก `obj.valueOf()` และ `obj.toString()` ตามลำดับ เลือกอันแรกที่ใช้ได้

ในทางปฏิบัติ การใช้เมท็อด `obj.toString()` เพียงอย่างเดียวเป็นตัวจัดการหลักในการแปลงออบเจ็กต์เป็น string มักจะพอเพียง และถูกใช้เพื่ออธิบายข้อมูลของออบเจ็กต์ในรูปแบบที่อ่านได้ง่าย โดยมักใช้ในการล็อก (log) และดีบั๊ก