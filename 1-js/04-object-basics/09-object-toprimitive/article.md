# การแปลงออบเจ็กต์เป็นค่าปฐมภูมิ

เกิดอะไรขึ้นเมื่อนำออบเจ็กต์มาบวกกัน (`obj1 + obj2`), ลบกัน (`obj1 - obj2`) หรือแสดงผลด้วย `alert(obj)`?

JavaScript ไม่อนุญาตให้กำหนดวิธีการทำงานของตัวดำเนินการบนออบเจ็กต์เอง แตกต่างจากบางภาษาโปรแกรม เช่น Ruby หรือ C++ ที่เราสามารถใช้เมท็อดพิเศษของออบเจ็กต์เพื่อจัดการการดำเนินการต่างๆ ได้

ในกรณีเหล่านี้ ออบเจ็กต์จะถูกแปลงเป็นค่าปฐมภูมิโดยอัตโนมัติก่อน จากนั้นการดำเนินการจะเกิดขึ้นบนค่าปฐมภูมิ และส่งผลเป็นค่าปฐมภูมิเช่นกัน 

นี่ถือเป็นข้อจำกัดสำคัญ: ผลลัพธ์ของ `obj1 + obj2` (หรือการดำเนินการทางคณิตศาสตร์อื่นๆ) ไม่สามารถเป็นออบเจ็กต์ได้!

เราจึงไม่สามารถสร้างออบเจ็กต์ที่แทนเวกเตอร์หรือเมทริกซ์ แล้วบวกมันเข้าด้วยกันโดยหวังให้ได้ผลลัพธ์เป็นออบเจ็กต์ที่ "รวม" กัน ข้อจำกัดนี้ทำให้ไม่อาจเขียนโค้ดในลักษณะนั้นได้เลย

ด้วยเหตุนี้ในโปรเจ็กต์จริงจึงไม่ค่อยมีการใช้งานการคำนวณทางคณิตศาสตร์กับออบเจ็กต์ หากมันเกิดขึ้น ก็มักจะเป็นเพราะข้อผิดพลาดในการเขียนโค้ดเสียมากกว่า

ในบทความนี้ เราจะกล่าวถึงวิธีที่ออบเจ็กต์ถูกแปลงเป็นค่าปฐมภูมิ และวิธีกำหนดการแปลงด้วยตัวเอง โดยมีจุดประสงค์สองประการคือ:

1. เพื่อให้เข้าใจสิ่งที่เกิดขึ้นเมื่อมีข้อผิดพลาดในการเขียนโค้ด ซึ่งทำให้เกิดการแปลงโดยไม่ได้ตั้งใจ
2. เพื่อรู้จักข้อยกเว้นที่การแปลงดังกล่าวสามารถทำได้และให้ผลลัพธ์ที่ถูกต้อง เช่น การลบหรือเปรียบเทียบวันที่ (Date)

## กฎการแปลง

ใน JavaScript มีวิธีแปลงออบเจ็กต์เป็นค่าปฐมภูมิสามแบบที่เรียกว่า "คำใบ้" (hint) ซึ่งเกิดขึ้นในสถานการณ์ต่างๆ ดังนี้:

`"string"`
: สำหรับการแปลงออบเจ็กต์เป็นสตริง เมื่อต้องการนำออบเจ็กต์ไปใช้ในบริบทที่คาดหวังสตริง เช่น `alert(obj)`

`"number"`
: สำหรับการแปลงออบเจ็กต์เป็นตัวเลข เช่น การคำนวณทางคณิตศาสตร์ `let num = Number(obj)`, `let n = +obj`, `let delta = date1 - date2`, `let greater = user1 > user2` เป็นต้น ฟังก์ชันคณิตศาสตร์ส่วนใหญ่ก็ใช้การแปลงนี้ด้วย

`"default"`
: เกิดขึ้นน้อยครั้ง เมื่อตัวดำเนินการ "ไม่แน่ใจ" ว่าคาดหวังข้อมูลชนิดใด เช่น การบวกเลขฐานสอง `+` ที่รับทั้งสตริงและตัวเลขได้ จึงใช้คำใบ้นี้เมื่อได้รับออบเจ็กต์ นอกจากนี้การเปรียบเทียบ `==` กับสตริง ตัวเลข หรือสัญลักษณ์ ก็ใช้คำใบ้ `"default"` เช่นกัน

ในทางปฏิบัติ สิ่งต่างๆ จะเรียบง่ายกว่านี้เล็กน้อย ออบเจ็กต์ส่วนใหญ่ยกเว้น Date จะใช้การแปลง `"default"` เหมือนกับ `"number"` และเราก็ควรทำแบบเดียวกัน แต่ก็ยังจำเป็นต้องรู้จักคำใบ้ทั้งสามแบบ เพราะเดี๋ยวเราจะเห็นว่ามันมีประโยชน์ยังไง

**เมื่อต้องการแปลงออบเจ็กต์ JavaScript จะพยายามหาและเรียกเมท็อดสามแบบตามลำดับ ได้แก่:**

1. เรียก `obj[Symbol.toPrimitive](hint)` หากกำหนดเมท็อดดังกล่าวไว้ โดย `Symbol.toPrimitive` เป็นสัญลักษณ์ของระบบ (system symbol) 
2. หากคำใบ้เป็น `"string"` จะลองเรียก `obj.toString()` หรือ `obj.valueOf()` อย่างใดอย่างหนึ่งที่มีอยู่
3. หากคำใบ้เป็น `"number"` หรือ `"default"` จะลองเรียก `obj.valueOf()` หรือ `obj.toString()` อย่างใดอย่างหนึ่งที่มีอยู่ 

## Symbol.toPrimitive

วิธีการแรกคือการใช้สัญลักษณ์ในตัว `Symbol.toPrimitive` เป็นชื่อเมท็อดสำหรับการแปลงออบเจ็กต์ ดังนี้:

```js
obj[Symbol.toPrimitive] = function(hint) {
  // โค้ดสำหรับแปลงออบเจ็กต์นี้เป็นค่าปฐมภูมิ
  // ต้องคืนค่าเป็นค่าปฐมภูมิ
  // hint เป็นหนึ่งใน "string", "number", "default"
};
```

หากมีเมท็อด `Symbol.toPrimitive` มันจะถูกใช้งานสำหรับทุกคำใบ้ และไม่จำเป็นต้องใช้เมท็อดอื่นอีก

ตัวอย่างเช่น ที่นี่ `user` ใช้เมท็อดนี้:

```js
let user = {
  name: "John",
  money: 1000,

  [Symbol.toPrimitive](hint) {
    alert(`hint: ${hint}`);
    return hint == "string" ? `{name: "${this.name}"}` : this.money;
  }
};

// ตัวอย่างการแปลง:
alert(user); // hint: string -> {name: "John"}
alert(+user); // hint: number -> 1000
alert(user + 500); // hint: default -> 1500
```

จะเห็นได้ว่า `user` จะกลายเป็นสตริงหรือตัวเลขขึ้นอยู่กับการแปลง โดยเมท็อดเดียว `user[Symbol.toPrimitive]` จัดการทุกกรณีเลย

## toString / valueOf

หากไม่มี `Symbol.toPrimitive` JavaScript จะมองหาเมท็อด `toString` และ `valueOf` แทน:

- สำหรับคำใบ้ `"string"` จะเรียก `toString` ก่อน หากไม่มีหรือคืนค่าเป็นออบเจ็กต์ก็จะไปเรียก `valueOf` แทน (เพราะฉะนั้น `toString` จะสำคัญกว่าสำหรับการแปลงเป็นสตริง)
- สำหรับคำใบ้ `"number"` หรือ `"default"` จะเรียก `valueOf` ก่อน หากไม่มีหรือคืนค่าเป็นออบเจ็กต์ก็จะไปเรียก `toString` แทน (เพราะฉะนั้น `valueOf` จะสำคัญกว่าสำหรับการคำนวณ)

เมท็อด `toString` และ `valueOf` มาจากสมัยเก่า ยังไม่มีแนวคิดของสัญลักษณ์ในตอนนั้น มันเป็นแค่เมท็อดที่ชื่อเป็นสตริงธรรมดา ที่ให้วิธีการแปลงแบบ "โบราณ"

โดยเมท็อดเหล่านี้ต้องคืนค่าปฐมภูมิ หาก `toString` หรือ `valueOf` คืนค่าเป็นออบเจ็กต์ มันจะถูกเพิกเฉยไปเลย (เหมือนกับว่าไม่ได้กำหนดเมท็อดนั้นไว้)

ออบเจ็กต์ธรรมดาจะมีเมท็อด `toString` และ `valueOf` ดีฟอลต์ดังนี้:

- `toString` คืนสตริง `"[object Object]"`
- `valueOf` คืนออบเจ็กต์ตัวมันเอง

ตัวอย่าง:

```js
let user = {name: "John"};

alert(user); // [object Object]
alert(user.valueOf() === user); // true
```

ดังนั้น หากเราพยายามใช้ออบเจ็กต์ในที่ๆ ต้องการสตริง อย่างเช่นใน `alert` โดยปกติมันจะแสดง `[object Object]`

ส่วน `valueOf` ที่คืนออบเจ็กต์ตัวมันเองนั้น ไม่ค่อยมีประโยชน์ มันถูกพูดถึงที่นี่เพื่อความครบถ้วนเท่านั้น ซึ่งมันเป็นแบบนี้มาตั้งแต่แรกด้วยเหตุผลบางอย่างในอดีต สามารถถือได้ว่ามันไม่มีอยู่จริงๆ ก็ได้

มาลองใช้เมท็อดเหล่านี้กำหนดวิธีการแปลงแบบของเรากัน

ตัวอย่างเช่น ที่นี่ `user` ทำงานแบบเดียวกับตัวอย่างก่อนหน้า แต่ใช้ `toString` กับ `valueOf` แทน `Symbol.toPrimitive`:

```js
let user = {
  name: "John",
  money: 1000,

  // สำหรับ hint "string"
  toString() {
    return `{name: "${this.name}"}`;
  },

  // สำหรับ hint "number" หรือ "default"
  valueOf() {
    return this.money;
  }
};

alert(user); // toString -> {name: "John"}
alert(+user); // valueOf -> 1000
alert(user + 500); // valueOf -> 1500
```

บ่อยครั้งที่เราต้องการจุดรวมศูนย์เดียวในการจัดการการแปลงออบเจ็กต์เป็นค่าปฐมภูมิทั้งหมด ในกรณีนี้ เรามักจะใช้แค่ `toString` อย่างเดียว เพื่อให้มันเป็นตัวจัดการหลัก ดังตัวอย่าง:

```js
let user = {
  name: "John",

  toString() {
    return this.name;
  }
};

alert(user); // toString -> John
alert(user + 500); // toString -> John500
```

เมื่อไม่มี `Symbol.toPrimitive` และ `valueOf` เมท็อด `toString` จะจัดการการแปลงออบเจ็กต์เป็นค่าปฐมภูมิทั้งหมดเอง

### การแปลงสามารถคืนค่าปฐมภูมิชนิดใดก็ได้

สิ่งสำคัญที่ต้องรู้เกี่ยวกับเมท็อดแปลงออบเจ็กต์ทั้งหมดก็คือ พวกมันไม่จำเป็นต้องคืนค่าปฐมภูมิตรงตามคำใบ้เสมอไป

ไม่มีข้อบังคับว่า `toString` ต้องคืนสตริง หรือ `Symbol.toPrimitive` ต้องคืนตัวเลขเมื่อได้รับคำใบ้ `"number"`

สิ่งเดียวที่ต้องทำคือ เมท็อดเหล่านั้นต้องคืนค่าปฐมภูมิ ไม่ใช่ออบเจ็กต์

```smart header="หมายเหตุทางประวัติศาสตร์"
ในอดีต หาก `toString` หรือ `valueOf` คืนออบเจ็กต์ ก็จะไม่เกิด error แต่ค่านั้นจะถูกเพิกเฉยไป (เหมือนกับว่าไม่มีเมท็อดนั้นอยู่) นั่นเป็นเพราะไม่มีแนวคิดเรื่อง "error" ที่ดีใน JavaScript เมื่อก่อน

ในทางตรงข้าม `Symbol.toPrimitive` เข้มงวดกว่า มันจะต้องคืนค่าปฐมภูมิเท่านั้น ไม่งั้นจะเกิด error
```

## การแปลงเพิ่มเติม

อย่างที่เราได้เรียนรู้ไปแล้ว ตัวดำเนินการและฟังก์ชันหลายตัวจะทำการแปลงชนิดข้อมูล เช่น การคูณ `*` จะแปลงตัวถูกดำเนินการเป็นตัวเลข

เมื่อเราส่งออบเจ็กต์เป็นอาร์กิวเมนต์ จะมีสองขั้นตอนในการคำนวณ:
1. ออบเจ็กต์จะถูกแปลงเป็นค่าปฐมภูมิ (ตามกฎที่อธิบายไปข้างต้น)
2. หากจำเป็นต่อการคำนวณต่อไป ค่าปฐมภูมิที่ได้ก็จะถูกแปลงอีกด้วย

ตัวอย่างเช่น:

```js
let obj = {
  // toString จัดการการแปลงทั้งหมดเมื่อไม่มีเมท็อดอื่น
  toString() {
    return "2";
  }
};

alert(obj * 2); // 4, ออบเจ็กต์ถูกแปลงเป็น "2", แล้วจึงเกิดการคูณซึ่งแปลงเป็นตัวเลข
```

1. การคูณ `obj * 2` ในตอนแรกจะแปลง `obj` เป็นค่าปฐมภูมิ ซึ่งจะได้เป็นสตริง `"2"` (จาก `toString`)
2. หลังจากนั้น `"2" * 2` จะกลายเป็น `2 * 2` (สตริงถูกแปลงเป็นตัวเลข)

ส่วนการบวกด้วย `+` นั้น หากเป็นสตริงก็จะทำการต่อสตริงแทน ดังตัวอย่าง:

```js
let obj = {
  toString() {
    return "2";
  }
};

alert(obj + 2); // "22" (แปลงเป็นสตริงจึงเกิดการต่อสตริง)
```

## สรุป

การแปลงออบเจ็กต์เป็นค่าปฐมภูมิจะถูกเรียกใช้โดยอัตโนมัติโดยฟังก์ชันและตัวดำเนินการหลายตัวที่คาดหวังให้ข้อมูลเป็นค่าปฐมภูมิ

มีสามรูปแบบ (หรือเรียกว่าคำใบ้) ของการแปลง ได้แก่:
- `"string"` (สำหรับ `alert` และการดำเนินการอื่นๆ ที่ต้องการสตริง)
- `"number"` (สำหรับการคำนวณทางคณิตศาสตร์) 
- `"default"` (ตัวดำเนินการบางตัวเท่านั้น ปกติออบเจ็กต์จะใช้แบบเดียวกับ `"number"`)

ซึ่งจะระบุไว้อย่างชัดเจนในข้อกำหนดว่า ตัวดำเนินการแต่ละตัวใช้คำใบ้แบบใด

ขั้นตอนการแปลงมีดังนี้:

1. เรียก `obj[Symbol.toPrimitive](hint)` หากกำหนดเมท็อดนี้ไว้
2. ไม่งั้น หากคำใบ้เป็น `"string"`:
    - ลองเรียก `obj.toString()` หรือ `obj.valueOf()` อย่างใดอย่างหนึ่งที่มีอยู่  
3. ไม่งั้น หากคำใบ้เป็น `"number"` หรือ `"default"`:
    - ลองเรียก `obj.valueOf()` หรือ `obj.toString()` อย่างใดอย่างหนึ่งที่มีอยู่

ทุกเมท็อดเหล่านี้ต้องคืนค่าปฐมภูมิ หากถูกกำหนดไว้

ในทางปฏิบัติ มักจะเพียงพอที่จะใช้แค่ `obj.toString()` เป็นเมท็อดหลักในการแปลงออบเจ็กต์เป็นสตริง เพื่ออธิบายข้อมูลของออบเจ็กต์ในรูปแบบที่มนุษย์อ่านง่าย ซึ่งจะใช้สำหรับการบันทึก (log) หรือการดีบั๊ก