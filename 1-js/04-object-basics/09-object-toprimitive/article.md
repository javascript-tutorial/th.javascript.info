# การแปลงออบเจ็กต์เป็นค่าปฐมภูมิ

เกิดอะไรขึ้นเมื่อนำออบเจ็กต์มาบวกกัน (`obj1 + obj2`), ลบกัน (`obj1 - obj2`) หรือแสดงผลด้วย `alert(obj)`?

JavaScript ไม่อนุญาตให้กำหนดวิธีการทำงานของตัวดำเนินการบนออบเจ็กต์เอง แตกต่างจากบางภาษาโปรแกรม เช่น Ruby หรือ C++ ที่เราสามารถใช้เมท็อดพิเศษของออบเจ็กต์เพื่อจัดการการดำเนินการต่างๆ ได้

ในกรณีเหล่านี้ ออบเจ็กต์จะถูกแปลงเป็นค่าปฐมภูมิโดยอัตโนมัติก่อน จากนั้นการดำเนินการจะเกิดขึ้นบนค่าปฐมภูมิ และส่งผลเป็นค่าปฐมภูมิเช่นกัน 

นี่ถือเป็นข้อจำกัดสำคัญ: ผลลัพธ์ของ `obj1 + obj2` (หรือการดำเนินการทางคณิตศาสตร์อื่นๆ) ไม่สามารถเป็นออบเจ็กต์ได้!

เราจึงไม่สามารถสร้างออบเจ็กต์ที่แทนเวกเตอร์หรือเมทริกซ์ แล้วบวกมันเข้าด้วยกันโดยหวังให้ได้ผลลัพธ์เป็นออบเจ็กต์ที่ "รวม" กัน ข้อจำกัดนี้ทำให้ไม่อาจเขียนโค้ดในลักษณะนั้นได้เลย

ด้วยเหตุนี้ในโปรเจ็กต์จริงจึงไม่ค่อยมีการใช้งานการคำนวณทางคณิตศาสตร์กับออบเจ็กต์ หากมันเกิดขึ้น ก็มักจะเป็นเพราะข้อผิดพลาดในการเขียนโค้ดเสียมากกว่า

ในบทความนี้ เราจะกล่าวถึงวิธีที่ออบเจ็กต์ถูกแปลงเป็นค่าปฐมภูมิ และวิธีกำหนดการแปลงด้วยตัวเอง โดยมีจุดประสงค์สองประการคือ:

1. เพื่อให้เข้าใจสิ่งที่เกิดขึ้นเมื่อมีข้อผิดพลาดในการเขียนโค้ด ซึ่งทำให้เกิดการแปลงโดยไม่ได้ตั้งใจ
2. เพื่อรู้จักข้อยกเว้นที่การแปลงดังกล่าวสามารถทำได้และให้ผลลัพธ์ที่ถูกต้อง เช่น การลบหรือเปรียบเทียบวันที่ (Date)

## กฎการแปลง

ใน JavaScript มีวิธีแปลงออบเจ็กต์เป็นค่าปฐมภูมิสามแบบที่เรียกว่า "คำใบ้" (hint) ซึ่งเกิดขึ้นในสถานการณ์ต่างๆ ดังนี้:

`"string"`
: สำหรับการแปลงออบเจ็กต์เป็นสตริง เมื่อต้องการนำออบเจ็กต์ไปใช้ในบริบทที่คาดหวังสตริง เช่น `alert(obj)`

`"number"`
: สำหรับการแปลงออบเจ็กต์เป็นตัวเลข เช่น การคำนวณทางคณิตศาสตร์ `let num = Number(obj)`, `let n = +obj`, `let delta = date1 - date2`, `let greater = user1 > user2` เป็นต้น ฟังก์ชันคณิตศาสตร์ส่วนใหญ่ก็ใช้การแปลงนี้ด้วย

`"default"`
: เกิดขึ้นน้อยครั้ง เมื่อตัวดำเนินการ "ไม่แน่ใจ" ว่าคาดหวังข้อมูลชนิดใด เช่น การบวกเลขฐานสอง `+` ที่รับทั้งสตริงและตัวเลขได้ จึงใช้คำใบ้นี้เมื่อได้รับออบเจ็กต์ นอกจากนี้การเปรียบเทียบ `==` กับสตริง ตัวเลข หรือสัญลักษณ์ ก็ใช้คำใบ้ `"default"` เช่นกัน

ในทางปฏิบัติ สิ่งต่างๆ จะเรียบง่ายกว่านี้เล็กน้อย ออบเจ็กต์ส่วนใหญ่ยกเว้น Date จะใช้การแปลง `"default"` เหมือนกับ `"number"` และเราก็ควรทำแบบเดียวกัน แต่ก็ยังจำเป็นต้องรู้จักคำใบ้ทั้งสามแบบ เพราะเดี๋ยวเราจะเห็นว่ามันมีประโยชน์ยังไง

**เมื่อต้องการแปลงออบเจ็กต์ JavaScript จะพยายามหาและเรียกเมท็อดสามแบบตามลำดับ ได้แก่:**

1. เรียก `obj[Symbol.toPrimitive](hint)` หากกำหนดเมท็อดดังกล่าวไว้ โดย `Symbol.toPrimitive` เป็นสัญลักษณ์ของระบบ (system symbol) 
2. หากคำใบ้เป็น `"string"` จะลองเรียก `obj.toString()` หรือ `obj.valueOf()` อย่างใดอย่างหนึ่งที่มีอยู่
3. หากคำใบ้เป็น `"number"` หรือ `"default"` จะลองเรียก `obj.valueOf()` หรือ `obj.toString()` อย่างใดอย่างหนึ่งที่มีอยู่ 

## Symbol.toPrimitive

วิธีการแรกคือการใช้สัญลักษณ์ในตัว `Symbol.toPrimitive` เป็นชื่อเมท็อดสำหรับการแปลงออบเจ็กต์ ดังนี้:

```js
obj[Symbol.toPrimitive] = function(hint) {
  // โค้ดสำหรับแปลงออบเจ็กต์นี้เป็นค่าปฐมภูมิ
  // ต้องคืนค่าเป็นค่าปฐมภูมิ
  // hint เป็นหนึ่งใน "string", "number", "default"
};
```

หากมีเมท็อด `Symbol.toPrimitive` มันจะถูกใช้งานสำหรับทุกคำใบ้ และไม่จำเป็นต้องใช้เมท็อดอื่นอีก

ตัวอย่างเช่น ที่นี่ `user` ใช้เมท็อดนี้:

```js
let user = {
  name: "John",
  money: 1000,

  [Symbol.toPrimitive](hint) {
    alert(`hint: ${hint}`);
    return hint == "string" ? `{name: "${this.name}"}` : this.money;
  }
};

// ตัวอย่างการแปลง:
alert(user); // hint: string -> {name: "John"}
alert(+user); // hint: number -> 1000
alert(user + 500); // hint: default -> 1500
```

จะเห็นได้ว่า `user` จะกลายเป็นสตริงหรือตัวเลขขึ้นอยู่กับการแปลง โดยเมท็อดเดียว `user[Symbol.toPrimitive]` จัดการทุกกรณีเลย

## toString / valueOf

หากไม่มี `Symbol.toPrimitive` JavaScript จะมองหาเมท็อด `toString` และ `valueOf` แทน:

- สำหรับคำใบ้ `"string"` จะเรียก `toString` ก่อน หากไม่มีหรือคืนค่าเป็นออบเจ็กต์ก็จะไปเรียก `valueOf` แทน (เพราะฉะนั้น `toString` จะสำคัญกว่าสำหรับการแปลงเป็นสตริง)
- สำหรับคำใบ้ `"number"` หรือ `"default"` จะเรียก `valueOf` ก่อน หากไม่มีหรือคืนค่าเป็นออบเจ็กต์ก็จะไปเรียก `toString` แทน (เพราะฉะนั้น `valueOf` จะสำคัญกว่าสำหรับการคำนวณ)

เมท็อด `toString` และ `valueOf` มาจากสมัยเก่า ยังไม่มีแนวคิดของสัญลักษณ์ในตอนนั้น มันเป็นแค่เมท็อดที่ชื่อเป็นสตริงธรรมดา ที่ให้วิธีการแปลงแบบ "โบราณ"

โดยเมท็อดเหล่านี้ต้องคืนค่าปฐมภูมิ หาก `toString` หรือ `valueOf` คืนค่าเป็นออบเจ็กต์ มันจะถูกเพิกเฉยไปเลย (เหมือนกับว่าไม่ได้กำหนดเมท็อดนั้นไว้)

ออบเจ็กต์ธรรมดาจะมีเมท็อด `toString` และ `valueOf` ดีฟอลต์ดังนี้:

- `toString` คืนสตริง `"[object Object]"`
- `valueOf` คืนออบเจ็กต์ตัวมันเอง

ตัวอย่าง:

```js
let user = {name: "John"};

alert(user); // [object Object]
alert(user.valueOf() === user); // true
```

ดังนั้น หากเราพยายามใช้ออบเจ็กต์ในที่ๆ ต้องการสตริง อย่างเช่นใน `alert` โดยปกติมันจะแสดง `[object Object]`

ส่วน `valueOf` ที่คืนออบเจ็กต์ตัวมันเองนั้น ไม่ค่อยมีประโยชน์ มันถูกพูดถึงที่นี่เพื่อความครบถ้วนเท่านั้น ซึ่งมันเป็นแบบนี้มาตั้งแต่แรกด้วยเหตุผลบางอย่างในอดีต สามารถถือได้ว่ามันไม่มีอยู่จริงๆ ก็ได้

มาลองใช้เมท็อดเหล่านี้กำหนดวิธีการแปลงแบบของเรากัน

ตัวอย่างเช่น ที่นี่ `user` ทำงานแบบเดียวกับตัวอย่างก่อนหน้า แต่ใช้ `toString` กับ `valueOf` แทน `Symbol.toPrimitive`:

```js
let user = {
  name: "John",
  money: 1000,

  // สำหรับ hint "string"
  toString() {
    return `{name: "${this.name}"}`;
  },

  // สำหรับ hint "number" หรือ "default"
  valueOf() {
    return this.money;
  }
};

alert(user); // toString -> {name: "John"}
alert(+user); // valueOf -> 1000
alert(user + 500); // valueOf -> 1500