# การแปลงออบเจ็กต์เป็นค่าปฐมภูมิ

เกิดอะไรขึ้นเมื่อเรานำออบเจ็กต์ไปบวก (`obj1 + obj2`) ลบ (`obj1 - obj2`) หรือแสดงผลด้วย `alert(obj)`?

ใน JavaScript เราไม่สามารถกำหนดพฤติกรรมของตัวดำเนินการเมื่อใช้กับออบเจ็กต์ได้เอง แตกต่างจากบางภาษาเช่น Ruby หรือ C++ ที่สามารถใช้เมท็อดพิเศษเพื่อควบคุมการทำงานของตัวดำเนินการได้ 

ในกรณีเหล่านี้ ออบเจ็กต์จะถูกแปลงเป็นค่าปฐมภูมิ (primitive value) โดยอัตโนมัติก่อน จากนั้นการดำเนินการจะเกิดขึ้นกับค่าปฐมภูมินั้น และส่งผลลัพธ์กลับมาเป็นค่าปฐมภูมิเช่นกัน

นี่เป็นข้อจำกัดที่สำคัญ: ผลลัพธ์ของ `obj1 + obj2` (หรือการดำเนินการทางคณิตศาสตร์อื่นๆ) ไม่สามารถเป็นออบเจ็กต์ได้ 

ดังนั้น เราจึงไม่สามารถนิยามออบเจ็กต์ที่แทนเวกเตอร์หรือเมทริกซ์ แล้วคาดหวังให้การบวกออบเจ็กต์เหล่านั้นเข้าด้วยกัน ทำให้ได้เวกเตอร์หรือเมทริกซ์ใหม่ที่ "รวม" ค่าเข้าด้วยกัน ข้อจำกัดนี้ทำให้ไม่สามารถเขียนโค้ดในลักษณะนั้นได้เลย

ด้วยเหตุนี้ การทำงานทางคณิตศาสตร์โดยใช้ออบเจ็กต์จึงมีใช้น้อยมากในโปรเจ็กต์จริง และถ้าเกิดขึ้นมักจะเป็นเพราะข้อผิดพลาดในการเขียนโค้ดมากกว่า

ในบทความนี้ เราจะเรียนรู้กระบวนการแปลงออบเจ็กต์เป็นค่าปฐมภูมิ และวิธีควบคุมกระบวนการนั้นด้วยตัวเอง โดยมีจุดประสงค์ 2 ประการ:

1. เพื่อเข้าใจสิ่งที่เกิดขึ้นเมื่อมีข้อผิดพลาดในการเขียนโค้ด ที่ทำให้เกิดการแปลงโดยไม่ตั้งใจ
2. เพื่อศึกษากรณียกเว้นที่การแปลงดังกล่าวมีประโยชน์และให้ผลลัพธ์ที่ถูกต้อง เช่น การลบหรือเปรียบเทียบวันที่ (Date)

## ขั้นตอนการแปลง

ใน JavaScript มี 3 ประเภทของการแปลงออบเจ็กต์เป็นค่าปฐมภูมิ ซึ่งเรียกว่า "hint" (คำใบ้) ขึ้นอยู่กับสถานการณ์ที่เกิดขึ้น ดังนี้:

`"string"`
: สำหรับการแปลงเป็น string เมื่อเราต้องการนำออบเจ็กต์ไปใช้ในบริบทที่คาดหวังค่า string เช่น `alert(obj)`

`"number"`
: สำหรับการแปลงเป็นตัวเลข เช่น ในการคำนวณทางคณิตศาสตร์ `let num = Number(obj)`, `let n = +obj`, `let delta = date1 - date2`, `let greater = user1 > user2` เป็นต้น ฟังก์ชันคณิตศาสตร์ส่วนใหญ่ก็ใช้การแปลงแบบนี้ด้วย

`"default"`
: เกิดขึ้นน้อยครั้ง เมื่อตัวดำเนินการ "ไม่แน่ใจ" ว่าคาดหวังข้อมูลประเภทใด เช่น ตัวดำเนินการบวกเลขฐานสอง `+` ที่ยอมรับทั้ง string และตัวเลข ดังนั้นจึงใช้ hint นี้เมื่อได้รับออบเจ็กต์มา นอกจากนี้ตัวดำเนินการเปรียบเทียบ `==` กับ string, number หรือ symbol ก็ใช้ hint `"default"` เช่นกัน

ในทางปฏิบัติ สถานการณ์อาจง่ายกว่านี้เล็กน้อย ออบเจ็กต์ส่วนใหญ่ (ยกเว้น Date) จะใช้การแปลงแบบ `"default"` เหมือนกับ `"number"` และเราก็ควรทำเช่นนั้น แต่ก็ยังจำเป็นต้องรู้จักทั้ง 3 ประเภท เพื่อให้เข้าใจว่ามันมีประโยชน์อย่างไร

**เมื่อต้องการแปลงออบเจ็กต์เป็นค่าปฐมภูมิ JavaScript จะพยายามค้นหาและเรียกใช้เมท็อดต่างๆ ตามลำดับดังนี้:**

1. เรียกใช้ `obj[Symbol.toPrimitive](hint)` หากมีการกำหนดเมท็อดนี้ไว้ โดย `Symbol.toPrimitive` เป็นสัญลักษณ์ในตัวของระบบ
2. มิฉะนั้น ถ้า hint เป็น `"string"` จะลองเรียก `obj.toString()` และ `obj.valueOf()` อย่างใดอย่างหนึ่งที่มีอยู่
3. มิฉะนั้น ถ้า hint เป็น `"number"` หรือ `"default"` จะลองเรียก `obj.valueOf()` และ `obj.toString()` อย่างใดอย่างหนึ่งที่มีอยู่

## Symbol.toPrimitive

วิธีแรกคือใช้ symbol ในตัว `Symbol.toPrimitive` เป็นชื่อเมท็อดสำหรับแปลงออบเจ็กต์ โดยใช้ดังนี้:

```js
obj[Symbol.toPrimitive] = function(hint) {
  // โค้ดสำหรับแปลงออบเจ็กต์นี้เป็นค่าปฐมภูมิ
  // ต้องคืนค่าเป็นค่าปฐมภูมิ
  // hint จะเป็นหนึ่งใน "string", "number", "default"
};
```

ถ้ามีเมท็อด `Symbol.toPrimitive` มันจะถูกเรียกใช้สำหรับทุก hint และไม่จำเป็นต้องใช้เมท็อดอื่นอีก

ตัวอย่างเช่น ออบเจ็กต์ `user` ใช้เมท็อดนี้:

```js
let user = {
  name: "John",
  money: 1000,

  [Symbol.toPrimitive](hint) {
    alert(`hint: ${hint}`);
    return hint == "string" ? `{name: "${this.name}"}` : this.money;
  }
};

// ตัวอย่างการแปลง:
alert(user); // hint: string -> {name: "John"}
alert(+user); // hint: number -> 1000
alert(user + 500); // hint: default -> 1500
```

จะเห็นว่า `user` กลายเป็น string หรือตัวเลข ขึ้นอยู่กับรูปแบบการแปลง โดยใช้แค่เมท็อดเดียว `user[Symbol.toPrimitive]` ในการจัดการทุกกรณี