# วิธีการของอ็อบเจ็กต์ และ "this"

อ็อบเจ็กต์มักถูกสร้างขึ้นเพื่อแสดงแทนสิ่งต่างๆ ในโลกแห่งความเป็นจริง เช่น ผู้ใช้งาน คำสั่งซื้อ และอื่นๆ:

```js
let user = {
  name: "John",
  age: 30
};
```

และในโลกแห่งความเป็นจริง ผู้ใช้สามารถ *กระทำ* สิ่งต่างๆ ได้: เลือกสินค้าจากตะกร้า เข้าสู่ระบบ ออกจากระบบ ฯลฯ

การกระทำในภาษา JavaScript จะถูกแสดงด้วยฟังก์ชันที่อยู่ในคุณสมบัติ (properties)

## ตัวอย่างเมท็อด

เริ่มต้นด้วยการสอนให้ `user` พูดคำว่าสวัสดี: 

```js run
let user = {
  name: "John",
  age: 30
};

*!*
user.sayHi = function() {
  alert("Hello!");
};
*/!*

user.sayHi(); // Hello!
```

ที่นี่เราใช้ Function Expression ในการสร้างฟังก์ชันและกำหนดให้กับคุณสมบัติ `user.sayHi` ของอ็อบเจ็กต์

จากนั้นเราสามารถเรียกมันด้วย `user.sayHi()` ตอนนี้ผู้ใช้สามารถพูดได้แล้ว!

ฟังก์ชันที่เป็นคุณสมบัติของอ็อบเจ็กต์เรียกว่า *เมท็อด (method)*

ดังนั้น ที่นี่เรามีเมท็อด `sayHi` ของอ็อบเจ็กต์ `user`

แน่นอนว่าเราสามารถใช้ฟังก์ชันที่ประกาศไว้ก่อนแล้วมาเป็นเมท็อดได้ ตัวอย่างเช่น:

```js run
let user = {
  // ...
};

*!*
// ประกาศฟังก์ชันก่อน
function sayHi() {
  alert("Hello!");
}

// จากนั้นเพิ่มมันเป็นเมท็อด
user.sayHi = sayHi;
*/!*

user.sayHi(); // Hello!
```

```smart header="การเขียนโปรแกรมเชิงวัตถุ (Object-oriented programming)"
เมื่อเราเขียนโค้ดโดยใช้อ็อบเจ็กต์แทนสิ่งต่างๆ นี่เรียกว่า [การเขียนโปรแกรมเชิงวัตถุ](https://en.wikipedia.org/wiki/Object-oriented_programming) หรือเรียกสั้นๆ ว่า "OOP"

OOP เป็นเรื่องใหญ่และเป็นศาสตร์ที่น่าสนใจในตัวมันเอง คำถามเช่น จะเลือกอ็อบเจ็กต์แทนสิ่งต่างๆ ได้อย่างไร? จะจัดการปฏิสัมพันธ์ระหว่างพวกมันอย่างไร? นี่คือเรื่องของสถาปัตยกรรม และมีหนังสือดีๆ มากมายเกี่ยวกับหัวข้อนี้ เช่น "Design Patterns: Elements of Reusable Object-Oriented Software" โดย E. Gamma, R. Helm, R. Johnson, J. Vissides หรือ "Object-Oriented Analysis and Design with Applications" โดย G. Booch และอื่นๆ
```

### เมท็อดลัด (Method shorthand)

มีรูปแบบสั้นกว่าสำหรับเขียนเมท็อดใน object literal:

```js
// อ็อบเจ็กต์เหล่านี้ทำงานแบบเดียวกัน 

user = {
  sayHi: function() {
    alert("Hello");
  }
};

// รูปแบบย่อของเมท็อดดูดีกว่าใช่ไหม?
user = {
*!*
  sayHi() { // เหมือนกับ "sayHi: function(){...}"
*/!*
    alert("Hello");
  }
};
```

อย่างที่เห็น เราสามารถละ `"function"` ทิ้งและเขียนแค่ `sayHi()` ได้

อันที่จริง รูปแบบที่เขียนไม่ได้เหมือนกันทั้งหมด มีความแตกต่างเล็กน้อยที่เกี่ยวกับการสืบทอดของอ็อบเจ็กต์ (จะกล่าวถึงภายหลัง) แต่ตอนนี้พวกมันไม่สำคัญ ในเกือบทุกกรณี เราจะเลือกใช้รูปแบบแบบย่อ 

## "this" ในเมท็อด

มักจะเป็นเรื่องปกติที่เมท็อดของอ็อบเจ็กต์ต้องการเข้าถึงข้อมูลที่เก็บอยู่ในอ็อบเจ็กต์เพื่อทำงานบางอย่าง

ยกตัวอย่างเช่น โค้ดภายใน `user.sayHi()` อาจต้องการชื่อ (name) ของ `user`

**เมท็อดสามารถใช้คีย์เวิร์ด `this` เพื่อเข้าถึงอ็อบเจ็กต์**

ค่าของ `this` คืออ็อบเจ็กต์ "ก่อนจุด" ซึ่งเป็นอ็อบเจ็กต์ที่ใช้ในการเรียกเมท็อด

ตัวอย่างเช่น:

```js run
let user = {
  name: "John",
  age: 30,

  sayHi() {
*!*
    // "this" คืออ็อบเจ็กต์ "ปัจจุบัน"
    alert(this.name);
*/!*
  }

};

user.sayHi(); // John
```

ที่นี่ในระหว่างที่มีการเรียก `user.sayHi()` ค่าของ `this` จะเป็น `user`

ในทางเทคนิคแล้ว เราก็สามารถเข้าถึงอ็อบเจ็กต์ได้โดยไม่ต้องใช้ `this` โดยการอ้างอิงผ่านตัวแปรภายนอก:

```js
let user = {
  name: "John",
  age: 30,

  sayHi() {
*!*
    alert(user.name); // ใช้ "user" แทน "this"
*/!*
  }

};
```

...แต่โค้ดแบบนี้ไม่เชื่อถือได้ หากเราตัดสินใจที่จะคัดลอก `user` ไปยังตัวแปรอื่น เช่น `admin = user` แล้วเขียนทับ `user` ด้วยค่าอื่น มันจะเข้าถึงอ็อบเจ็กต์ผิด

ตัวอย่างแสดงไว้ข้างล่างนี้:

```js run
let user = {
  name: "John",
  age: 30,

  sayHi() {
*!*
    alert( user.name ); // นำไปสู่ข้อผิดพลาด
*/!*
  }

};


let admin = user;
user = null; // เขียนทับเพื่อให้สิ่งต่างๆ ชัดเจน

*!*
admin.sayHi(); // TypeError: Cannot read property 'name' of null
*/!*
```

ถ้าเราใช้ `this.name` แทน `user.name` ภายใน `alert` โค้ดก็จะทำงานได้

## "this" ไม่ถูกผูกไว้

ในภาษา JavaScript คีย์เวิร์ด `this` มีพฤติกรรมแตกต่างจากภาษาอื่นๆ ส่วนใหญ่ มันสามารถใช้ในฟังก์ชันใดก็ได้ ถึงแม้ว่ามันจะไม่ใช่เมท็อดของอ็อบเจ็กต์ก็ตาม

ไม่มี syntax error ในตัวอย่างต่อไปนี้:

```js
function sayHi() {
  alert( *!*this*/!*.name );
}
```

ค่าของ `this` จะถูกประเมินในช่วง run-time ขึ้นอยู่กับบริบท

ตัวอย่างเช่น ที่นี่ฟังก์ชันเดียวกันถูกกำหนดให้กับอ็อบเจ็กต์สองตัวที่แตกต่างกัน และมี "this" ที่ต่างกันในการเรียก:

```js run
let user = { name: "John" };
let admin = { name: "Admin" };

function sayHi() {
  alert( this.name );
}

*!*
// ใช้ฟังก์ชันเดียวกันในอ็อบเจ็กต์สองตัว
user.f = sayHi;
admin.f = sayHi;
*/!*

// การเรียกเหล่านี้มี this ต่างกัน
// "this" ภายในฟังก์ชันคือ อ็อบเจ็กต์ "ก่อนจุด"
user.f(); // John  (this == user)
admin.f(); // Admin  (this == admin)

admin['f'](); // Admin (การเข้าถึงเมท็อดโดยจุดกับวงเล็บเหลี่ยมไม่ต่างกัน)
```

กฎง่ายๆ คือ: ถ้ามีการเรียก `obj.f()` เมื่อนั้น `this` จะเป็น `obj` ระหว่างการเรียก `f` ดังนั้นมันจะเป็น `user` หรือ `admin` ในตัวอย่างข้างต้น 

````smart header="การเรียกโดยไม่มีอ็อบเจ็กต์: `this == undefined`"
เราสามารถเรียกฟังก์ชันได้โดยไม่มีอ็อบเจ็กต์เลยก็ได้:

```js run
function sayHi() {
  alert(this);
}

sayHi(); // undefined
```

````
ในกรณีนี้ `this` จะเป็น `undefined` ในโหมด strict ถ้าเราพยายามเข้าถึง `this.name` จะเกิด error

ในโหมด non-strict ค่าของ `this` ในกรณีนี้จะเป็น *global object* (`window` ในเบราว์เซอร์ เราจะได้เรียนรู้เพิ่มเติมในบท [](info:global-object)) นี่เป็นพฤติกรรมดั้งเดิมที่ `"use strict"` แก้ไข

โดยปกติการเรียกแบบนี้เป็นข้อผิดพลาดในการเขียนโปรแกรม ถ้ามี `this` อยู่ในฟังก์ชัน มันคาดหวังว่าจะถูกเรียกในบริบทของอ็อบเจ็กต์


````smart header="ผลกระทบของ `this` ที่ไม่ได้ถูกผูกไว้"
ถ้าคุณมาจากภาษาโปรแกรมอื่น คุณอาจจะคุ้นเคยกับแนวคิดเรื่อง "`this` ที่ถูกผูกไว้" ซึ่งเมท็อดที่ประกาศในอ็อบเจ็กต์จะมี `this` ชี้ไปยังอ็อบเจ็กต์นั้นตลอดเวลา 

ในภาษา JavaScript `this` มีค่า "อิสระ" ค่าของมันจะถูกประเมินในช่วงเวลาเรียก และไม่ขึ้นอยู่กับว่าเมท็อดถูกประกาศที่ไหน แต่จะขึ้นอยู่กับว่าอ็อบเจ็กต์ใดอยู่ "ก่อนจุด"

แนวคิดของ `this` ที่ถูกประเมินในช่วง run-time มีทั้งข้อดีและข้อเสีย ในแง่หนึ่ง ฟังก์ชันสามารถนำไปใช้กับอ็อบเจ็กต์ต่างๆ ได้อย่างอิสระ แต่ในอีกแง่หนึ่ง ความยืดหยุ่นที่เพิ่มขึ้นก็ทำให้มีโอกาสเกิดข้อผิดพลาดได้มากขึ้นด้วย

ที่นี่เราไม่ได้ตัดสินว่าการออกแบบภาษาเช่นนี้ดีหรือไม่ดี เราจะเข้าใจวิธีทำงานกับมัน เพื่อใช้ประโยชน์และหลีกเลี่ยงปัญหา
````

## Arrow functions ไม่มี "this"

Arrow functions มีลักษณะพิเศษ: พวกมันไม่มี `this` "เป็นของตัวเอง" ถ้าเราใช้ `this` ในฟังก์ชันแบบนี้ ค่าของมันจะถูกนำมาจากฟังก์ชัน "ธรรมดา" ที่ครอบมันอยู่

ตัวอย่างเช่น ที่นี่ `arrow()` ใช้ `this` จากเมท็อด `user.sayHi()` ด้านนอก:

```js run
let user = {
  firstName: "Ilya",
  sayHi() {
    let arrow = () => alert(this.firstName);
    arrow();
  }
};

user.sayHi(); // Ilya
```

นี่คือลักษณะพิเศษของ arrow functions มันมีประโยชน์เมื่อเราไม่ต้องการให้มี `this` ที่แยกออกมา แต่จะนำ `this` มาจากบริบทภายนอกแทน เราจะศึกษา arrow functions เพิ่มเติมในบท <info:arrow-functions>

## สรุป

- ฟังก์ชันที่ถูกเก็บอยู่ในคุณสมบัติของอ็อบเจ็กต์เรียกว่า "เมท็อด"
- เมท็อดทำให้อ็อบเจ็กต์สามารถ "กระทำ" อะไรบางอย่างได้ เช่น `object.doSomething()`
- เมท็อดสามารถอ้างอิงไปยังอ็อบเจ็กต์ผ่าน `this` ได้

ค่าของ `this` จะถูกกำหนดในช่วง run-time
- เมื่อประกาศฟังก์ชัน มันอาจใช้ `this` ได้ แต่ `this` จะยังไม่มีค่าจนกว่าฟังก์ชันจะถูกเรียก
- ฟังก์ชันสามารถถูกคัดลอกข้ามอ็อบเจ็กต์ได้
- เมื่อฟังก์ชันถูกเรียกในรูปแบบ `object.method()` ค่าของ `this` ระหว่างการเรียกจะเป็น `object`

โปรดทราบว่า arrow functions มีลักษณะพิเศษ: พวกมันไม่มี `this` เมื่อมีการใช้ `this` ภายใน arrow function ค่าของมันจะถูกนำมาจากภายนอก