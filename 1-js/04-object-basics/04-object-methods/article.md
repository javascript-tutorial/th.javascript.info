# วิธีการของอ็อบเจ็กต์ และ "this"

อ็อบเจ็กต์มักถูกสร้างขึ้นเพื่อเป็นตัวแทนของสิ่งต่างๆ ในโลกความเป็นจริง เช่น ผู้ใช้ ใบสั่งซื้อ และอื่นๆ:

```js
let user = {
  name: "John",
  age: 30
};
```

และในโลกความเป็นจริง ผู้ใช้สามารถ *กระทำ* สิ่งต่างๆ ได้: เลือกสินค้าจากตะกร้า เข้าสู่ระบบ ออกจากระบบ ฯลฯ 

การกระทำในจาวาสคริปต์จะถูกแทนที่ด้วยฟังก์ชันในคุณสมบัติ (properties)

## ตัวอย่างเมท็อด

ลองเริ่มจากการสอนให้ `user` พูดทักทาย:

```js run
let user = {
  name: "John",
  age: 30
};

*!*
user.sayHi = function() {
  alert("Hello!");
};
*/!*

user.sayHi(); // Hello!
```

ที่นี่เราใช้ฟังก์ชันนิพจน์ (Function Expression) เพื่อสร้างฟังก์ชันและกำหนดให้กับคุณสมบัติ `user.sayHi` ของอ็อบเจ็กต์

จากนั้นเราก็เรียกมันด้วย `user.sayHi()` ตอนนี้ผู้ใช้สามารถพูดได้แล้ว!

ฟังก์ชันที่เป็นคุณสมบัติของอ็อบเจ็กต์เรียกว่า *เมท็อด*

ดังนั้น ที่นี่เรามีเมท็อด `sayHi` ของอ็อบเจ็กต์ `user`

แน่นอนว่าเราสามารถใช้ฟังก์ชันที่ประกาศไว้ก่อนหน้าเป็นเมท็อดได้ เช่น:

```js run
let user = {
  // ...
};

*!*
// ประกาศฟังก์ชันก่อน
function sayHi() {
  alert("Hello!");
}

// จากนั้นเพิ่มเป็นเมท็อด
user.sayHi = sayHi;
*/!*

user.sayHi(); // Hello!
```

```smart header="การเขียนโปรแกรมเชิงวัตถุ"
เมื่อเราเขียนโค้ดโดยใช้อ็อบเจ็กต์เพื่อเป็นตัวแทนของสิ่งต่างๆ นั่นเรียกว่า [การเขียนโปรแกรมเชิงวัตถุ](https://en.wikipedia.org/wiki/Object-oriented_programming) หรือย่อว่า "OOP"

OOP เป็นเรื่องใหญ่และเป็นศาสตร์ที่น่าสนใจในตัวของมันเอง คำถามอย่างเช่น จะเลือกอ็อบเจ็กต์ที่เหมาะสมได้อย่างไร? จะจัดระเบียบการปฏิสัมพันธ์ระหว่างพวกมันยังไง? นี่คือเรื่องของสถาปัตยกรรม และมีหนังสือดีๆ เกี่ยวกับหัวข้อนี้มากมาย เช่น "Design Patterns: Elements of Reusable Object-Oriented Software" โดย E. Gamma, R. Helm, R. Johnson, J. Vissides หรือ "Object-Oriented Analysis and Design with Applications" โดย G. Booch เป็นต้น
```

### เมท็อดแบบย่อ

มีวิธีเขียนแบบย่อสำหรับเมท็อดใน object literal:

```js
// อ็อบเจ็กต์เหล่านี้ทำงานเหมือนกัน

user = {
  sayHi: function() {
    alert("Hello");
  }
};

// เมท็อดแบบย่อดูดีกว่าใช่ไหม?
user = {
*!*
  sayHi() { // เหมือนกับ "sayHi: function(){...}"
*/!*
    alert("Hello");
  }
};
```

อย่างที่เห็น เราสามารถละ `"function"` ทิ้งไปได้และเขียนแค่ `sayHi()`

จริงๆ แล้วสองแบบนี้ไม่ได้เหมือนกันทีเดียว มันมีความแตกต่างเล็กน้อยที่เกี่ยวข้องกับการสืบทอดของอ็อบเจ็กต์ (จะกล่าวถึงต่อไป) แต่ตอนนี้ยังไม่มีผลอะไร ในเกือบทุกกรณี แบบย่อจะเป็นที่นิยมมากกว่า

## "this" ในเมท็อด

เป็นเรื่องปกติที่เมท็อดของอ็อบเจ็กต์จำเป็นต้องเข้าถึงข้อมูลที่อยู่ในอ็อบเจ็กต์เพื่อทำหน้าที่ของมัน

ตัวอย่างเช่น โค้ดภายใน `user.sayHi()` อาจจำเป็นต้องใช้ชื่อของ `user`

**เมท็อดสามารถใช้คีย์เวิร์ด `this` เพื่อเข้าถึงอ็อบเจ็กต์**

ค่าของ `this` คืออ็อบเจ็กต์ "ก่อนจุด" ที่ถูกใช้ในการเรียกเมท็อด

เช่น:

```js run
let user = {
  name: "John",
  age: 30,

  sayHi() {
*!*
    // "this" คืออ็อบเจ็กต์ "ปัจจุบัน"
    alert(this.name);
*/!*
  }

};

user.sayHi(); // John
```

ที่นี่ในระหว่างการประมวลผล `user.sayHi()` ค่าของ `this` จะเป็น `user`

ในทางเทคนิคแล้ว เราสามารถเข้าถึงอ็อบเจ็กต์ได้โดยไม่ใช้ `this` ผ่านการอ้างอิงโดยตัวแปรภายนอก:

```js
let user = {
  name: "John",
  age: 30,

  sayHi() {
*!*
    alert(user.name); // ใช้ "user" แทน "this"
*/!*
  }

};
```

...แต่โค้ดแบบนี้ไม่น่าเชื่อถือ หากเราตัดสินใจที่จะคัดลอก `user` ไปยังตัวแปรอื่น เช่น `admin = user` และเขียนทับ `user` ด้วยค่าอื่น มันจะเข้าถึงอ็อบเจ็กต์ผิดตัว

แสดงให้เห็นด้านล่าง:

```js run
let user = {
  name: "John",
  age: 30,

  sayHi() {
*!*
    alert( user.name ); // ทำให้เกิด error  
*/!*
  }

};


let admin = user;
user = null; // เขียนทับเพื่อให้เห็นชัดเจน

*!*
admin.sayHi(); // TypeError: ไม่สามารถอ่านคุณสมบัติ 'name' ของ null ได้
*/!*
```

หากเราใช้ `this.name` แทน `user.name` ภายใน `alert` โค้ดก็จะทำงาน
