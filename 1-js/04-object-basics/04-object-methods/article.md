# วิธีการของอ็อบเจ็กต์ และ "this"

อ็อบเจ็กต์มักถูกสร้างขึ้นเพื่อเป็นตัวแทนของสิ่งต่างๆ ในโลกความเป็นจริง เช่น ผู้ใช้ ใบสั่งซื้อ และอื่นๆ:

```js
let user = {
  name: "John",
  age: 30
};
```

และในโลกความเป็นจริง ผู้ใช้สามารถ *กระทำ* สิ่งต่างๆ ได้: เลือกสินค้าจากตะกร้า เข้าสู่ระบบ ออกจากระบบ ฯลฯ 

การกระทำในจาวาสคริปต์จะถูกแทนที่ด้วยฟังก์ชันในคุณสมบัติ (properties)

## ตัวอย่างเมท็อด

ลองเริ่มจากการสอนให้ `user` พูดทักทาย:

```js run
let user = {
  name: "John",
  age: 30
};

*!*
user.sayHi = function() {
  alert("Hello!");
};
*/!*

user.sayHi(); // Hello!
```

ที่นี่เราใช้ฟังก์ชันนิพจน์ (Function Expression) เพื่อสร้างฟังก์ชันและกำหนดให้กับคุณสมบัติ `user.sayHi` ของอ็อบเจ็กต์

จากนั้นเราก็เรียกมันด้วย `user.sayHi()` ตอนนี้ผู้ใช้สามารถพูดได้แล้ว!

ฟังก์ชันที่เป็นคุณสมบัติของอ็อบเจ็กต์เรียกว่า *เมท็อด*

ดังนั้น ที่นี่เรามีเมท็อด `sayHi` ของอ็อบเจ็กต์ `user`

แน่นอนว่าเราสามารถใช้ฟังก์ชันที่ประกาศไว้ก่อนหน้าเป็นเมท็อดได้ เช่น:

```js run
let user = {
  // ...
};

*!*
// ประกาศฟังก์ชันก่อน
function sayHi() {
  alert("Hello!");
}

// จากนั้นเพิ่มเป็นเมท็อด
user.sayHi = sayHi;
*/!*

user.sayHi(); // Hello!
```

```smart header="การเขียนโปรแกรมเชิงวัตถุ"
เมื่อเราเขียนโค้ดโดยใช้อ็อบเจ็กต์เพื่อเป็นตัวแทนของสิ่งต่างๆ นั่นเรียกว่า [การเขียนโปรแกรมเชิงวัตถุ](https://en.wikipedia.org/wiki/Object-oriented_programming) หรือย่อว่า "OOP"

OOP เป็นเรื่องใหญ่และเป็นศาสตร์ที่น่าสนใจในตัวของมันเอง คำถามอย่างเช่น จะเลือกอ็อบเจ็กต์ที่เหมาะสมได้อย่างไร? จะจัดระเบียบการปฏิสัมพันธ์ระหว่างพวกมันยังไง? นี่คือเรื่องของสถาปัตยกรรม และมีหนังสือดีๆ เกี่ยวกับหัวข้อนี้มากมาย เช่น "Design Patterns: Elements of Reusable Object-Oriented Software" โดย E. Gamma, R. Helm, R. Johnson, J. Vissides หรือ "Object-Oriented Analysis and Design with Applications" โดย G. Booch เป็นต้น
```

### เมท็อดแบบย่อ

มีวิธีเขียนแบบย่อสำหรับเมท็อดใน object literal:

```js
// อ็อบเจ็กต์เหล่านี้ทำงานเหมือนกัน

user = {
  sayHi: function() {
    alert("Hello");
  }
};

// เมท็อดแบบย่อดูดีกว่าใช่ไหม?
user = {
*!*
  sayHi() { // เหมือนกับ "sayHi: function(){...}"
*/!*
    alert("Hello");
  }
};
```

อย่างที่เห็น เราสามารถละ `"function"` ทิ้งไปได้และเขียนแค่ `sayHi()`

จริงๆ แล้วสองแบบนี้ไม่ได้เหมือนกันทีเดียว มันมีความแตกต่างเล็กน้อยที่เกี่ยวข้องกับการสืบทอดของอ็อบเจ็กต์ (จะกล่าวถึงต่อไป) แต่ตอนนี้ยังไม่มีผลอะไร ในเกือบทุกกรณี แบบย่อจะเป็นที่นิยมมากกว่า

## "this" ในเมท็อด

เป็นเรื่องปกติที่เมท็อดของอ็อบเจ็กต์จำเป็นต้องเข้าถึงข้อมูลที่อยู่ในอ็อบเจ็กต์เพื่อทำหน้าที่ของมัน

ตัวอย่างเช่น โค้ดภายใน `user.sayHi()` อาจจำเป็นต้องใช้ชื่อของ `user`

**เมท็อดสามารถใช้คีย์เวิร์ด `this` เพื่อเข้าถึงอ็อบเจ็กต์**

ค่าของ `this` คืออ็อบเจ็กต์ "ก่อนจุด" ที่ถูกใช้ในการเรียกเมท็อด

เช่น:

```js run
let user = {
  name: "John",
  age: 30,

  sayHi() {
*!*
    // "this" คืออ็อบเจ็กต์ "ปัจจุบัน"
    alert(this.name);
*/!*
  }

};

user.sayHi(); // John
```

ที่นี่ในระหว่างการประมวลผล `user.sayHi()` ค่าของ `this` จะเป็น `user`

ในทางเทคนิคแล้ว เราสามารถเข้าถึงอ็อบเจ็กต์ได้โดยไม่ใช้ `this` ผ่านการอ้างอิงโดยตัวแปรภายนอก:

```js
let user = {
  name: "John",
  age: 30,

  sayHi() {
*!*
    alert(user.name); // ใช้ "user" แทน "this"
*/!*
  }

};
```

...แต่โค้ดแบบนี้ไม่น่าเชื่อถือ หากเราตัดสินใจที่จะคัดลอก `user` ไปยังตัวแปรอื่น เช่น `admin = user` และเขียนทับ `user` ด้วยค่าอื่น มันจะเข้าถึงอ็อบเจ็กต์ผิดตัว

แสดงให้เห็นด้านล่าง:

```js run
let user = {
  name: "John",
  age: 30,

  sayHi() {
*!*
    alert( user.name ); // ทำให้เกิด error  
*/!*
  }

};


let admin = user;
user = null; // เขียนทับเพื่อให้เห็นชัดเจน

*!*
admin.sayHi(); // TypeError: ไม่สามารถอ่านคุณสมบัติ 'name' ของ null ได้
*/!*
```

หากเราใช้ `this.name` แทน `user.name` ภายใน `alert` โค้ดก็จะทำงาน

## "this" ไม่ถูกผูกไว้

ในจาวาสคริปต์ คีย์เวิร์ด `this` จะแตกต่างจากภาษาโปรแกรมส่วนใหญ่ มันสามารถใช้ในฟังก์ชันใดก็ได้ ถึงแม้ว่ามันจะไม่ใช่เมท็อดของอ็อบเจ็กต์ก็ตาม

ในตัวอย่างต่อไปนี้ไม่มี syntax error:

```js
function sayHi() {
  alert( *!*this*/!*.name );
}
```

ค่าของ `this` จะถูกประเมินในช่วงเวลารันไทม์ (run-time) ขึ้นอยู่กับบริบท (context)

ตัวอย่างเช่น ที่นี่ฟังก์ชันเดียวกันถูกกำหนดให้กับสองอ็อบเจ็กต์ที่ต่างกัน และมี "this" ที่แตกต่างกันในการเรียก:

```js run
let user = { name: "John" };
let admin = { name: "Admin" };

function sayHi() {
  alert( this.name );
}

*!*
// ใช้ฟังก์ชันเดียวกันในอ็อบเจ็กต์สองตัว
user.f = sayHi;
admin.f = sayHi;
*/!*

// การเรียกเหล่านี้มี this ต่างกัน
// "this" ภายในฟังก์ชันคืออ็อบเจ็กต์ "ก่อนจุด"
user.f(); // John  (this == user)
admin.f(); // Admin  (this == admin)

admin['f'](); // Admin (การเข้าถึงด้วยจุดหรือวงเล็บก็ไม่ต่างกัน)
```

กฎง่ายๆ คือ: ถ้ามีการเรียก `obj.f()` เมื่อนั้น `this` จะเป็น `obj` ในระหว่างการเรียก `f` ดังนั้นจะเป็น `user` หรือ `admin` ในตัวอย่างข้างต้น

````smart header="การเรียกโดยไม่มีอ็อบเจ็กต์: `this == undefined`"
เราสามารถเรียกฟังก์ชันได้โดยไม่มีอ็อบเจ็กต์เลยด้วย:

```js run
function sayHi() {
  alert(this);
}

sayHi(); // undefined
```

ในกรณีนี้ `this` จะเป็น `undefined` ในโหมดเข้มงวด (strict mode) หากเราพยายามเข้าถึง `this.name` จะเกิด error

ในโหมดไม่เข้มงวด (non-strict mode) ค่าของ `this` ในกรณีนี้จะเป็น *global object* (`window` ในเบราว์เซอร์ เราจะเรียนรู้เพิ่มเติมในบท [](info:global-object)) นี่คือพฤติกรรมดั้งเดิมที่ `"use strict"` แก้ไข

โดยปกติแล้วการเรียกเช่นนี้เป็นข้อผิดพลาดในการเขียนโปรแกรม หากมี `this` อยู่ในฟังก์ชัน ย่อมหมายความว่ามันควรถูกเรียกในบริบทของอ็อบเจ็กต์
````

````smart header="ผลที่ตามมาของ `this` ที่ไม่ได้ถูกผูกไว้"
ถ้าคุณมาจากภาษาโปรแกรมอื่น คุณคงคุ้นเคยกับแนวคิดของ "`this` ที่ถูกผูกไว้แล้ว" ที่เมท็อดซึ่งประกาศภายในอ็อบเจ็กต์จะมี `this` อ้างถึงอ็อบเจ็กต์นั้นเสมอ 

ในจาวาสคริปต์ `this` มีลักษณะ "อิสระ" ค่าของมันจะถูกประเมินในช่วงเวลาเรียก (call-time) และไม่ได้ขึ้นอยู่กับว่าเมท็อดถูกประกาศที่ไหน แต่จะขึ้นกับว่าอ็อบเจ็กต์ใดอยู่ "ก่อนจุด"

แนวคิดของ `this` ที่ถูกประเมินในช่วงรันไทม์ (run-time) มีทั้งข้อดีและข้อเสีย ในแง่หนึ่ง ฟังก์ชันสามารถนำไปใช้ซ้ำกับอ็อบเจ็กต์ต่างๆ ได้ แต่ในอีกแง่หนึ่ง ความยืดหยุ่นที่มากขึ้นก็ทำให้มีโอกาสเกิดข้อผิดพลาดได้มากขึ้นด้วย

ที่นี่เราไม่ได้ตัดสินว่าการออกแบบภาษานี้ดีหรือไม่ดี เราจะเข้าใจวิธีการทำงานกับมัน เพื่อใช้ประโยชน์และหลีกเลี่ยงปัญหา
````

## Arrow functions ไม่มี "this"

Arrow functions มีลักษณะพิเศษ: พวกมันไม่มี `this` "ของตัวเอง" หากใช้ `this` จากฟังก์ชันแบบนี้ ค่าจะถูกนำมาจากฟังก์ชัน "ปกติ" ด้านนอก

ตัวอย่างเช่น ที่นี่ `arrow()` ใช้ `this` จากเมท็อด `user.sayHi()` ภายนอก:

```js run
let user = {
  firstName: "Ilya",
  sayHi() {
    let arrow = () => alert(this.firstName);
    arrow();
  }
};

user.sayHi(); // Ilya
```

นี่คือลักษณะพิเศษของ arrow functions มันมีประโยชน์เมื่อเราไม่ต้องการให้มี `this` แยกต่างหาก แต่ต้องการนำเอา `this` มาจากบริบทภายนอก เราจะศึกษา arrow functions เพิ่มเติมในบท <info:arrow-functions>

## สรุป

- ฟังก์ชันที่ถูกจัดเก็บในคุณสมบัติของอ็อบเจ็กต์เรียกว่า "เมท็อด"
- เมท็อดช่วยให้อ็อบเจ็กต์ "ทำอะไรบางอย่าง" ได้ เช่น `object.doSomething()`
- เมท็อดสามารถอ้างอิงอ็อบเจ็กต์ด้วย `this` ได้ 

ค่าของ `this` ถูกกำหนดในช่วงรันไทม์
- เมื่อประกาศฟังก์ชัน มันอาจใช้ `this` ได้ แต่ `this` จะยังไม่มีค่าจนกว่าฟังก์ชันจะถูกเรียก
- ฟังก์ชันสามารถถูกคัดลอกระหว่างอ็อบเจ็กต์ได้
- เมื่อฟังก์ชันถูกเรียกในรูปแบบ "เมท็อด": `object.method()` ค่าของ `this` ในระหว่างการเรียกคือ `object`

โปรดทราบว่า arrow functions มีลักษณะพิเศษ: มันไม่มี `this` เมื่อมีการเข้าถึง `this` ภายใน arrow function ค่าจะถูกนำมาจากภายนอก