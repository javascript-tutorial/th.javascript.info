# Constructor และตัวดำเนินการ "new"

การใช้ `{...}` ช่วยให้เราสร้างออบเจ็กต์ได้ แต่ในกรณีที่ต้องการสร้างออบเจ็กต์หลายๆ ตัวที่มีลักษณะคล้ายกัน เช่น ผู้ใช้หลายคน, เมนูหลายรายการ ฯลฯ การใช้ `{...}` ซ้ำๆ อาจไม่ใช่วิธีที่ดี 

ในกรณีนี้เราสามารถใช้ฟังก์ชัน constructor ร่วมกับตัวดำเนินการ `"new"` ได้

## ฟังก์ชัน Constructor

โดยปกติแล้ว ฟังก์ชัน constructor เป็นฟังก์ชันธรรมดา แต่มีข้อตกลงสองประการ:

1. ชื่อฟังก์ชันจะขึ้นต้นด้วยตัวพิมพ์ใหญ่เสมอ
2. ควรเรียกใช้งานผ่านตัวดำเนินการ `"new"` เท่านั้น

ตัวอย่างเช่น:

```js run
function User(name) {
  this.name = name;
  this.isAdmin = false;
}

*!*
let user = new User("Jack");
*/!*

alert(user.name); // Jack
alert(user.isAdmin); // false
```

เมื่อฟังก์ชันถูกเรียกผ่าน `new` จะเกิดขั้นตอนดังนี้:

1. มีการสร้างออบเจ็กต์ใหม่ขึ้นมาเปล่าๆ และกำหนดให้เป็น `this`
2. ทำงานในส่วนบอดี้ของฟังก์ชัน ซึ่งมักจะมีการปรับแต่ง `this` และเพิ่มคุณสมบัติใหม่ๆ เข้าไป
3. คืนค่า `this`

กล่าวอีกนัยหนึ่ง `new User(...)` สามารถเทียบได้กับ:

```js
function User(name) {
*!*
  // this = {};  (โดยนัยยะ)
*/!*

  // เพิ่มคุณสมบัติลงใน this
  this.name = name;
  this.isAdmin = false;

*!*
  // return this;  (โดยนัยยะ)
*/!*
}
```

ดังนั้น `let user = new User("Jack")` จะให้ผลลัพธ์เหมือนกับ:

```js
let user = {
  name: "Jack",
  isAdmin: false
};
```

ซึ่งหากเราต้องการสร้าง user อื่นๆ เพิ่มเติม ก็เรียกใช้ `new User("Ann")`, `new User("Alice")` เป็นต้น โดยจะสั้นกว่าและอ่านง่ายกว่าการใช้ออบเจ็กต์ลิเทอรัลซ้ำๆ มากๆ

จึงสรุปได้ว่า จุดประสงค์หลักของ constructor คือ การนำโค้ดที่ใช้ในการสร้างออบเจ็กต์มาใช้ซ้ำได้ง่ายขึ้น

กลับมาเน้นย้ำอีกครั้ง -- ในแง่หลักการแล้ว ฟังก์ชันอะไรก็ตาม (ยกเว้น arrow function ที่ไม่มี `this`) สามารถนำมาเป็น constructor ได้ สามารถเรียกใช้งานผ่าน `new` และจะดำเนินการตามขั้นตอนข้างต้น การตั้งชื่อให้ขึ้นต้นด้วยตัวอักษรพิมพ์ใหญ่เป็นแค่ข้อตกลงร่วมกัน เพื่อให้ชัดเจนว่าฟังก์ชันนี้ควรเรียกใช้ผ่าน `new` เท่านั้น

````smart header="new function() { ... }"
กรณีที่การสร้างออบเจ็กต์ที่ซับซ้อนมีโค้ดหลายบรรทัด เราสามารถครอบมันด้วย constructor function และเรียกใช้ทันทีได้ ดังนี้:

```js
// สร้างฟังก์ชันและทันทีเรียกใช้ผ่าน new
let user = new function() {
  this.name = "John";
  this.isAdmin = false;

  // ...โค้ดอื่นๆ ในการสร้าง user
  // อาจมีตรรกะและคำสั่งที่ซับซ้อน
  // มีตัวแปรภายใน ฯลฯ
};
```

Constructor ดังกล่าวไม่สามารถเรียกใช้ซ้ำได้อีก เนื่องจากไม่ได้ถูกเก็บไว้ที่ใดเลย ถูกสร้างและเรียกใช้ในทันที เทคนิคนี้ใช้เพื่อห่อหุ้มกระบวนการสร้างออบเจ็กต์ที่ซับซ้อนไว้ด้วยกัน และไม่มีแผนจะนำมาใช้ซ้ำอีกในอนาคต
````

## ทดสอบโหมด Constructor: new.target

```smart header="แนวคิดขั้นสูง"
ไวยากรณ์ในส่วนนี้ไม่ค่อยถูกใช้ สามารถข้ามไปได้หากไม่สนใจเนื้อหาโดยลึก
```

ในฟังก์ชัน เราสามารถตรวจสอบได้ว่า มันถูกเรียกผ่าน `new` หรือไม่ โดยใช้ `new.target`

ในกรณีการเรียกปกติ `new.target` จะเป็น `undefined` แต่หากเรียกผ่าน `new` ค่าของมันจะเป็นฟังก์ชันนั้นเอง:

```js run
function User() {
  alert(new.target);
}

// ไม่ใช่ new
*!*
User(); // undefined
*/!*

// ใช้ new
*!*
new User(); // ฟังก์ชัน User {...}
*/!*
```

สิ่งนี้สามารถนำไปใช้ในการตรวจสอบภายในฟังก์ชันว่า ถูกเรียกในโหมด "constructor" ด้วย `new` หรือโหมด "ปกติ"

เราสามารถทำให้การเรียกแบบใช้และไม่ใช้ `new` ทำงานเหมือนกันได้ เช่น:

```js run
function User(name) {
  if (!new.target) { // ถ้าคุณเรียกใช้ฉันโดยไม่มี new
    return new User(name); // ...ฉันจะใส่ new ให้เอง
  }

  this.name = name;
}

let john = User("John"); // เปลี่ยนทางไปเรียกใช้ new User
alert(john.name); // John
```

ซึ่งพบเห็นได้บ้างในไลบรารีต่างๆ ที่ต้องการให้ไวยากรณ์ยืดหยุ่น จะเรียกด้วย `new` หรือไม่ก็ได้ ฟังก์ชันจะยังทำงานได้ปกติ

แต่ไม่ควรนำไปใช้กับทุกฟังก์ชัน เพราะการไม่ใส่ `new` อาจทำให้สิ่งที่เกิดขึ้นคลุมเครือไปหน่อย เมื่อเราใช้ `new` ทุกคนจะเข้าใจว่าเรากำลังสร้างออบเจ็กต์ใหม่

## การ return จาก constructor

ปกติแล้ว constructor จะไม่มีการใช้คำสั่ง `return` หน้าที่ของมันคือการเขียนข้อมูลที่จำเป็นทั้งหมดลงใน `this` ซึ่ง `this` จะกลายเป็นผลลัพธ์โดยอัตโนมัติอยู่แล้ว

แต่ถ้าหากมีการใช้คำสั่ง `return` ก็จะมีกฎง่ายๆ ดังนี้:

- หาก `return` ด้วยออบเจ็กต์ ออบเจ็กต์นั้นจะถูกคืนค่ากลับมาแทน `this`
- หาก `return` ด้วยค่าพื้นฐาน (primitive) จะเกิดการเพิกเฉยต่อค่านั้น

หรือกล่าวอีกนัยหนึ่งคือ `return` ด้วยออบเจ็กต์จะคืนออบเจ็กต์นั้นกลับมา แต่ในกรณีอื่นทั้งหมด `this` จะถูกคืนกลับมาเป็นผลลัพธ์

ยกตัวอย่างเช่น ในที่นี่ `return` จะเขียนทับ `this` โดยคืนออบเจ็กต์ออกมา:

```js run
function BigUser() {

  this.name = "John";

  return { name: "Godzilla" };  // <-- คืนออบเจ็กต์นี้
}

alert( new BigUser().name );  // Godzilla ออบเจ็กต์ถูกคืนกลับมา
```

ส่วนในนี้คือตัวอย่างการ `return` เปล่าๆ (หรืออาจใส่ค่าพื้นฐานหลังจากนั้นก็ได้ ไม่สำคัญ):

```js run
function SmallUser() {

  this.name = "John";

  return; // <-- คืนค่า this
}

alert( new SmallUser().name );  // John
```

โดยทั่วไปแล้ว constructor มักจะไม่มีคำสั่ง `return` ในที่นี้เราพูดถึงพฤติกรรมพิเศษ ในการคืนค่าเป็นออบเจ็กต์ เพื่อให้ข้อมูลครบถ้วนสมบูรณ์

````smart header="ละวงเล็บ"
ที่จริงแล้ว เราสามารถละวงเล็บต่อท้าย `new` ได้ ถ้าไม่มีอาร์กิวเมนต์:

```js
let user = new User; // <-- ไม่มีวงเล็บ
// เหมือนกับ let user = new User();
```

การไม่ใส่วงเล็บแบบนี้ไม่ใช่ "แบบแผนที่ดี" แต่ไวยากรณ์ของภาษาก็อนุญาตให้ทำได้
````