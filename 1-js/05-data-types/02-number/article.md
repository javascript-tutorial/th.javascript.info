# ตัวเลข

ในภาษา JavaScript สมัยใหม่ มีตัวเลขอยู่สองประเภท:

1. ตัวเลขปกติใน JavaScript จะถูกเก็บในรูปแบบ 64 บิต [IEEE-754](https://en.wikipedia.org/wiki/IEEE_754-2008_revision) ซึ่งเรียกอีกอย่างว่า "จำนวนทศนิยมความแม่นยำสองเท่า" (double precision floating point numbers) ตัวเลขเหล่านี้เป็นตัวเลขที่เราใช้บ่อยที่สุด และเราจะพูดถึงมันในบทนี้

2. ตัวเลข BigInt เพื่อแสดงจำนวนเต็มที่มีความยาวไม่จำกัด บางครั้งจำเป็นต้องใช้เนื่องจากตัวเลขปกติไม่สามารถเกิน <code>2<sup>53</sup></code> หรือน้อยกว่า <code>-2<sup>53</sup></code> ได้อย่างปลอดภัย เนื่องจาก bigints ใช้ในบางพื้นที่พิเศษเท่านั้น เราจึงอุทิศบทพิเศษให้กับมัน <info:bigint>

ดังนั้นในที่นี้เราจะพูดถึงตัวเลขปกติ มาขยายความรู้เกี่ยวกับมันกันเถอะ

## วิธีเขียนตัวเลขเพิ่มเติม

สมมติว่าเราต้องการเขียนตัวเลขหนึ่งพันล้าน วิธีที่เห็นได้ชัดคือ:

```js
let billion = 1000000000;
```

เราสามารถใช้เครื่องหมายขีดล่าง `_` เป็นตัวคั่นได้:

```js
let billion = 1_000_000_000;
```

ในที่นี้ เครื่องหมายขีดล่าง `_` ทำหน้าที่เป็น "น้ำตาลทางไวยากรณ์" (syntactic sugar) ทำให้ตัวเลขอ่านง่ายขึ้น เครื่องยนต์ JavaScript จะละเลย `_` ระหว่างตัวเลข ดังนั้นมันจึงเป็นตัวเลขหนึ่งพันล้านเหมือนกันกับข้างบน

ในชีวิตจริง เราพยายามหลีกเลี่ยงการเขียนเลขศูนย์ต่อกันยาวๆ เราขี้เกียจเกินไป เราจะพยายามเขียนอะไรประมาณ `"1bn"` สำหรับหนึ่งพันล้าน หรือ `"7.3bn"` สำหรับเจ็ดพันสามร้อยล้าน สิ่งเดียวกันนี้เป็นจริงสำหรับตัวเลขขนาดใหญ่ส่วนใหญ่

ใน JavaScript เราสามารถย่อตัวเลขโดยเพิ่มตัวอักษร `"e"` ต่อท้ายและระบุจำนวนศูนย์:

```js run
let billion = 1e9;  // 1 พันล้าน ตามตัวอักษร: 1 และตามด้วยศูนย์ 9 ตัว

alert( 7.3e9 );  // 7.3 พันล้าน (เหมือนกับ 7300000000 หรือ 7_300_000_000)
```

กล่าวอีกนัยหนึ่ง `e` คูณตัวเลขด้วย `1` ตามด้วยจำนวนศูนย์ที่กำหนด

```js
1e3 === 1 * 1000; // e3 หมายถึง *1000
1.23e6 === 1.23 * 1000000; // e6 หมายถึง *1000000
```

ตอนนี้มาเขียนอะไรที่เล็กมากๆ กัน สมมติว่า 1 ไมโครวินาที (หนึ่งในล้านของวินาที):

```js
let mсs = 0.000001;
```

เช่นเดียวกับก่อนหน้านี้ การใช้ `"e"` สามารถช่วยได้ ถ้าเราไม่อยากเขียนศูนย์อย่างชัดเจน เราสามารถพูดเหมือนกันได้ว่า:

```js
let mcs = 1e-6; // ศูนย์หกตัวทางซ้ายของ 1
```

ถ้าเรานับจำนวนศูนย์ใน `0.000001` จะมีศูนย์อยู่ 6 ตัว ดังนั้นจึงเป็น `1e-6` ตามธรรมชาติ

กล่าวอีกนัยหนึ่ง ตัวเลขติดลบหลัง `"e"` หมายถึงการหารด้วย 1 ตามด้วยจำนวนศูนย์ที่กำหนด:

```js
// -3 หารด้วย 1 ตามด้วยศูนย์ 3 ตัว
1e-3 === 1 / 1000; // 0.001

// -6 หารด้วย 1 ตามด้วยศูนย์ 6 ตัว
1.23e-6 === 1.23 / 1000000; // 0.00000123
```

### ตัวเลขฐานสิบหก ฐานสอง และฐานแปด

[ตัวเลขฐานสิบหก](https://en.wikipedia.org/wiki/Hexadecimal) (เลขฐาน 16) ถูกใช้อย่างแพร่หลายใน JavaScript เพื่อแสดงสี เข้ารหัสตัวอักษร และอื่นๆ อีกมากมาย ดังนั้นจึงมีวิธีเขียนที่สั้นกว่า: `0x` แล้วตามด้วยตัวเลข

ตัวอย่างเช่น:

```js run
alert( 0xff ); // 255
alert( 0xFF ); // 255 (เหมือนกัน ตัวพิมพ์เล็กหรือใหญ่ไม่สำคัญ)
```

ระบบตัวเลขฐานสองและฐานแปดใช้น้อย แต่ก็รองรับเช่นกันโดยใช้คำนำหน้า `0b` และ `0o`:


```js run
let a = 0b11111111; // รูปแบบเลขฐานสองของ 255
let b = 0o377; // รูปแบบเลขฐานแปดของ 255

alert( a == b ); // จริง, เป็นตัวเลข 255 เหมือนกันทั้งสองฝั่ง
```

มีเพียง 3 ระบบตัวเลขที่รองรับแบบนี้ สำหรับระบบตัวเลขอื่นๆ เราควรใช้ฟังก์ชัน `parseInt` (ซึ่งเราจะเห็นในภายหลังในบทนี้)

## toString(base)

วิธีการ `num.toString(base)` คืนค่าการแสดงผลเป็นสตริงของ `num` ในระบบตัวเลขที่มีฐานที่กำหนด

ตัวอย่างเช่น:
```js run
let num = 255;

alert( num.toString(16) );  // ff
alert( num.toString(2) );   // 11111111
```

`base` สามารถมีค่าตั้งแต่ `2` ถึง `36` โดยค่าเริ่มต้นคือ `10`

กรณีการใช้งานทั่วไปสำหรับสิ่งนี้คือ:

- **base=16** ใช้สำหรับสีในรูปแบบเลขฐานสิบหก, การเข้ารหัสตัวอักษร ฯลฯ ตัวเลขสามารถเป็น `0..9` หรือ `A..F`
- **base=2** ส่วนใหญ่ใช้สำหรับการแก้ไขข้อผิดพลาดของการดำเนินการระดับบิต ตัวเลขสามารถเป็น `0` หรือ `1`
- **base=36** เป็นค่าสูงสุด ตัวเลขสามารถเป็น `0..9` หรือ `A..Z` ตัวอักษรละตินทั้งหมดถูกใช้เพื่อแสดงตัวเลข กรณีที่สนุกแต่มีประโยชน์สำหรับ `36` คือเมื่อเราต้องการเปลี่ยนตัวระบุตัวเลขที่ยาวให้เป็นอะไรที่สั้นกว่า เช่น เพื่อสร้าง URL สั้น เราสามารถแสดงมันในระบบตัวเลขฐาน `36` ได้ง่ายๆ:

    ```js run
    alert( 123456..toString(36) ); // 2n9c
    ```

```warn header="จุดสองจุดเพื่อเรียกใช้วิธีการ"
โปรดทราบว่าจุดสองจุดใน `123456..toString(36)` ไม่ใช่ข้อผิดพลาดในการพิมพ์ หากเราต้องการเรียกใช้วิธีการโดยตรงกับตัวเลข เช่น `toString` ในตัวอย่างข้างต้น เราต้องวางจุดสองจุด `..` หลังจากนั้น

หากเราวางจุดเดียว: `123456.toString(36)` จะเกิดข้อผิดพลาด เพราะไวยากรณ์ JavaScript บอกว่าส่วนทศนิยมอยู่หลังจุดแรก และถ้าเราวางจุดอีกหนึ่งจุด JavaScript จะรู้ว่าส่วนทศนิยมว่างเปล่าและตอนนี้มาถึงวิธีการแล้ว

เราสามารถเขียน `(123456).toString(36)` ได้เช่นกัน

```

## การปัดเศษ

หนึ่งในการดำเนินการที่ใช้บ่อยที่สุดเมื่อทำงานกับตัวเลขคือการปัดเศษ

มีฟังก์ชันในตัวหลายตัวสำหรับการปัดเศษ:

`Math.floor`
: ปัดลง: `3.1` กลายเป็น `3`, และ `-1.1` กลายเป็น `-2`

`Math.ceil`
: ปัดขึ้น: `3.1` กลายเป็น `4`, และ `-1.1` กลายเป็น `-1`

`Math.round`
: ปัดเศษไปยังจำนวนเต็มที่ใกล้ที่สุด: `3.1` กลายเป็น `3`, `3.6` กลายเป็น `4`, กรณีกึ่งกลาง: `3.5` ปัดขึ้นเป็น `4` เช่นกัน

`Math.trunc` (ไม่รองรับโดย Internet Explorer)
: ลบทุกอย่างหลังจุดทศนิยมโดยไม่ปัดเศษ: `3.1` กลายเป็น `3`, `-1.1` กลายเป็น `-1`

นี่คือตารางสรุปความแตกต่างระหว่างพวกมัน:

|   | `Math.floor` | `Math.ceil` | `Math.round` | `Math.trunc` |
|---|---------|--------|---------|---------|
|`3.1`|  `3`    |   `4`  |    `3`  |   `3`   |
|`3.6`|  `3`    |   `4`  |    `4`  |   `3`   |
|`-1.1`|  `-2`    |   `-1`  |    `-1`  |   `-1`   |
|`-1.6`|  `-2`    |   `-1`  |    `-2`  |   `-1`   |


ฟังก์ชันเหล่านี้ครอบคลุมทุกวิธีที่เป็นไปได้ในการจัดการกับส่วนทศนิยมของตัวเลข แต่ถ้าเราต้องการปัดเศษตัวเลขไปยังตำแหน่งทศนิยมที่ `n` ล่ะ?

ตัวอย่างเช่น เรามี `1.2345` และต้องการปัดเศษให้เหลือ 2 ตำแหน่งทศนิยม ให้ได้เพียง `1.23`

มีสองวิธีในการทำเช่นนี้:

1. คูณและหาร

    ตัวอย่างเช่น เพื่อปัดเศษตัวเลขไปยังตำแหน่งทศนิยมที่ 2 เราสามารถคูณตัวเลขด้วย `100` (หรือกำลังที่มากกว่าของ 10) เรียกใช้ฟังก์ชันปัดเศษ และจากนั้นหารกลับ
    ```js run
    let num = 1.23456;

    alert( Math.round(num * 100) / 100 ); // 1.23456 -> 123.456 -> 123 -> 1.23
    ```

2. วิธีการ [toFixed(n)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) ปัดเศษตัวเลขไปยัง `n` ตำแหน่งหลังจุดทศนิยมและคืนค่าการแสดงผลเป็นสตริง

    ```js run
    let num = 12.34;
    alert( num.toFixed(1) ); // "12.3"
    ```

    วิธีนี้ปัดขึ้นหรือลงไปยังค่าที่ใกล้ที่สุด คล้ายกับ `Math.round`:

    ```js run
    let num = 12.36;
    alert( num.toFixed(1) ); // "12.4"
    ```

    โปรดทราบว่าผลลัพธ์ของ `toFixed` เป็นสตริง หากส่วนทศนิยมสั้นกว่าที่ต้องการ จะมีการเพิ่มศูนย์ต่อท้าย:

    ```js run
    let num = 12.34;
    alert( num.toFixed(5) ); // "12.34000", เพิ่มศูนย์เพื่อให้ได้ 5 หลักพอดี
    ```

    เราสามารถแปลงมันเป็นตัวเลขโดยใช้เครื่องหมายบวกเดี่ยวหรือการเรียก `Number()`: `+num.toFixed(5)`

## การคำนวณที่ไม่แม่นยำ

ภายใน ตัวเลขถูกแสดงในรูปแบบ 64 บิต [IEEE-754](https://en.wikipedia.org/wiki/IEEE_754-2008_revision) ดังนั้นจึงมีบิตทั้งหมด 64 บิตเพื่อเก็บตัวเลข: 52 บิตใช้เพื่อเก็บตัวเลข, 11 บิตเก็บตำแหน่งของจุดทศนิยม (เป็นศูนย์สำหรับจำนวนเต็ม), และ 1 บิตสำหรับเครื่องหมาย

ถ้าตัวเลขใหญ่เกินไป มันจะล้นพื้นที่เก็บข้อมูล 64 บิต ซึ่งอาจให้ผลเป็นอนันต์:

```js run
alert( 1e500 ); // Infinity
```

สิ่งที่อาจเห็นได้ไม่ชัดเจนนัก แต่เกิดขึ้นบ่อยมาก คือการสูญเสียความแม่นยำ

พิจารณาการทดสอบนี้ (ที่ให้ผลเป็นเท็จ!):

```js run
alert( 0.1 + 0.2 == 0.3 ); // *!*เท็จ*/!*
```

ถูกต้อง ถ้าเราตรวจสอบว่าผลรวมของ `0.1` และ `0.2` เป็น `0.3` เราจะได้ `เท็จ`

แปลก! แล้วมันคืออะไรถ้าไม่ใช่ `0.3`?

```js run
alert( 0.1 + 0.2 ); // 0.30000000000000004
```

โอ้! มีผลกระทบมากกว่าการเปรียบเทียบที่ไม่ถูกต้องที่นี่ ลองนึกภาพว่าคุณกำลังทำเว็บไซต์ขายของออนไลน์ และผู้เข้าชมใส่สินค้ามูลค่า `$0.10` และ `$0.20` ลงในตะกร้า ยอดรวมของคำสั่งซื้อจะเป็น `$0.30000000000000004` ซึ่งจะทำให้ทุกคนประหลาดใจ

แต่ทำไมถึงเกิดเรื่องนี้ขึ้น?

ตัวเลขถูกเก็บในหน่วยความจำในรูปแบบไบนารี ซึ่งเป็นลำดับของบิต - หนึ่งและศูนย์ แต่เศษส่วนเช่น `0.1`, `0.2` ที่ดูเรียบง่ายในระบบตัวเลขฐานสิบ จริงๆ แล้วเป็นเศษส่วนที่ไม่มีที่สิ้นสุดในรูปแบบไบนารีของมัน

กล่าวอีกนัยหนึ่ง `0.1` คืออะไร? มันคือหนึ่งหารด้วยสิบ `1/10` หนึ่งในสิบ ในระบบตัวเลขฐานสิบ ตัวเลขเช่นนี้แสดงได้ง่าย เปรียบเทียบกับหนึ่งในสาม: `1/3` มันกลายเป็นเศษส่วนที่ไม่มีที่สิ้นสุด `0.33333(3)`

ดังนั้น การหารด้วยกำลังของ `10` รับประกันว่าจะทำงานได้ดีในระบบฐานสิบ แต่การหารด้วย `3` ไม่ใช่ ด้วยเหตุผลเดียวกัน ในระบบตัวเลขไบนารี การหารด้วยกำลังของ `2` รับประกันว่าจะทำงานได้ แต่ `1/10` กลายเป็นเศษส่วนไบนารีที่ไม่มีที่สิ้นสุด

ไม่มีทางที่จะเก็บ *0.1 หรือ 0.2 อย่างแม่นยำ* โดยใช้ระบบไบนารี เช่นเดียวกับที่ไม่มีทางเก็บหนึ่งในสามเป็นเศษส่วนทศนิยม

รูปแบบตัวเลข IEEE-754 แก้ปัญหานี้โดยการปัดเศษไปยังตัวเลขที่ใกล้ที่สุดที่เป็นไปได้ กฎการปัดเศษเหล่านี้ปกติแล้วไม่อนุญาตให้เราเห็น "การสูญเสียความแม่นยำเล็กน้อย" นั้น แต่มันมีอยู่

เราสามารถเห็นสิ่งนี้ในการทำงาน:
```js run
alert( 0.1.toFixed(20) ); // 0.10000000000000000555
```

และเมื่อเรารวมสองตัวเลข "การสูญเสียความแม่นยำ" ของพวกมันจะรวมกัน

นั่นคือเหตุผลที่ `0.1 + 0.2` ไม่ใช่ `0.3` อย่างแม่นยำ

```smart header="ไม่ใช่แค่ JavaScript"
ปัญหาเดียวกันนี้มีอยู่ในภาษาโปรแกรมอื่นๆ หลายภาษา

PHP, Java, C, Perl, Ruby ให้ผลลัพธ์เดียวกันพอดี เพราะพวกมันใช้รูปแบบตัวเลขเดียวกัน
```

เราสามารถแก้ไขปัญหานี้ได้ไหม? แน่นอน วิธีที่น่าเชื่อถือที่สุดคือการปัดเศษผลลัพธ์โดยใช้วิธีการ [toFixed(n)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed):

```js run
let sum = 0.1 + 0.2;
alert( sum.toFixed(2) ); // 0.30
```

โปรดทราบว่า `toFixed` มักจะคืนค่าเป็นสตริงเสมอ มันรับประกันว่าจะมี 2 ตำแหน่งหลังจุดทศนิยม นั่นจริงๆ แล้วสะดวกถ้าเรามีร้านค้าออนไลน์และต้องการแสดง `$0.30` สำหรับกรณีอื่นๆ เราสามารถใช้เครื่องหมายบวกเดี่ยวเพื่อบังคับให้เป็นตัวเลข:

```js run
let sum = 0.1 + 0.2;
alert( +sum.toFixed(2) ); // 0.3
```

เราสามารถคูณตัวเลขด้วย 100 (หรือตัวเลขที่ใหญ่กว่า) ชั่วคราวเพื่อเปลี่ยนให้เป็นจำนวนเต็ม ทำการคำนวณทางคณิตศาสตร์ และจากนั้นหารกลับ จากนั้น เนื่องจากเรากำลังทำการคำนวณทางคณิตศาสตร์กับจำนวนเต็ม ข้อผิดพลาดจะลดลงบ้าง แต่เรายังคงได้รับข้อผิดพลาดเมื่อหาร:

```js run
alert( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3
alert( (0.28 * 100 + 0.14 * 100) / 100); // 0.4200000000000001
```

ดังนั้น วิธีการคูณ/หารลดข้อผิดพลาด แต่ไม่ได้กำจัดมันออกไปทั้งหมด

บางครั้งเราอาจพยายามหลีกเลี่ยงเศษส่วนทั้งหมด เช่น ถ้าเรากำลังจัดการกับร้านค้า เราสามารถเก็บราคาในหน่วยเซ็นต์แทนดอลลาร์ แต่ถ้าเราใช้ส่วนลด 30% ล่ะ? ในทางปฏิบัติ การหลีกเลี่ยงเศษส่วนทั้งหมดแทบจะเป็นไปไม่ได้ เพียงแค่ปัดเศษเพื่อตัด "หาง" เมื่อจำเป็น

````smart header="เรื่องตลก"
ลองรันสิ่งนี้ดู:

```js run
// สวัสดี! ฉันเป็นตัวเลขที่เพิ่มขึ้นเอง!
alert( 9999999999999999 ); // แสดง 10000000000000000
```

สิ่งนี้เกิดจากปัญหาเดียวกัน: การสูญเสียความแม่นยำ มี 64 บิตสำหรับตัวเลข, 52 บิตสามารถใช้เพื่อเก็บตัวเลข แต่นั่นไม่เพียงพอ ดังนั้นตัวเลขที่มีนัยสำคัญน้อยที่สุดจึงหายไป

JavaScript ไม่ทำให้เกิดข้อผิดพลาดในเหตุการณ์เช่นนี้ มันพยายามอย่างดีที่สุดเพื่อให้ตัวเลขพอดีกับรูปแบบที่ต้องการ แต่น่าเสียดายที่รูปแบบนี้ไม่ใหญ่พอ
````

```smart header="ศูนย์สองตัว"