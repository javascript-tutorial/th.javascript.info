# ตัวเลข

ในภาษา JavaScript สมัยใหม่ มีตัวเลขอยู่สองประเภท:

1. ตัวเลขปกติใน JavaScript จะถูกเก็บในรูปแบบ 64 บิต [IEEE-754](https://en.wikipedia.org/wiki/IEEE_754-2008_revision) ซึ่งเรียกอีกอย่างว่า "จำนวนทศนิยมความแม่นยำสองเท่า" (double precision floating point numbers) ตัวเลขเหล่านี้เป็นตัวเลขที่เราใช้บ่อยที่สุด และเราจะพูดถึงมันในบทนี้

2. ตัวเลข BigInt เพื่อแสดงจำนวนเต็มที่มีความยาวไม่จำกัด บางครั้งจำเป็นต้องใช้เนื่องจากตัวเลขปกติไม่สามารถเกิน <code>2<sup>53</sup></code> หรือน้อยกว่า <code>-2<sup>53</sup></code> ได้อย่างปลอดภัย เนื่องจาก bigints ใช้ในบางพื้นที่พิเศษเท่านั้น เราจึงอุทิศบทพิเศษให้กับมัน <info:bigint>

ดังนั้นในที่นี้เราจะพูดถึงตัวเลขปกติ มาขยายความรู้เกี่ยวกับมันกันเถอะ

## วิธีเขียนตัวเลขเพิ่มเติม

สมมติว่าเราต้องการเขียนตัวเลขหนึ่งพันล้าน วิธีที่เห็นได้ชัดคือ:

```js
let billion = 1000000000;
```

เราสามารถใช้เครื่องหมายขีดล่าง `_` เป็นตัวคั่นได้:

```js
let billion = 1_000_000_000;
```

ในที่นี้ เครื่องหมายขีดล่าง `_` ทำหน้าที่เป็น "น้ำตาลทางไวยากรณ์" (syntactic sugar) ทำให้ตัวเลขอ่านง่ายขึ้น เครื่องยนต์ JavaScript จะละเลย `_` ระหว่างตัวเลข ดังนั้นมันจึงเป็นตัวเลขหนึ่งพันล้านเหมือนกันกับข้างบน

ในชีวิตจริง เราพยายามหลีกเลี่ยงการเขียนเลขศูนย์ต่อกันยาวๆ เราขี้เกียจเกินไป เราจะพยายามเขียนอะไรประมาณ `"1bn"` สำหรับหนึ่งพันล้าน หรือ `"7.3bn"` สำหรับเจ็ดพันสามร้อยล้าน สิ่งเดียวกันนี้เป็นจริงสำหรับตัวเลขขนาดใหญ่ส่วนใหญ่

ใน JavaScript เราสามารถย่อตัวเลขโดยเพิ่มตัวอักษร `"e"` ต่อท้ายและระบุจำนวนศูนย์:

```js run
let billion = 1e9;  // 1 พันล้าน ตามตัวอักษร: 1 และตามด้วยศูนย์ 9 ตัว

alert( 7.3e9 );  // 7.3 พันล้าน (เหมือนกับ 7300000000 หรือ 7_300_000_000)
```

กล่าวอีกนัยหนึ่ง `e` คูณตัวเลขด้วย `1` ตามด้วยจำนวนศูนย์ที่กำหนด

```js
1e3 === 1 * 1000; // e3 หมายถึง *1000
1.23e6 === 1.23 * 1000000; // e6 หมายถึง *1000000
```

ตอนนี้มาเขียนอะไรที่เล็กมากๆ กัน สมมติว่า 1 ไมโครวินาที (หนึ่งในล้านของวินาที):

```js
let mсs = 0.000001;
```

เช่นเดียวกับก่อนหน้านี้ การใช้ `"e"` สามารถช่วยได้ ถ้าเราไม่อยากเขียนศูนย์อย่างชัดเจน เราสามารถพูดเหมือนกันได้ว่า:

```js
let mcs = 1e-6; // ศูนย์หกตัวทางซ้ายของ 1
```

ถ้าเรานับจำนวนศูนย์ใน `0.000001` จะมีศูนย์อยู่ 6 ตัว ดังนั้นจึงเป็น `1e-6` ตามธรรมชาติ

กล่าวอีกนัยหนึ่ง ตัวเลขติดลบหลัง `"e"` หมายถึงการหารด้วย 1 ตามด้วยจำนวนศูนย์ที่กำหนด:

```js
// -3 หารด้วย 1 ตามด้วยศูนย์ 3 ตัว
1e-3 === 1 / 1000; // 0.001

// -6 หารด้วย 1 ตามด้วยศูนย์ 6 ตัว
1.23e-6 === 1.23 / 1000000; // 0.00000123
```

### ตัวเลขฐานสิบหก ฐานสอง และฐานแปด

[ตัวเลขฐานสิบหก](https://en.wikipedia.org/wiki/Hexadecimal) (เลขฐาน 16) ถูกใช้อย่างแพร่หลายใน JavaScript เพื่อแสดงสี เข้ารหัสตัวอักษร และอื่นๆ อีกมากมาย ดังนั้นจึงมีวิธีเขียนที่สั้นกว่า: `0x` แล้วตามด้วยตัวเลข

ตัวอย่างเช่น:

```js run
alert( 0xff ); // 255
alert( 0xFF ); // 255 (เหมือนกัน ตัวพิมพ์เล็กหรือใหญ่ไม่สำคัญ)
```

ระบบตัวเลขฐานสองและฐานแปดใช้น้อย แต่ก็รองรับเช่นกันโดยใช้คำนำหน้า `0b` และ `0o`:


```js run
let a = 0b11111111; // รูปแบบเลขฐานสองของ 255
let b = 0o377; // รูปแบบเลขฐานแปดของ 255

alert( a == b ); // จริง, เป็นตัวเลข 255 เหมือนกันทั้งสองฝั่ง
```

มีเพียง 3 ระบบตัวเลขที่รองรับแบบนี้ สำหรับระบบตัวเลขอื่นๆ เราควรใช้ฟังก์ชัน `parseInt` (ซึ่งเราจะเห็นในภายหลังในบทนี้)

## toString(base)

วิธีการ `num.toString(base)` คืนค่าการแสดงผลเป็นสตริงของ `num` ในระบบตัวเลขที่มีฐานที่กำหนด

ตัวอย่างเช่น:
```js run
let num = 255;

alert( num.toString(16) );  // ff
alert( num.toString(2) );   // 11111111
```

`base` สามารถมีค่าตั้งแต่ `2` ถึง `36` โดยค่าเริ่มต้นคือ `10`

กรณีการใช้งานทั่วไปสำหรับสิ่งนี้คือ:

- **base=16** ใช้สำหรับสีในรูปแบบเลขฐานสิบหก, การเข้ารหัสตัวอักษร ฯลฯ ตัวเลขสามารถเป็น `0..9` หรือ `A..F`
- **base=2** ส่วนใหญ่ใช้สำหรับการแก้ไขข้อผิดพลาดของการดำเนินการระดับบิต ตัวเลขสามารถเป็น `0` หรือ `1`
- **base=36** เป็นค่าสูงสุด ตัวเลขสามารถเป็น `0..9` หรือ `A..Z` ตัวอักษรละตินทั้งหมดถูกใช้เพื่อแสดงตัวเลข กรณีที่สนุกแต่มีประโยชน์สำหรับ `36` คือเมื่อเราต้องการเปลี่ยนตัวระบุตัวเลขที่ยาวให้เป็นอะไรที่สั้นกว่า เช่น เพื่อสร้าง URL สั้น เราสามารถแสดงมันในระบบตัวเลขฐาน `36` ได้ง่ายๆ:

    ```js run
    alert( 123456..toString(36) ); // 2n9c
    ```

```warn header="จุดสองจุดเพื่อเรียกใช้วิธีการ"
โปรดทราบว่าจุดสองจุดใน `123456..toString(36)` ไม่ใช่ข้อผิดพลาดในการพิมพ์ หากเราต้องการเรียกใช้วิธีการโดยตรงกับตัวเลข เช่น `toString` ในตัวอย่างข้างต้น เราต้องวางจุดสองจุด `..` หลังจากนั้น

หากเราวางจุดเดียว: `123456.toString(36)` จะเกิดข้อผิดพลาด เพราะไวยากรณ์ JavaScript บอกว่าส่วนทศนิยมอยู่หลังจุดแรก และถ้าเราวางจุดอีกหนึ่งจุด JavaScript จะรู้ว่าส่วนทศนิยมว่างเปล่าและตอนนี้มาถึงวิธีการแล้ว

เราสามารถเขียน `(123456).toString(36)` ได้เช่นกัน

```

## การปัดเศษ

หนึ่งในการดำเนินการที่ใช้บ่อยที่สุดเมื่อทำงานกับตัวเลขคือการปัดเศษ

มีฟังก์ชันในตัวหลายตัวสำหรับการปัดเศษ:

`Math.floor`
: ปัดลง: `3.1` กลายเป็น `3`, และ `-1.1` กลายเป็น `-2`

`Math.ceil`
: ปัดขึ้น: `3.1` กลายเป็น `4`, และ `-1.1` กลายเป็น `-1`

`Math.round`
: ปัดเศษไปยังจำนวนเต็มที่ใกล้ที่สุด: `3.1` กลายเป็น `3`, `3.6` กลายเป็น `4`, กรณีกึ่งกลาง: `3.5` ปัดขึ้นเป็น `4` เช่นกัน

`Math.trunc` (ไม่รองรับโดย Internet Explorer)
: ลบทุกอย่างหลังจุดทศนิยมโดยไม่ปัดเศษ: `3.1` กลายเป็น `3`, `-1.1` กลายเป็น `-1`

นี่คือตารางสรุปความแตกต่างระหว่างพวกมัน:

|   | `Math.floor` | `Math.ceil` | `Math.round` | `Math.trunc` |
|---|---------|--------|---------|---------|
|`3.1`|  `3`    |   `4`  |    `3`  |   `3`   |
|`3.6`|  `3`    |   `4`  |    `4`  |   `3`   |
|`-1.1`|  `-2`    |   `-1`  |    `-1`  |   `-1`   |
|`-1.6`|  `-2`    |   `-1`  |    `-2`  |   `-1`   |


ฟังก์ชันเหล่านี้ครอบคลุมทุกวิธีที่เป็นไปได้ในการจัดการกับส่วนทศนิยมของตัวเลข แต่ถ้าเราต้องการปัดเศษตัวเลขไปยังตำแหน่งทศนิยมที่ `n` ล่ะ?

ตัวอย่างเช่น เรามี `1.2345` และต้องการปัดเศษให้เหลือ 2 ตำแหน่งทศนิยม ให้ได้เพียง `1.23`

มีสองวิธีในการทำเช่นนี้:

1. คูณและหาร

    ตัวอย่างเช่น เพื่อปัดเศษตัวเลขไปยังตำแหน่งทศนิยมที่ 2 เราสามารถคูณตัวเลขด้วย `100` (หรือกำลังที่มากกว่าของ 10) เรียกใช้ฟังก์ชันปัดเศษ และจากนั้นหารกลับ
    ```js run
    let num = 1.23456;

    alert( Math.round(num * 100) / 100 ); // 1.23456 -> 123.456 -> 123 -> 1.23
    ```

2. วิธีการ [toFixed(n)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) ปัดเศษตัวเลขไปยัง `n` ตำแหน่งหลังจุดทศนิยมและคืนค่าการแสดงผลเป็นสตริง

    ```js run
    let num = 12.34;
    alert( num.toFixed(1) ); // "12.3"
    ```

    วิธีนี้ปัดขึ้นหรือลงไปยังค่าที่ใกล้ที่สุด คล้ายกับ `Math.round`:

    ```js run
    let num = 12.36;
    alert( num.toFixed(1) ); // "12.4"
    ```

    โปรดทราบว่าผลลัพธ์ของ `toFixed` เป็นสตริง หากส่วนทศนิยมสั้นกว่าที่ต้องการ จะมีการเพิ่มศูนย์ต่อท้าย:

    ```js run
    let num = 12.34;
    alert( num.toFixed(5) ); // "12.34000", เพิ่มศูนย์เพื่อให้ได้ 5 หลักพอดี
    ```

    เราสามารถแปลงมันเป็นตัวเลขโดยใช้เครื่องหมายบวกเดี่ยวหรือการเรียก `Number()`: `+num.toFixed(5)`

## การคำนวณที่ไม่แม่นยำ

ภายใน ตัวเลขถูกแสดงในรูปแบบ 64 บิต [IEEE-754](https://en.wikipedia.org/wiki/IEEE_754-2008_revision) ดังนั้นจึงมีบิตทั้งหมด 64 บิตเพื่อเก็บตัวเลข: 52 บิตใช้เพื่อเก็บตัวเลข, 11 บิตเก็บตำแหน่งของจุดทศนิยม (เป็นศูนย์สำหรับจำนวนเต็ม), และ 1 บิตสำหรับเครื่องหมาย

ถ้าตัวเลขใหญ่เกินไป มันจะล้นพื้นที่เก็บข้อมูล 64 บิต ซึ่งอาจให้ผลเป็นอนันต์:

```js run
alert( 1e500 ); // Infinity
```

สิ่งที่อาจเห็นได้ไม่ชัดเจนนัก แต่เกิดขึ้นบ่อยมาก คือการสูญเสียความแม่นยำ

พิจารณาการทดสอบนี้ (ที่ให้ผลเป็นเท็จ!):

```js run
alert( 0.1 + 0.2 == 0.3 ); // *!*เท็จ*/!*
```

ถูกต้อง ถ้าเราตรวจสอบว่าผลรวมของ `0.1` และ `0.2` เป็น `0.3` เราจะได้ `เท็จ`

แปลก! แล้วมันคืออะไรถ้าไม่ใช่ `0.3`?

```js run
alert( 0.1 + 0.2 ); // 0.30000000000000004
```

โอ้! มีผลกระทบมากกว่าการเปรียบเทียบที่ไม่ถูกต้องที่นี่ ลองนึกภาพว่าคุณกำลังทำเว็บไซต์ขายของออนไลน์ และผู้เข้าชมใส่สินค้ามูลค่า `$0.10` และ `$0.20` ลงในตะกร้า ยอดรวมของคำสั่งซื้อจะเป็น `$0.30000000000000004` ซึ่งจะทำให้ทุกคนประหลาดใจ

แต่ทำไมถึงเกิดเรื่องนี้ขึ้น?

ตัวเลขถูกเก็บในหน่วยความจำในรูปแบบไบนารี ซึ่งเป็นลำดับของบิต - หนึ่งและศูนย์ แต่เศษส่วนเช่น `0.1`, `0.2` ที่ดูเรียบง่ายในระบบตัวเลขฐานสิบ จริงๆ แล้วเป็นเศษส่วนที่ไม่มีที่สิ้นสุดในรูปแบบไบนารีของมัน

กล่าวอีกนัยหนึ่ง `0.1` คืออะไร? มันคือหนึ่งหารด้วยสิบ `1/10` หนึ่งในสิบ ในระบบตัวเลขฐานสิบ ตัวเลขเช่นนี้แสดงได้ง่าย เปรียบเทียบกับหนึ่งในสาม: `1/3` มันกลายเป็นเศษส่วนที่ไม่มีที่สิ้นสุด `0.33333(3)`

ดังนั้น การหารด้วยกำลังของ `10` รับประกันว่าจะทำงานได้ดีในระบบฐานสิบ แต่การหารด้วย `3` ไม่ใช่ ด้วยเหตุผลเดียวกัน ในระบบตัวเลขไบนารี การหารด้วยกำลังของ `2` รับประกันว่าจะทำงานได้ แต่ `1/10` กลายเป็นเศษส่วนไบนารีที่ไม่มีที่สิ้นสุด

ไม่มีทางที่จะเก็บ *0.1 หรือ 0.2 อย่างแม่นยำ* โดยใช้ระบบไบนารี เช่นเดียวกับที่ไม่มีทางเก็บหนึ่งในสามเป็นเศษส่วนทศนิยม

รูปแบบตัวเลข IEEE-754 แก้ปัญหานี้โดยการปัดเศษไปยังตัวเลขที่ใกล้ที่สุดที่เป็นไปได้ กฎการปัดเศษเหล่านี้ปกติแล้วไม่อนุญาตให้เราเห็น "การสูญเสียความแม่นยำเล็กน้อย" นั้น แต่มันมีอยู่

เราสามารถเห็นสิ่งนี้ในการทำงาน:
```js run
alert( 0.1.toFixed(20) ); // 0.10000000000000000555
```

และเมื่อเรารวมสองตัวเลข "การสูญเสียความแม่นยำ" ของพวกมันจะรวมกัน

นั่นคือเหตุผลที่ `0.1 + 0.2` ไม่ใช่ `0.3` อย่างแม่นยำ

```smart header="ไม่ใช่แค่ JavaScript"
ปัญหาเดียวกันนี้มีอยู่ในภาษาโปรแกรมอื่นๆ หลายภาษา

PHP, Java, C, Perl, Ruby ให้ผลลัพธ์เดียวกันพอดี เพราะพวกมันใช้รูปแบบตัวเลขเดียวกัน
```

เราสามารถแก้ไขปัญหานี้ได้ไหม? แน่นอน วิธีที่น่าเชื่อถือที่สุดคือการปัดเศษผลลัพธ์โดยใช้วิธีการ [toFixed(n)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed):

```js run
let sum = 0.1 + 0.2;
alert( sum.toFixed(2) ); // 0.30
```

โปรดทราบว่า `toFixed` มักจะคืนค่าเป็นสตริงเสมอ มันรับประกันว่าจะมี 2 ตำแหน่งหลังจุดทศนิยม นั่นจริงๆ แล้วสะดวกถ้าเรามีร้านค้าออนไลน์และต้องการแสดง `$0.30` สำหรับกรณีอื่นๆ เราสามารถใช้เครื่องหมายบวกเดี่ยวเพื่อบังคับให้เป็นตัวเลข:

```js run
let sum = 0.1 + 0.2;
alert( +sum.toFixed(2) ); // 0.3
```

เราสามารถคูณตัวเลขด้วย 100 (หรือตัวเลขที่ใหญ่กว่า) ชั่วคราวเพื่อเปลี่ยนให้เป็นจำนวนเต็ม ทำการคำนวณทางคณิตศาสตร์ และจากนั้นหารกลับ จากนั้น เนื่องจากเรากำลังทำการคำนวณทางคณิตศาสตร์กับจำนวนเต็ม ข้อผิดพลาดจะลดลงบ้าง แต่เรายังคงได้รับข้อผิดพลาดเมื่อหาร:

```js run
alert( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3
alert( (0.28 * 100 + 0.14 * 100) / 100); // 0.4200000000000001
```

ดังนั้น วิธีการคูณ/หารลดข้อผิดพลาด แต่ไม่ได้กำจัดมันออกไปทั้งหมด

บางครั้งเราอาจพยายามหลีกเลี่ยงเศษส่วนทั้งหมด เช่น ถ้าเรากำลังจัดการกับร้านค้า เราสามารถเก็บราคาในหน่วยเซ็นต์แทนดอลลาร์ แต่ถ้าเราใช้ส่วนลด 30% ล่ะ? ในทางปฏิบัติ การหลีกเลี่ยงเศษส่วนทั้งหมดแทบจะเป็นไปไม่ได้ เพียงแค่ปัดเศษเพื่อตัด "หาง" เมื่อจำเป็น

````smart header="เรื่องตลก"
ลองรันสิ่งนี้ดู:

```js run
// สวัสดี! ฉันเป็นตัวเลขที่เพิ่มขึ้นเอง!
alert( 9999999999999999 ); // แสดง 10000000000000000
```

สิ่งนี้เกิดจากปัญหาเดียวกัน: การสูญเสียความแม่นยำ มี 64 บิตสำหรับตัวเลข, 52 บิตสามารถใช้เพื่อเก็บตัวเลข แต่นั่นไม่เพียงพอ ดังนั้นตัวเลขที่มีนัยสำคัญน้อยที่สุดจึงหายไป

JavaScript ไม่ทำให้เกิดข้อผิดพลาดในเหตุการณ์เช่นนี้ มันพยายามอย่างดีที่สุดเพื่อให้ตัวเลขพอดีกับรูปแบบที่ต้องการ แต่น่าเสียดายที่รูปแบบนี้ไม่ใหญ่พอ
````

```smart header="ศูนย์สองตัว"
ผลที่ตลกอีกอย่างหนึ่งของการแสดงตัวเลขภายในคือการมีศูนย์สองตัว: `0` และ `-0`

นั่นเป็นเพราะเครื่องหมายถูกแสดงด้วยบิตเดียว ดังนั้นจึงสามารถตั้งค่าหรือไม่ตั้งค่าสำหรับตัวเลขใดๆ รวมถึงศูนย์

ในกรณีส่วนใหญ่ ความแตกต่างไม่สามารถสังเกตเห็นได้ เพราะตัวดำเนินการถูกปรับให้ปฏิบัติต่อพวกมันเหมือนกัน
```

## การทดสอบ: isFinite และ isNaN

จำค่าตัวเลขพิเศษสองตัวนี้ได้ไหม?

- `Infinity` (และ `-Infinity`) เป็นค่าตัวเลขพิเศษที่มากกว่า (น้อยกว่า) ทุกอย่าง
- `NaN` แสดงถึงข้อผิดพลาด

พวกมันเป็นของประเภท `number` แต่ไม่ใช่ตัวเลข "ปกติ" ดังนั้นจึงมีฟังก์ชันพิเศษเพื่อตรวจสอบพวกมัน:


- `isNaN(value)` แปลงอาร์กิวเมนต์ของมันเป็นตัวเลขและจากนั้นทดสอบว่าเป็น `NaN`:

    ```js run
    alert( isNaN(NaN) ); // จริง
    alert( isNaN("str") ); // จริง
    ```

    แต่เราจำเป็นต้องใช้ฟังก์ชันนี้หรือไม่? เราไม่สามารถใช้การเปรียบเทียบ `=== NaN` ได้หรือ? ขอโทษ แต่คำตอบคือไม่ได้ ค่า `NaN` เป็นเอกลักษณ์ในการที่มันไม่เท่ากับอะไรเลย รวมถึงตัวมันเอง:

    ```js run
    alert( NaN === NaN ); // เท็จ
    ```

- `isFinite(value)` แปลงอาร์กิวเมนต์ของมันเป็นตัวเลขและคืนค่า `จริง` ถ้ามันเป็นตัวเลขปกติ ไม่ใช่ `NaN/Infinity/-Infinity`:

    ```js run
    alert( isFinite("15") ); // จริง
    alert( isFinite("str") ); // เท็จ เพราะเป็นค่าพิเศษ: NaN
    alert( isFinite(Infinity) ); // เท็จ เพราะเป็นค่าพิเศษ: Infinity
    ```

บางครั้ง `isFinite` ถูกใช้เพื่อตรวจสอบว่าค่าสตริงเป็นตัวเลขปกติหรือไม่:


```js run
let num = +prompt("ป้อนตัวเลข", '');

// จะเป็นจริงยกเว้นคุณป้อน Infinity, -Infinity หรือไม่ใช่ตัวเลข
alert( isFinite(num) );
```

โปรดทราบว่าสตริงว่างเปล่าหรือสตริงที่มีเฉพาะช่องว่างจะถูกปฏิบัติเป็น `0` ในทุกฟังก์ชันตัวเลขรวมถึง `isFinite`

```smart header="เปรียบเทียบกับ `Object.is`"

มีวิธีการในตัวพิเศษ [`Object.is`](mdn:js/Object/is) ที่เปรียบเทียบค่าเหมือน `===` แต่น่าเชื่อถือมากกว่าสำหรับสองกรณีพิเศษ:

1. มันทำงานกับ `NaN`: `Object.is(NaN, NaN) === true` นั่นเป็นสิ่งที่ดี
2. ค่า `0` และ `-0` แตกต่างกัน: `Object.is(0, -0) === false` ทางเทคนิคแล้วนั่นเป็นความจริง เพราะภายในตัวเลขมีบิตเครื่องหมายที่อาจแตกต่างกันแม้ว่าบิตอื่นๆ ทั้งหมดจะเป็นศูนย์

ในทุกกรณีอื่นๆ `Object.is(a, b)` เหมือนกับ `a === b`

วิธีการเปรียบเทียบนี้มักใช้ในข้อกำหนดของ JavaScript เมื่ออัลกอริทึมภายในต้องการเปรียบเทียบสองค่าว่าเหมือนกันพอดีหรือไม่ มันใช้ `Object.is` (เรียกภายในว่า [SameValue](https://tc39.github.io/ecma262/#sec-samevalue))
```


## parseInt และ parseFloat

การแปลงเป็นตัวเลขโดยใช้เครื่องหมายบวก `+` หรือ `Number()` นั้นเข้มงวด ถ้าค่าไม่ใช่ตัวเลขพอดี มันจะล้มเหลว:

```js run
alert( +"100px" ); // NaN
```

ข้อยกเว้นเพียงอย่างเดียวคือช่องว่างที่อยู่ต้นหรือท้ายสตริง เพราะมันจะถูกละเลย

แต่ในชีวิตจริง เรามักจะมีค่าในหน่วยต่างๆ เช่น `"100px"` หรือ `"12pt"` ใน CSS และในหลายประเทศสัญลักษณ์สกุลเงินจะอยู่หลังจำนวนเงิน ดังนั้นเราจึงมี `"19€"` และต้องการแยกค่าตัวเลขออกมา

นั่นคือสิ่งที่ `parseInt` และ `parseFloat` มีไว้

พวกมัน "อ่าน" ตัวเลขจากสตริงจนกว่าจะไม่สามารถอ่านได้ ในกรณีที่เกิดข้อผิดพลาด ตัวเลขที่รวบรวมได้จะถูกส่งคืน ฟังก์ชัน `parseInt` ส่งคืนจำนวนเต็ม ในขณะที่ `parseFloat` จะส่งคืนตัวเลขที่มีทศนิยม:

```js run
alert( parseInt('100px') ); // 100
alert( parseFloat('12.5em') ); // 12.5

alert( parseInt('12.3') ); // 12, เฉพาะส่วนจำนวนเต็มถูกส่งคืน
alert( parseFloat('12.3.4') ); // 12.3, จุดที่สองหยุดการอ่าน
```

มีสถานการณ์ที่ `parseInt/parseFloat` จะส่งคืน `NaN` มันเกิดขึ้นเมื่อไม่สามารถอ่านตัวเลขได้เลย:

```js run
alert( parseInt('a123') ); // NaN, สัญลักษณ์แรกหยุดกระบวนการ
```

````smart header="อาร์กิวเมนต์ที่สองของ `parseInt(str, radix)`"
ฟังก์ชัน `parseInt()` มีพารามิเตอร์ที่สองซึ่งเป็นตัวเลือก มันระบุฐานของระบบตัวเลข ดังนั้น `parseInt` สามารถแยกวิเคราะห์สตริงของตัวเลขฐานสิบหก ตัวเลขฐานสอง และอื่นๆ ได้:

```js run
alert( parseInt('0xff', 16) ); // 255
alert( parseInt('ff', 16) ); // 255, ไม่มี 0x ก็ทำงานได้

alert( parseInt('2n9c', 36) ); // 123456
```
````

## ฟังก์ชันทางคณิตศาสตร์อื่นๆ

JavaScript มีวัตถุ [Math](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math) ในตัวซึ่งมีไลบรารีขนาดเล็กของฟังก์ชันทางคณิตศาสตร์และค่าคงที่

ตัวอย่างบางส่วน:

`Math.random()`
: ส่งคืนตัวเลขสุ่มตั้งแต่ 0 ถึง 1 (ไม่รวม 1)

    ```js run
    alert( Math.random() ); // 0.1234567894322
    alert( Math.random() ); // 0.5435252343232
    alert( Math.random() ); // ... (ตัวเลขสุ่มใดๆ)
    ```

`Math.max(a, b, c...)` / `Math.min(a, b, c...)`
: ส่งคืนค่าที่มากที่สุด/น้อยที่สุดจากอาร์กิวเมนต์จำนวนใดๆ

    ```js run
    alert( Math.max(3, 5, -10, 0, 1) ); // 5
    alert( Math.min(1, 2) ); // 1
    ```

`Math.pow(n, power)`
: ส่งคืน `n` ยกกำลัง `power`

    ```js run
    alert( Math.pow(2, 10) ); // 2 ยกกำลัง 10 = 1024
    ```

มีฟังก์ชันและค่าคงที่อื่นๆ อีกมากใน `Math` รวมถึงตรีโกณมิติ ซึ่งคุณสามารถพบได้ในเอกสารสำหรับวัตถุ [Math](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math)

## สรุป

การเขียนตัวเลขที่มีศูนย์จำนวนมาก:

- ต่อท้าย `"e"` กับจำนวนศูนย์ไปยังตัวเลข เช่น: `123e6` เหมือนกับ `123` ตามด้วยศูนย์ 6 ตัว `123000000`
- ตัวเลขลบหลัง `"e"` ทำให้ตัวเลขถูกหารด้วย 1 ตามด้วยจำนวนศูนย์ที่กำหนด เช่น `123e-6` หมายถึง `0.000123` (`123` หนึ่งในล้าน)

สำหรับระบบตัวเลขต่างๆ:

- สามารถเขียนตัวเลขโดยตรงในระบบฐานสิบหก (`0x`), ฐานแปด (`0o`) และฐานสอง (`0b`)
- `parseInt(str, base)` แยกวิเคราะห์สตริง `str` เป็นจำนวนเต็มในระบบตัวเลขที่มีฐาน `base`, `2 ≤ base ≤ 36`
- `num.toString(base)` แปลงตัวเลขเป็นสตริงในระบบตัวเลขที่มีฐานที่กำหนด

สำหรับการแปลงค่าเช่น `12pt` และ `100px` เป็นตัวเลข:

- ใช้ `parseInt/parseFloat` สำหรับการแปลง "แบบนุ่มนวล" ซึ่งอ่านตัวเลขจากสตริงและจากนั้นส่งคืนค่าที่สามารถอ่านได้ก่อนเกิดข้อผิดพลาด

สำหรับเศษส่วน:

- ปัดเศษโดยใช้ `Math.floor`, `Math.ceil`, `Math.trunc`, `Math.round` หรือ `num.toFixed(precision)`
- ต้องแน่ใจว่าจำไว้ว่ามีการสูญเสียความแม่นยำเมื่อทำงานกับเศษส่วน

ฟังก์ชันทางคณิตศาสตร์เพิ่มเติม:

- ดูวัตถุ [Math](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math) เมื่อคุณต้องการใช้ ไลบรารีนี้มีขนาดเล็กมาก แต่สามารถครอบคลุมความต้องการทางคณิตศาสตร์ที่สำคัญ
