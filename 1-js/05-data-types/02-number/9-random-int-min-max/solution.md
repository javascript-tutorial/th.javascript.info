# วิธีแก้ที่ง่ายแต่ไม่ถูกต้อง

วิธีที่ง่ายที่สุดแต่ไม่ถูกต้องคือการสร้างค่าจาก `min` ถึง `max` แล้วปัดเศษ:

```js run
function randomInteger(min, max) {
  let rand = min + Math.random() * (max - min); 
  return Math.round(rand);
}

alert( randomInteger(1, 3) );
```

ฟังก์ชันนี้ทำงานได้ แต่ไม่ถูกต้อง โอกาสที่จะได้ค่าขอบ `min` และ `max` น้อยกว่าค่าอื่นๆ สองเท่า

ถ้าคุณรันตัวอย่างข้างบนหลายๆ ครั้ง คุณจะเห็นว่า `2` ปรากฏบ่อยที่สุด

นี่เกิดขึ้นเพราะ `Math.round()` รับตัวเลขสุ่มจากช่วง `1..3` และปัดเศษดังนี้:

```js no-beautify
ค่าจาก 1    ... ถึง 1.4999999999  กลายเป็น 1
ค่าจาก 1.5  ... ถึง 2.4999999999  กลายเป็น 2
ค่าจาก 2.5  ... ถึง 2.9999999999  กลายเป็น 3
```

เราเห็นชัดว่า `1` ได้ค่าน้อยกว่า `2` สองเท่า และเช่นเดียวกันกับ `3`

# วิธีแก้ที่ถูกต้อง

มีหลายวิธีที่ถูกต้องสำหรับโจทย์นี้ หนึ่งในนั้นคือการปรับขอบเขตของช่วง เพื่อให้แน่ใจว่าช่วงเท่ากัน เราสามารถสร้างค่าจาก `0.5 ถึง 3.5` เพื่อเพิ่มโอกาสที่ต้องการให้กับขอบ:

```js run
function randomInteger(min, max) {
  // ตอนนี้ rand อยู่ระหว่าง (min-0.5) ถึง (max+0.5)
  let rand = min - 0.5 + Math.random() * (max - min + 1);
  return Math.round(rand);
}

alert( randomInteger(1, 3) );
```

อีกวิธีหนึ่งคือใช้ `Math.floor` สำหรับตัวเลขสุ่มจาก `min` ถึง `max+1`:

```js run
function randomInteger(min, max) {
  // ตรงนี้ rand อยู่ระหว่าง min ถึง (max+1)
  let rand = min + Math.random() * (max + 1 - min);
  return Math.floor(rand);
}

alert( randomInteger(1, 3) );
```

ตอนนี้ทุกช่วงถูกแมปดังนี้:

```js no-beautify
ค่าจาก 1  ... ถึง 1.9999999999  กลายเป็น 1
ค่าจาก 2  ... ถึง 2.9999999999  กลายเป็น 2
ค่าจาก 3  ... ถึง 3.9999999999  กลายเป็น 3
```

ทุกช่วงมีความยาวเท่ากัน ทำให้การกระจายสุดท้ายสม่ำเสมอ
