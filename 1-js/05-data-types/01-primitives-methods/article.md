# วิธีการของข้อมูลปฐมภูมิ

JavaScript อนุญาตให้เราทำงานกับข้อมูลปฐมภูมิ (เช่น string, number) ราวกับว่าพวกมันเป็นออบเจ็กต์ โดยมีเมท็อดให้เรียกใช้ได้ด้วย เราจะศึกษาวิธีการทำงานนี้กันในรายละเอียด

ก่อนอื่นมาทำความเข้าใจความแตกต่างสำคัญระหว่างข้อมูลปฐมภูมิกับออบเจ็กต์กันก่อน

ข้อมูลปฐมภูมิ:
- เป็นค่าปฐมภูมีประเภทต่างๆ 
- มีทั้งหมด 7 ประเภท ได้แก่ `string`, `number`, `bigint`, `boolean`, `symbol`, `null` และ `undefined`

ออบเจ็กต์:
- สามารถเก็บพร็อพเพอร์ตี้หลายค่า ในรูปแบบคีย์-ค่า
- สามารถสร้างได้ด้วย `{}` เช่น `{name: "John", age: 30}` และในภาษา JavaScript ยังมีออบเจ็กต์ประเภทอื่นๆ อีก เช่น ฟังก์ชันเองก็ถือเป็นออบเจ็กต์

หนึ่งในจุดเด่นของออบเจ็กต์คือ เราสามารถเก็บฟังก์ชันเป็นพร็อพเพอร์ตี้ได้:

```js run
let john = {
  name: "John",
  sayHi: function() {
    alert("Hi buddy!");
  }
};

john.sayHi(); // Hi buddy!
```

ที่นี่เราสร้างออบเจ็กต์ `john` ที่มีเมท็อด `sayHi` ไว้ด้วย

มีออบเจ็กต์ในตัวจำนวนมากที่มีอยู่แล้ว เช่น ออบเจ็กต์สำหรับวันที่ (Date), ข้อผิดพลาด (Error), องค์ประกอบ HTML เป็นต้น ซึ่งมีพร็อพเพอร์ตี้และเมท็อดเฉพาะตัวที่หลากหลาย

แต่คุณสมบัติเหล่านี้ก็มีค่าใช้จ่าย!

ออบเจ็กต์จะ "หนัก" กว่าข้อมูลปฐมภูมิ เพราะต้องใช้ทรัพยากรเพิ่มเติมเพื่อสนับสนุนกลไกภายในต่างๆ

## ข้อมูลปฐมภูมิในฐานะออบเจ็กต์ 

นี่คือปัญหาที่ผู้สร้าง JavaScript ต้องเผชิญ:

- เรามักจะอยากทำอะไรหลายๆ อย่างกับข้อมูลปฐมภูมิ เช่น string หรือ number การเข้าถึงข้อมูลผ่านเมท็อดจะช่วยได้มาก  
- แต่ข้อมูลปฐมภูมิควรจะเบาและรวดเร็วที่สุดเท่าที่จะเป็นไปได้

วิธีแก้ปัญหาอาจดูแปลกไปหน่อย แต่ทำได้ดังนี้:

1. ข้อมูลปฐมภูมิยังคงเป็นข้อมูลปฐมภูมี ซึ่งเป็นค่าเดี่ยวตามต้องการ
2. ภาษานี้อนุญาตให้เข้าถึงเมท็อดและพร็อพเพอร์ตี้ของ string, number, boolean และ symbol
3. เพื่อให้ทำได้ มีการสร้าง "ออบเจ็กต์ห่อหุ้ม" พิเศษขึ้นมาเพื่อให้ฟังก์ชันการทำงานเพิ่มเติม ซึ่งจะถูกทำลายทิ้งหลังจากเสร็จงาน

"ออบเจ็กต์ห่อหุ้ม" จะแตกต่างกันตามชนิดของข้อมูลปฐมภูมิ มี `String`, `Number`, `Boolean`, `Symbol` และ `BigInt` แต่ละตัวจะมีเมท็อดเฉพาะของตัวเอง

ยกตัวอย่างเช่น มีเมท็อดสำหรับ string อย่าง [str.toUpperCase()](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase) ที่คืนค่า `str` เป็นตัวอักษรพิมพ์ใหญ่ทั้งหมด

ลองดูการทำงานได้ดังนี้:

```js run
let str = "Hello";

alert( str.toUpperCase() ); // HELLO
```

ง่ายๆ เลย แต่แท้จริงแล้ว เบื้องหลัง `str.toUpperCase()` เกิดอะไรขึ้นมั่ง:

1. string `str` เป็นข้อมูลปฐมภูมิ ดังนั้นเมื่อมีการเข้าถึงพร็อพเพอร์ตี้ จะมีการสร้างออบเจ็กต์พิเศษขึ้นมาซึ่งรู้ค่าของ string นั้น และมีเมท็อดที่มีประโยชน์ต่างๆ เช่น `toUpperCase()`
2. เมท็อดนั้นรันและคืนค่า string ใหม่ (แสดงโดย `alert`)
3. ออบเจ็กต์พิเศษจะถูกทำลายทิ้ง ปล่อย `str` ไว้เป็นข้อมูลปฐมภูมิตามเดิม

ดังนั้น ข้อมูลปฐมภูมิสามารถจัดการเมท็อดได้ โดยยังคงความเป็นข้อมูลที่มีน้ำหนักเบาไว้เหมือนเดิม

เอ็นจิน JavaScript ทำให้กระบวนการนี้ราบรื่นที่สุด บางครั้งอาจแม้กระทั่งข้ามการสร้างออบเจ็กต์พิเศษไปเลย แต่ยังคงปฏิบัติตามข้อกำหนดและให้ผลเสมือนมีการสร้างออบเจ็กต์นั้นขึ้นมาจริง

ตัวเลขก็มีเมท็อดเป็นของตัวเองเช่นกัน เช่น [toFixed(n)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) ที่ปัดเศษทศนิยมตามจำนวนตำแหน่งที่ระบุ:

```js run
let n = 1.23456;

alert( n.toFixed(2) ); // 1.23
```

เราจะได้เรียนรู้เมท็อดเฉพาะของข้อมูลปฐมภูมิแต่ละตัวเพิ่มเติมในบท <info:number> และ <info:string>


````warn header="constructor ของ String/Number/Boolean ใช้สำหรับภายในเท่านั้น"
บางภาษา เช่น Java อนุญาตให้เราสร้าง "ออบเจ็กต์ wrapper" สำหรับข้อมูลปฐมภูมิได้โดยใช้ syntax แบบ `new Number(1)` หรือ `new Boolean(false)`

ใน JavaScript ก็ทำแบบนั้นได้ด้วยเหตุผลทางประวัติ แต่ *ไม่แนะนำให้ใช้เด็ดขาด* เพราะอาจเกิดปัญหาได้มากมาย 

ยกตัวอย่างเช่น:

```js run
alert( typeof 0 ); // "number"

alert( typeof new Number(0) ); // "object"!
```

ออบเจ็กต์จะมีค่าเป็น truthy เสมอ ดังนั้น alert ด้านล่างจะแสดงอะไรออกมา:

```js run
let zero = new Number(0);

if (zero) { // zero เป็น true เพราะเป็นออบเจ็กต์
  alert( "zero is truthy!?!" );
}
```

ในทางกลับกัน การใช้ฟังก์ชัน `String/Number/Boolean` แบบไม่มี `new` นั้นโอเค และมีประโยชน์มาก เพราะจะแปลงค่าเป็น string/number/boolean ตามแต่ประเภทที่ต้องการ (ซึ่งยังคงเป็นค่าปฐมภูมิ)

ยกตัวอย่างเช่น นี่เป็นวิธีที่ถูกต้อง:
```js
let num = Number("123"); // แปลง string เป็น number
```
````


````warn header="null/undefined ไม่มีเมท็อด"
ข้อมูลปฐมภูมิพิเศษ `null` กับ `undefined` ถือเป็นข้อยกเว้น ไม่มี "ออบเจ็กต์ wrapper" สำหรับค่าเหล่านี้ และก็ไม่มีเมท็อดอะไรด้วย แปลว่าพวกมันคือข้อมูลปฐมภูมิล้วนๆ ที่สุดเลยก็ว่าได้

การพยายามเข้าถึงพร็อพเพอร์ตี้ของค่าพวกนี้จะทำให้เกิด error:

```js run
alert(null.test); // error
```
````

## สรุป

- ข้อมูลปฐมภูมิยกเว้น `null` และ `undefined` มีเมท็อดที่ใช้งานได้จำนวนมาก เราจะศึกษาเมท็อดเหล่านั้นในบทต่อๆ ไป
- อย่างเป็นทางการแล้ว เมท็อดพวกนี้ทำงานผ่านออบเจ็กต์ชั่วคราว แต่เอ็นจิน JavaScript ได้รับการปรับแต่งอย่างดีเพื่อให้เกิดค่าใช้จ่ายในการเรียกใช้น้อยที่สุด