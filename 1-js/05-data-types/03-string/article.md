# สตริง (Strings)

ในภาษา JavaScript ข้อมูลที่เป็นตัวอักษรจะถูกเก็บในรูปแบบของสตริง โดยไม่มีประเภทข้อมูลแยกต่างหากสำหรับอักขระเดี่ยว ซึ่งต่างจากบางภาษาโปรแกรมมิ่งอื่นๆ ที่มีประเภทข้อมูลเฉพาะสำหรับตัวอักษรเดี่ยว

รูปแบบภายในของสตริงใน JavaScript จะเป็น UTF-16 เสมอ โดยไม่ขึ้นอยู่กับการเข้ารหัสของหน้าเว็บ นี่หมายความว่าสตริงใน JavaScript สามารถรองรับอักขระยูนิโค้ดได้อย่างกว้างขวาง ทำให้สามารถทำงานกับข้อความในหลายภาษาได้อย่างมีประสิทธิภาพ

## เครื่องหมายคำพูด

มาทบทวนประเภทของเครื่องหมายคำพูดที่ใช้ในการสร้างสตริงใน JavaScript กัน
สตริงสามารถอยู่ภายในเครื่องหมายคำพูดได้ 3 แบบ:

เครื่องหมายคำพูดเดี่ยว (Single quotes)
เครื่องหมายคำพูดคู่ (Double quotes)
เครื่องหมาย backticks

ตัวอย่างการใช้งาน:

```js
let single = 'single-quoted';
let double = "double-quoted";

let backticks = `backticks`;
```

เครื่องหมายคำพูดเดี่ยวและคู่มีลักษณะการทำงานเหมือนกัน แต่เครื่องหมาย backticks มีความสามารถพิเศษ ช่วยให้เราสามารถแทรกนิพจน์ (expression) ใดๆ ลงในสตริงได้ โดยครอบด้วย `${…}` ซึ่งเรียกว่า template literals หรือ template strings

ตัวอย่างการใช้ template literals:

```js run
function sum(a, b) {
  return a + b;
}

alert(`1 + 2 = ${sum(1, 2)}.`); // 1 + 2 = 3.
```

ข้อดีอีกอย่างของการใช้ backticks คือสามารถทำให้สตริงมีหลายบรรทัดได้:

```js run
let guestList = `Guests:
 * John
 * Pete
 * Mary
`;

alert(guestList); // a list of guests, multiple lines
```

สังเกตว่าการใช้ backticks ทำให้เราสามารถเขียนข้อความหลายบรรทัดได้อย่างเป็นธรรมชาติ โดยไม่ต้องใช้อักขระพิเศษเช่น `\n` เพื่อขึ้นบรรทัดใหม่

ในทางกลับกัน ถ้าเราใช้เครื่องหมายคำพูดเดี่ยวหรือคู่และพยายามใช้หลายบรรทัด จะเกิดข้อผิดพลาด:

```js run
let guestList = "รายชื่อแขก: // Error: Unexpected token ILLEGAL
  * สมชาย";
```

เครื่องหมายคำพูดเดี่ยวและคู่มีมาตั้งแต่ยุคแรกๆ ของการสร้างภาษา JavaScript ซึ่งตอนนั้นยังไม่ได้คำนึงถึงความต้องการในการใช้สตริงหลายบรรทัด ส่วน backticks เพิ่งมาในภายหลังใน ECMAScript 6 (ES6) จึงมีความสามารถที่หลากหลายกว่า

นอกจากนี้ backticks ยังช่วยให้เราสามารถระบุ "ฟังก์ชันเทมเพลต" (template function) ก่อน backtick แรกได้ด้วย ไวยากรณ์คือ: <code>func&#96;string&#96;</code> ฟังก์ชัน `func` จะถูกเรียกโดยอัตโนมัติ รับสตริงและนิพจน์ที่แทรกเข้ามาและสามารถประมวลผลได้ คุณลักษณะนี้เรียกว่า "tagged templates" ซึ่งมีประโยชน์มากในการสร้างสตริงที่ซับซ้อนหรือต้องการการประมวลผลพิเศษ แม้ว่าจะพบเห็นได้ไม่บ่อยนักในโค้ดทั่วไป แต่มีประโยชน์มากในไลบรารีหรือเฟรมเวิร์กบางตัว คุณสามารถอ่านเพิ่มเติมได้ที่เอกสารอ้างอิงของ MDN: [Template literals](mdn:/JavaScript/Reference/Template_literals#Tagged_templates)

## อักขระพิเศษ

แม้ว่า backticks จะช่วยให้เราสร้างสตริงหลายบรรทัดได้ง่าย แต่เราก็ยังสามารถสร้างสตริงหลายบรรทัดด้วยเครื่องหมายคำพูดเดี่ยวและคู่ได้ โดยใช้ "อักขระขึ้นบรรทัดใหม่" (newline character) ซึ่งเขียนเป็น `\n`:

```js run
let guestList = "Guests:\n * John\n * Pete\n * Mary";

alert(guestList); // แสดงรายชื่อแขกหลายบรรทัด เหมือนกับตัวอย่างก่อนหน้า
```

ตัวอย่างที่ง่ายกว่านี้ สองบรรทัดต่อไปนี้ให้ผลลัพธ์เหมือนกัน แค่เขียนต่างกัน:

```js run
let str1 = "Hello\nWorld"; // สองบรรทัดโดยใช้ "สัญลักษณ์ขึ้นบรรทัดใหม่"

// สองบรรทัดโดยใช้การขึ้นบรรทัดปกติและ backticks
let str2 = `Hello
World`;

alert(str1 == str2); // true แสดงว่าทั้งสองสตริงเหมือนกัน
```

มีอักขระพิเศษอื่นๆ ที่พบได้น้อยกว่า:

| อักขระ | คำอธิบาย |
|-----------|-------------|
|`\n`|ขึ้นบรรทัดใหม่|
|`\r`|Carriage return (ใช้ในระบบ Windows)|
|`\t`|แท็บ (Tab)|
|`\'`|เครื่องหมายคำพูดเดี่ยว|
|`\"`|เครื่องหมายคำพูดคู่|
|<code>\\`</code>|Backtick|
|`\\`|แบ็คสแลช|

สำหรับระบบปฏิบัติการ Windows การรวมกันของอักขระสองตัว `\r\n` แสดงถึงการขึ้นบรรทัดใหม่ ในขณะที่ระบบปฏิบัติการอื่นๆ เช่น macOS หรือ Linux จะใช้แค่ `\n` นี่เป็นเพราะเหตุผลทางประวัติศาสตร์ของการพัฒนาระบบปฏิบัติการ อย่างไรก็ตาม ซอฟต์แวร์ Windows ส่วนใหญ่ในปัจจุบันก็เข้าใจ `\n` เช่นกัน

ดังที่คุณเห็น อักขระพิเศษทั้งหมดเริ่มต้นด้วยเครื่องหมายแบ็คสแลช `\` ซึ่งเรียกว่า "อักขระหลบ" (escape character) เนื่องจากมันมีความพิเศษ ถ้าเราต้องการแสดงแบ็คสแลชจริงๆ `\` ในสตริง เราต้องเขียนมันสองครั้ง:

```js run
alert( `The backslash: \\` ); // แสดงผล: แบ็คสแลช: \
```

เครื่องหมายคำพูดที่ "หลบ" (escaped) `\'`, `\"`, <code>\\`</code> ใช้เพื่อแทรกเครื่องหมายคำพูดลงในสตริงที่ใช้เครื่องหมายคำพูดแบบเดียวกัน

ตัวอย่างเช่น:

```js run
alert( 'I*!*\'*/!*m the Walrus!' ); // *!*I'm*/!* the Walrus!
```

ในตัวอย่างนี้ เราใช้ `\'` เพื่อแทรกเครื่องหมายคำพูดเดี่ยวลงในสตริงที่ล้อมรอบด้วยเครื่องหมายคำพูดเดี่ยวเช่นกัน ถ้าไม่ใช้ `\` JavaScript จะเข้าใจผิดว่าเครื่องหมายคำพูดนั้นเป็นจุดสิ้นสุดของสตริง

อย่างไรก็ตาม วิธีที่สะดวกและอ่านง่ายกว่าคือการใช้เครื่องหมายคำพูดที่ต่างกัน:


```js run
alert( "I'm the Walrus!" ); // I'm the Walrus!
```

ในกรณีนี้ เราใช้เครื่องหมายคำพูดคู่ภายนอกและเครื่องหมายคำพูดเดี่ยวภายใน ทำให้ไม่ต้องใช้อักขระหลบและอ่านง่ายขึ้น 

## ความยาวของสตริง

คุณสมบัติ `length` ใช้เพื่อหาความยาวของสตริง:

```js run
alert( `My\n`.length ); // 3
```

สังเกตว่า `\n` เป็น "อักขระพิเศษ" เดียว ดังนั้นความยาวของสตริงนี้จึงเป็น `3`

```warn header="`length` เป็นคุณสมบัติ"
ผู้ที่มีพื้นฐานจากภาษาอื่นบางครั้งอาจเผลอเรียกใช้ `str.length()` แทนที่จะใช้แค่ `str.length` ซึ่งไม่ถูกต้องและจะทำให้โปรแกรมทำงานผิดพลาด

โปรดจำไว้ว่า `str.length` เป็นคุณสมบัติเชิงตัวเลข ไม่ใช่ฟังก์ชัน ไม่จำเป็นต้องเพิ่มวงเล็บหลังมัน เราใช้แค่ `.length` ไม่ใช่ `.length()`
```

## การเข้าถึงอักขระ

ในภาษา JavaScript เรามีวิธีการเข้าถึงอักขระในสตริงสองวิธีหลัก:

1. การใช้วงเล็บเหลี่ยม `[]`
2. การใช้เมธอด `at()`

### การใช้วงเล็บเหลี่ยม

เพื่อเข้าถึงอักขระที่ตำแหน่ง `pos` เราสามารถใช้วงเล็บเหลี่ยม `[pos]` โดยการนับเริ่มจาก 0:

```js run
let str = `Hello`;

// อักขระแรก
alert( str[0] ); // H

// อักขระสุดท้าย
alert( str[str.length - 1] ); // o
```

### การใช้เมธอด at()

อีกวิธีหนึ่งคือการใช้เมธอด [str.at(pos)](mdn:js/String/at) ซึ่งมีข้อดีคือสามารถใช้ค่าลบเพื่อนับจากท้ายสตริงได้:

```js run
let str = `Hello`;

// อักขระแรก
alert( str.at(0) ); // H

// อักขระสุดท้าย
alert( str.at(-1) ); // o

// อักขระก่อนสุดท้าย
alert( str.at(-2) ); // l
```

ข้อแตกต่างที่สำคัญระหว่างสองวิธีนี้คือ:

1. วงเล็บเหลี่ยม `[]` จะคืนค่า `undefined` เสมอสำหรับดัชนีที่เป็นลบ
2. เมธอด `at()` สามารถใช้ค่าลบเพื่อนับจากท้ายสตริงได้

ตัวอย่างเช่น:

```js run
let str = `Hello`;

alert( str[-2] ); // undefined
alert( str.at(-2) ); // l
```

เราสามารถวนลูปผ่านอักขระของสตริงโดยใช้ `for..of` ได้ด้วย:

```js run
for (let char of "Hello") {
  alert(char); // H,e,l,l,o (char becomes "H", then "e", then "l" etc)
}
```

## สตริงไม่สามารถเปลี่ยนแปลงได้

สตริงใน JavaScript เป็นประเภทข้อมูลที่ไม่สามารถเปลี่ยนแปลงได้ (immutable) นั่นหมายความว่าเราไม่สามารถแก้ไขอักขระในสตริงที่มีอยู่แล้วได้

ลองดูตัวอย่างนี้เพื่อแสดงให้เห็นว่าการพยายามเปลี่ยนแปลงสตริงโดยตรงไม่ทำงาน:

```js run
let str = 'Hi';

str[0] = 'h'; // เกิดข้อผิดพลาด
alert( str[0] ); // ไม่ทำงาน
```

วิธีแก้ปัญหาทั่วไปเมื่อต้องการเปลี่ยนแปลงสตริงคือการสร้างสตริงใหม่ทั้งหมดและกำหนดให้กับตัวแปรเดิม:

ตัวอย่างเช่น:

```js run
let str = 'Hi';

str = 'h' + str[1]; // แทนที่ 'H' ด้วย 'h'

alert( str ); // hi
```

ในตัวอย่างนี้ เราสร้างสตริงใหม่โดยใช้อักขระ 'h' แทนที่อักขระแรกของสตริงเดิม และคงอักขระที่เหลือไว้เหมือนเดิม

## การเปลี่ยนตัวพิมพ์

การเปลี่ยนตัวพิมพ์ของสตริงเป็นสิ่งที่ทำได้ง่ายใน JavaScript โดยใช้เมธอด `toLowerCase()` และ `toUpperCase()`:

```js run
alert( 'Interface'.toUpperCase() ); // INTERFACE
alert( 'Interface'.toLowerCase() ); // interface
```

ถ้าเราต้องการเปลี่ยนตัวพิมพ์ของอักขระเดี่ยว เราสามารถทำได้โดยการเข้าถึงอักขระนั้นก่อนแล้วใช้เมธอดเปลี่ยนตัวพิมพ์:

```js run
alert( 'Interface'[0].toLowerCase() ); // 'i'
```

## การค้นหาสตริงย่อย

JavaScript มีหลายวิธีในการค้นหาสตริงย่อยภายในสตริง แต่ละวิธีมีจุดเด่นและการใช้งานที่แตกต่างกัน

### str.indexOf

เมธอด [str.indexOf(substr, pos)](mdn:js/String/indexOf) เป็นวิธีพื้นฐานในการค้นหาสตริงย่อย:

ตัวอย่างเช่น:

```js run
let str = 'Widget with id';

alert( str.indexOf('Widget') ); // 0, เพราะ 'Widget' พบที่จุดเริ่มต้น
alert( str.indexOf('widget') ); // // -1, ไม่พบ การค้นหานี้คำนึงถึงตัวพิมพ์ใหญ่-เล็ก

alert( str.indexOf("id") ); // 1, "ไอดี" พบที่ตำแหน่ง 1
```

พารามิเตอร์ที่สองเป็นตัวเลือก ช่วยให้เราเริ่มค้นหาจากตำแหน่งที่กำหนดได้:

```js run
let str = 'Widget with id';

alert( str.indexOf('id', 2) ) // 12
```

ถ้าเราต้องการหาทุกตำแหน่งที่สตริงย่อยปรากฏ เราสามารถใช้ `indexOf` ในลูปได้:

```js run
let str = 'As sly as a fox, as strong as an ox';

let target = 'as'; // หา "as" ในสตริง

let pos = 0;
while (true) {
  let foundPos = str.indexOf(target, pos);
  if (foundPos == -1) break;

  alert( `Found at ${foundPos}` );
  pos = foundPos + 1; // ตำแหน่งถัดไปจากการค้นหาล่าสุด
}
```

อัลกอริทึมเดียวกันนี้สามารถเขียนให้กระชับขึ้นได้:

```js run
let str = "As sly as a fox, as strong as an ox";
let target = "as";

*!*
let pos = -1;
while ((pos = str.indexOf(target, pos + 1)) != -1) {
  alert( pos );
}
*/!*
```

```smart header="`str.lastIndexOf(substr, position)`"
มีเมธอดที่คล้ายกันคือ [str.lastIndexOf(substr, position)](mdn:js/String/lastIndexOf) ที่ค้นหาจากท้ายสตริงไปยังจุดเริ่มต้น

มันจะแสดงรายการการปรากฏในลำดับย้อนกลับ ซึ่งมีประโยชน์เมื่อต้องการหาการปรากฏล่าสุดของสตริงย่อย
```

มีข้อควรระวังเล็กน้อยเมื่อใช้ `indexOf` ในการทดสอบเงื่อนไข เราไม่สามารถใช้มันใน `if` แบบนี้ได้โดยตรง:

```js run
let str = "Widget with id";

if (str.indexOf("Widget")) {
    alert("We found it"); // ไม่ทำงานอย่างที่คาด!
}
```

`alert` ในตัวอย่างด้านบนไม่แสดงผลเพราะ `str.indexOf("Widget")` คืนค่า `0` (หมายความว่าพบการจับคู่ที่ตำแหน่งเริ่มต้น) แต่ `if` ถือว่า `0` เป็น `false`

ดังนั้น วิธีที่ถูกต้องคือการตรวจสอบว่าผลลัพธ์ไม่เท่ากับ `-1`:

```js run
let str = "Widget with id";

*!*
if (str.indexOf("Widget") != -1) {
*/!*
    alert("We found it"); // ตอนนี้ทำงานแล้ว!
}
```

### includes, startsWith, endsWith

เมธอดที่ทันสมัยและใช้งานง่ายกว่าสำหรับการตรวจสอบการมีอยู่ของสตริงย่อยคือ [str.includes(substr, pos)](mdn:js/String/includes) ซึ่งส่งคืน `true` หรือ `false` ขึ้นอยู่กับว่า `str` มี `substr` อยู่หรือไม่:


```js run
alert( "Widget with id".includes("Widget") ); // true

alert( "Hello".includes("Bye") ); // false
```

อาร์กิวเมนต์ที่สองของ `str.includes` เป็นตัวเลือก เป็นตำแหน่งที่จะเริ่มค้นหา:

```js run
alert( "Widget".includes("id") ); // true
alert( "Widget".includes("id", 3) ); // false, ตั้งแต่ตำแหน่งที่ 3 ไม่มี "id"
```

เมธอด [str.startsWith](mdn:js/String/startsWith) และ [str.endsWith](mdn:js/String/endsWith) ทำหน้าที่ตามชื่อของมันเลย คือตรวจสอบว่าสตริงขึ้นต้นหรือลงท้ายด้วยสตริงย่อยที่กำหนดหรือไม่:

```js run
alert( "*!*Wid*/!*get".startsWith("Wid") ); // true ขึ้นต้นด้วย "Wid"
alert( "Wid*!*get*/!*".endsWith("get") ); // true ลงท้ายด้วย "get"
```

## การดึงสตริงย่อย

มี 3 เมธอดหลักใน JavaScript สำหรับการดึงสตริงย่อย: `substring`, `substr` และ `slice` แต่ละวิธีมีลักษณะการทำงานที่แตกต่างกันเล็กน้อย ดังนี้:

`str.slice(start [, end])`
: ส่งคืนส่วนของสตริงจาก `start` ถึง (แต่ไม่รวม) `end`

    ตัวอย่างการใช้งาน:

    ```js run
    let str = "stringify";
    alert( str.slice(0, 5) ); // 'strin', สตริงย่อยจาก 0 ถึง 5 (ไม่รวม 5)
    alert( str.slice(0, 1) ); // 's', จาก 0 ถึง 1 แต่ไม่รวม 1 ดังนั้นเป็นเพียงอักขระที่ 0
    ```

    ถ้าไม่ระบุอาร์กิวเมนต์ที่สอง `slice` จะดึงสตริงย่อยจนถึงท้ายสตริง:

    ```js run
    let str = "st*!*ringify*/!*";
    alert( str.slice(2) ); // 'ringify', จากตำแหน่งที่ 2 จนถึงท้าย
    ```

    `slice` ยังรองรับค่าลบสำหรับ `start` และ `end` ซึ่งหมายถึงตำแหน่งจะถูกนับจากท้ายสตริง:

    ```js run
    let str = "strin*!*gif*/!*y";

    // เริ่มที่ตำแหน่งที่ 4 จากขวา จบที่ตำแหน่งที่ 1 จากขวา
    alert( str.slice(-4, -1) ); // 'gif'
    ```

`str.substring(start [, end])`
: ส่งคืนส่วนของสตริง*ระหว่าง* `start` และ `end` (ไม่รวม `end`)

    การทำงานคล้ายกับ `slice` แต่มีความแตกต่างสำคัญคือ `substring` อนุญาตให้ `start` มีค่ามากกว่า `end` ได้ ในกรณีนี้มันจะสลับค่า `start` และ `end` โดยอัตโนมัติ

    ตัวอย่างการใช้งาน:

    ```js run
    let str = "st*!*ring*/!*ify";

    // ทั้งสองคำสั่งนี้ให้ผลลัพธ์เหมือนกันสำหรับ substring
    alert( str.substring(2, 6) ); // "ring"
    alert( str.substring(6, 2) ); // "ring"

    // แต่ให้ผลต่างกันสำหรับ slice:
    alert( str.slice(2, 6) ); // "ring" (เหมือนกัน)
    alert( str.slice(6, 2) ); // "" (สตริงว่าง)

    ```

    `substring` จะปฏิบัติกับอาร์กิวเมนต์ที่เป็นลบเสมือนเป็น `0` ซึ่งต่างจาก `slice`

`str.substr(start [, length])`
: ส่งคืนส่วนของสตริงจาก `start` โดยมีความยาวที่กำหนด

    วิธีนี้แตกต่างจากสองวิธีแรกตรงที่เราระบุ `length` แทนตำแหน่งสิ้นสุด:

    ```js run
    let str = "st*!*ring*/!*ify";
    alert( str.substr(2, 4) ); // 'ring', จากตำแหน่งที่ 2 ดึง 4 อักขระ
    ```

    อาร์กิวเมนต์แรกสามารถเป็นค่าลบได้ เพื่อนับจากท้ายสตริง:

    ```js run
    let str = "strin*!*gi*/!*fy";
    alert( str.substr(-4, 2) ); // 'gi', จากตำแหน่งที่ 4 จากท้าย ดึง 2 อักขระ
    ```

    อย่างไรก็ตาม ควรระมัดระวังในการใช้ `substr` เนื่องจากมีอยู่ใน [Annex B](https://tc39.es/ecma262/#sec-string.prototype.substr) ของข้อกำหนดภาษา JavaScript ซึ่งหมายความว่าอาจไม่ได้รับการสนับสนุนในสภาพแวดล้อมที่ไม่ใช่เบราว์เซอร์ แม้ว่าในทางปฏิบัติจะได้รับการสนับสนุนในเกือบทุกที่ แต่ก็ไม่แนะนำให้ใช้ในโค้ดใหม่

สรุปเมธอดเหล่านี้เพื่อให้เข้าใจง่ายขึ้น:

| เมธอด | เลือก... | ค่าลบ |
|--------|-----------|-----------|
| `slice(start, end)` | จาก `start` ถึง `end` (ไม่รวม `end`) | อนุญาตค่าลบ |
| `substring(start, end)` | ระหว่าง `start` และ `end` (ไม่รวม `end`) | ค่าลบหมายถึง `0` |
| `substr(start, length)` | จาก `start` ดึง `length` อักขระ | อนุญาต `start` เป็นลบ |

```smart header="ควรเลือกใช้เมธอดไหนดี?"
ทั้งสามเมธอดสามารถทำงานได้ แต่แต่ละวิธีมีข้อดีและข้อจำกัดต่างกัน:

- `substr` มีข้อเสียคือไม่ได้อยู่ในข้อกำหนดหลักของ JavaScript แต่อยู่ใน Annex B ซึ่งครอบคลุมคุณลักษณะที่มีไว้เพื่อความเข้ากันได้กับโค้ดเก่าเป็นหลัก อาจมีปัญหาในสภาพแวดล้อมที่ไม่ใช่เบราว์เซอร์
- `substring` มีพฤติกรรมแปลกๆ กับค่าลบ ซึ่งอาจทำให้สับสนได้
- `slice` มีความยืดหยุ่นมากที่สุด รองรับค่าลบได้ และมีไวยากรณ์ที่เข้าใจง่าย

ดังนั้น สำหรับการใช้งานทั่วไป การจดจำและใช้แค่ `slice` ก็เพียงพอและปลอดภัยที่สุด
```

## การเปรียบเทียบสตริง

การเปรียบเทียบสตริงใน JavaScript ใช้การเปรียบเทียบทีละอักขระตามลำดับตัวอักษร (lexicographical order) ซึ่งอาจให้ผลลัพธ์ที่แตกต่างจากที่คาดไว้ในบางกรณี:

1. ตัวพิมพ์เล็กจะมากกว่าตัวพิมพ์ใหญ่เสมอ:

    ```js run
    alert( 'a' > 'Z' ); // true
    ```

2. ตัวอักษรที่มีเครื่องหมายกำกับอาจไม่เรียงตามที่คาดหวัง:

    ```js run
    alert( 'Österreich' > 'Zealand' ); // true
    ```

    ผลลัพธ์นี้อาจดูแปลกประหลาดถ้าเราเรียงลำดับชื่อประเทศ โดยปกติแล้วคนจะคาดหวังว่า `Zealand` ควรมาหลัง `Österreich` ในรายการที่เรียงตามตัวอักษร

เพื่อเข้าใจว่าทำไมจึงเป็นเช่นนี้ เราต้องรู้ว่าสตริงใน JavaScript ถูกเข้ารหัสโดยใช้ [UTF-16](https://en.wikipedia.org/wiki/UTF-16) ซึ่งหมายความว่าแต่ละอักขระมีรหัสตัวเลขที่สอดคล้องกัน

JavaScript มีเมธอดพิเศษที่ช่วยให้เราได้รหัสของอักขระและสร้างอักขระจากรหัส:

`str.codePointAt(pos)`
: ส่งคืนรหัส Unicode ของอักขระที่ตำแหน่ง `pos`:

    ```js run
    // ตัวอักษรที่มีตัวพิมพ์ต่างกันจะมีรหัสต่างกัน
    alert( "Z".codePointAt(0) ); // 90
    alert( "z".codePointAt(0) ); // 122
    alert( "z".codePointAt(0).toString(16) ); // 7a (ถ้าเราต้องการค่าฐานสิบหก)
    ```

`String.fromCodePoint(code)`
: สร้างอักขระจากรหัส Unicode ที่กำหนด:

    ```js run
    alert( String.fromCodePoint(90) ); // Z
    alert( String.fromCodePoint(0x5a) ); // Z (เราสามารถใช้ค่าฐานสิบหกเป็นอาร์กิวเมนต์ได้ด้วย)
    ```

เราสามารถทดลองดูอักขระที่มีรหัสระหว่าง 65 ถึง 220 (ซึ่งครอบคลุมตัวอักษรละตินและสัญลักษณ์พิเศษบางตัว) ได้ดังนี้:

```js run
let str = '';

for (let i = 65; i <= 220; i++) {
  str += String.fromCodePoint(i);
}
alert( str );
// ผลลัพธ์:
// ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
// ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜ
```

จากผลลัพธ์นี้ เราจะเห็นว่าตัวอักษรตัวพิมพ์ใหญ่มาก่อน ตามด้วยสัญลักษณ์พิเศษบางตัว แล้วจึงเป็นตัวอักษรตัวพิมพ์เล็ก และตัวอักษรที่มีเครื่องหมายกำกับ (เช่น Ö) อยู่ท้ายสุด

ตอนนี้เราเข้าใจแล้วว่าทำไม `'a' > 'Z'`:

1. อักขระถูกเปรียบเทียบโดยใช้รหัสตัวเลขของพวกมัน
2. รหัสที่มากกว่าหมายถึงอักขระนั้น "มากกว่า" ในการเปรียบเทียบ
3. รหัสสำหรับ `a` (97) มากกว่ารหัสสำหรับ `Z` (90)

### การเปรียบเทียบที่ถูกต้องตามภาษา

อัลกอริทึมการเปรียบเทียบสตริง "ที่ถูกต้อง" ตามหลักภาษาศาสตร์นั้นซับซ้อนกว่าที่คิด เพราะภาษาต่างๆ มีกฎการเรียงลำดับตัวอักษรที่แตกต่างกัน

โชคดีที่เบราว์เซอร์สมัยใหม่ (และ Node.js) สนับสนุนมาตรฐานการทำให้เป็นสากล [ECMA-402](https://www.ecma-international.org/publications-and-standards/standards/ecma-402/) ซึ่งให้วิธีการเปรียบเทียบสตริงที่คำนึงถึงกฎของแต่ละภาษา

เราสามารถใช้เมธอด [str.localeCompare(str2)](mdn:js/String/localeCompare) เพื่อเปรียบเทียบสตริงตามกฎภาษา:

ตัวอย่างเช่น:

```js run
alert( 'Österreich'.localeCompare('Zealand') ); // -1
```
เข้าใจครับ ผมจะขยายความเฉพาะส่วนที่เกี่ยวกับ `localeCompare` และสรุปตามที่ระบุไว้ในต้นฉบับ โดยไม่เพิ่มเติมเนื้อหาใหม่

เมธอด `localeCompare` มีอาร์กิวเมนต์เพิ่มเติมที่ช่วยให้เราสามารถปรับแต่งการเปรียบเทียบได้ดังนี้:

```js
str.localeCompare(str2, [locales, [options]])
```

- `locales`: ช่วยระบุภาษาที่ใช้ในการเปรียบเทียบ โดยค่าเริ่มต้นจะใช้ภาษาตามสภาพแวดล้อมของระบบ
- `options`: เป็นวัตถุที่ใช้กำหนดกฎเพิ่มเติมในการเปรียบเทียบ เช่น การคำนึงถึงตัวพิมพ์ใหญ่-เล็ก หรือการปฏิบัติต่ออักขระที่มีเครื่องหมายกำกับ

การใช้อาร์กิวเมนต์เหล่านี้ช่วยให้เราสามารถปรับแต่งการเปรียบเทียบให้เหมาะกับความต้องการเฉพาะได้ เช่น การเปรียบเทียบโดยไม่คำนึงถึงตัวพิมพ์ใหญ่-เล็ก หรือการปฏิบัติต่อตัวอักษรที่มีเครื่องหมายกำกับ (เช่น "a" และ "á") ให้เหมือนกัน

## สรุป

เรามาสรุปสาระสำคัญเกี่ยวกับการจัดการสตริงใน JavaScript กัน:

1. **การสร้างสตริง**: สามารถใช้เครื่องหมายคำพูดเดี่ยว (''), คู่ ("") หรือ backticks (``). Backticks มีความสามารถพิเศษในการแทรกนิพจน์และสร้างสตริงหลายบรรทัด

2. **การเข้าถึงอักขระ**: ใช้วงเล็บเหลี่ยม `[]` หรือเมธอด `at()` โดย `at()` สามารถใช้ดัชนีเชิงลบได้

3. **การเปลี่ยนตัวพิมพ์**: ใช้ `toLowerCase()` และ `toUpperCase()`

4. **การค้นหาสตริงย่อย**: 
   - `indexOf()`: หาตำแหน่งแรกที่พบ
   - `includes()`: ตรวจสอบการมีอยู่
   - `startsWith()` และ `endsWith()`: ตรวจสอบการขึ้นต้นและลงท้าย

5. **การดึงสตริงย่อย**: 
   - `slice(start, end)`: ดึงจาก start ถึง (ไม่รวม) end, รองรับดัชนีลบ
   - `substring(start, end)`: คล้าย slice แต่ไม่รองรับดัชนีลบ
   - `substr(start, length)`: ดึงตามความยาวที่กำหนด (ไม่แนะนำให้ใช้ในโค้ดใหม่)

6. **การเปรียบเทียบสตริง**: 
   - ใช้เครื่องหมาย `<`, `>`, `==`, `===` สำหรับการเปรียบเทียบทั่วไป
   - ใช้ `localeCompare()` สำหรับการเปรียบเทียบที่คำนึงถึงภาษา

7. **อักขระพิเศษ**: เช่น `\n` สำหรับขึ้นบรรทัดใหม่, `\t` สำหรับแท็บ, `\'` และ `\"` สำหรับเครื่องหมายคำพูด

8. **ความยาวของสตริง**: ใช้คุณสมบัติ `length`

9. **สตริงเป็นข้อมูลที่ไม่สามารถเปลี่ยนแปลงได้ (immutable)**: การแก้ไขสตริงต้องสร้างสตริงใหม่เสมอ

10. **การทำงานกับ Unicode**: ใช้ `codePointAt()` และ `String.fromCodePoint()` สำหรับการจัดการรหัส Unicode

เมื่อทำงานกับสตริง สิ่งสำคัญคือต้องเลือกใช้เมธอดที่เหมาะสมกับงาน และระมัดระวังเรื่องประสิทธิภาพเมื่อต้องทำงานกับสตริงขนาดใหญ่หรือการดำเนินการซ้ำๆ

นอกจากนี้ JavaScript ยังมีเมธอดอื่นๆ สำหรับการจัดการสตริงที่มีประโยชน์ เช่น:

- `trim()`: ลบช่องว่างจากจุดเริ่มต้นและจุดสิ้นสุดของสตริง
- `repeat(n)`: ทำซ้ำสตริง `n` ครั้ง
- `padStart()` และ `padEnd()`: เติมสตริงให้ได้ความยาวที่กำหนด

สำหรับการค้นหาและแทนที่ที่ซับซ้อนมากขึ้น JavaScript รองรับการใช้นิพจน์ทั่วไป (Regular Expressions) ซึ่งเป็นเครื่องมือที่ทรงพลังสำหรับการจัดการกับรูปแบบของสตริง

สุดท้าย เมื่อทำงานกับสตริงที่มีอักขระพิเศษหรือต้องการความถูกต้องในการจัดการกับ Unicode ควรศึกษาเพิ่มเติมเกี่ยวกับการทำงานของ Unicode ใน JavaScript เพื่อหลีกเลี่ยงปัญหาที่อาจเกิดขึ้นกับอักขระบางตัว ดูเพิ่มเติมได้ที่บทเรียนนี้ info:unicode