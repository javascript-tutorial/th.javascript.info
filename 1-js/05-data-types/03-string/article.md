# สตริง (Strings)

ในภาษา JavaScript ข้อมูลที่เป็นตัวอักษรจะถูกเก็บในรูปแบบของสตริง โดยไม่มีประเภทข้อมูลแยกต่างหากสำหรับอักขระเดี่ยว ซึ่งต่างจากบางภาษาโปรแกรมมิ่งอื่นๆ ที่มีประเภทข้อมูลเฉพาะสำหรับตัวอักษรเดี่ยว

รูปแบบภายในของสตริงใน JavaScript จะเป็น UTF-16 เสมอ โดยไม่ขึ้นอยู่กับการเข้ารหัสของหน้าเว็บ นี่หมายความว่าสตริงใน JavaScript สามารถรองรับอักขระยูนิโค้ดได้อย่างกว้างขวาง ทำให้สามารถทำงานกับข้อความในหลายภาษาได้อย่างมีประสิทธิภาพ

## เครื่องหมายคำพูด

มาทบทวนประเภทของเครื่องหมายคำพูดที่ใช้ในการสร้างสตริงใน JavaScript กัน
สตริงสามารถอยู่ภายในเครื่องหมายคำพูดได้ 3 แบบ:

เครื่องหมายคำพูดเดี่ยว (Single quotes)
เครื่องหมายคำพูดคู่ (Double quotes)
เครื่องหมาย backticks

ตัวอย่างการใช้งาน:

```js
let single = 'single-quoted';
let double = "double-quoted";

let backticks = `backticks`;
```

เครื่องหมายคำพูดเดี่ยวและคู่มีลักษณะการทำงานเหมือนกัน แต่เครื่องหมาย backticks มีความสามารถพิเศษ ช่วยให้เราสามารถแทรกนิพจน์ (expression) ใดๆ ลงในสตริงได้ โดยครอบด้วย `${…}` ซึ่งเรียกว่า template literals หรือ template strings

ตัวอย่างการใช้ template literals:

```js run
function sum(a, b) {
  return a + b;
}

alert(`1 + 2 = ${sum(1, 2)}.`); // 1 + 2 = 3.
```

ข้อดีอีกอย่างของการใช้ backticks คือสามารถทำให้สตริงมีหลายบรรทัดได้:

```js run
let guestList = `Guests:
 * John
 * Pete
 * Mary
`;

alert(guestList); // a list of guests, multiple lines
```

สังเกตว่าการใช้ backticks ทำให้เราสามารถเขียนข้อความหลายบรรทัดได้อย่างเป็นธรรมชาติ โดยไม่ต้องใช้อักขระพิเศษเช่น `\n` เพื่อขึ้นบรรทัดใหม่

ในทางกลับกัน ถ้าเราใช้เครื่องหมายคำพูดเดี่ยวหรือคู่และพยายามใช้หลายบรรทัด จะเกิดข้อผิดพลาด:

```js run
let guestList = "รายชื่อแขก: // Error: Unexpected token ILLEGAL
  * สมชาย";
```

เครื่องหมายคำพูดเดี่ยวและคู่มีมาตั้งแต่ยุคแรกๆ ของการสร้างภาษา JavaScript ซึ่งตอนนั้นยังไม่ได้คำนึงถึงความต้องการในการใช้สตริงหลายบรรทัด ส่วน backticks เพิ่งมาในภายหลังใน ECMAScript 6 (ES6) จึงมีความสามารถที่หลากหลายกว่า

นอกจากนี้ backticks ยังช่วยให้เราสามารถระบุ "ฟังก์ชันเทมเพลต" (template function) ก่อน backtick แรกได้ด้วย ไวยากรณ์คือ: <code>func&#96;string&#96;</code> ฟังก์ชัน `func` จะถูกเรียกโดยอัตโนมัติ รับสตริงและนิพจน์ที่แทรกเข้ามาและสามารถประมวลผลได้ คุณลักษณะนี้เรียกว่า "tagged templates" ซึ่งมีประโยชน์มากในการสร้างสตริงที่ซับซ้อนหรือต้องการการประมวลผลพิเศษ แม้ว่าจะพบเห็นได้ไม่บ่อยนักในโค้ดทั่วไป แต่มีประโยชน์มากในไลบรารีหรือเฟรมเวิร์กบางตัว คุณสามารถอ่านเพิ่มเติมได้ที่เอกสารอ้างอิงของ MDN: [Template literals](mdn:/JavaScript/Reference/Template_literals#Tagged_templates)

## อักขระพิเศษ

แม้ว่า backticks จะช่วยให้เราสร้างสตริงหลายบรรทัดได้ง่าย แต่เราก็ยังสามารถสร้างสตริงหลายบรรทัดด้วยเครื่องหมายคำพูดเดี่ยวและคู่ได้ โดยใช้ "อักขระขึ้นบรรทัดใหม่" (newline character) ซึ่งเขียนเป็น `\n`:

```js run
let guestList = "Guests:\n * John\n * Pete\n * Mary";

alert(guestList); // แสดงรายชื่อแขกหลายบรรทัด เหมือนกับตัวอย่างก่อนหน้า
```

ตัวอย่างที่ง่ายกว่านี้ สองบรรทัดต่อไปนี้ให้ผลลัพธ์เหมือนกัน แค่เขียนต่างกัน:

```js run
let str1 = "Hello\nWorld"; // สองบรรทัดโดยใช้ "สัญลักษณ์ขึ้นบรรทัดใหม่"

// สองบรรทัดโดยใช้การขึ้นบรรทัดปกติและ backticks
let str2 = `Hello
World`;

alert(str1 == str2); // true แสดงว่าทั้งสองสตริงเหมือนกัน
```

มีอักขระพิเศษอื่นๆ ที่พบได้น้อยกว่า:

| อักขระ | คำอธิบาย |
|-----------|-------------|
|`\n`|ขึ้นบรรทัดใหม่|
|`\r`|Carriage return (ใช้ในระบบ Windows)|
|`\t`|แท็บ (Tab)|
|`\'`|เครื่องหมายคำพูดเดี่ยว|
|`\"`|เครื่องหมายคำพูดคู่|
|<code>\\`</code>|Backtick|
|`\\`|แบ็คสแลช|

สำหรับระบบปฏิบัติการ Windows การรวมกันของอักขระสองตัว `\r\n` แสดงถึงการขึ้นบรรทัดใหม่ ในขณะที่ระบบปฏิบัติการอื่นๆ เช่น macOS หรือ Linux จะใช้แค่ `\n` นี่เป็นเพราะเหตุผลทางประวัติศาสตร์ของการพัฒนาระบบปฏิบัติการ อย่างไรก็ตาม ซอฟต์แวร์ Windows ส่วนใหญ่ในปัจจุบันก็เข้าใจ `\n` เช่นกัน

ดังที่คุณเห็น อักขระพิเศษทั้งหมดเริ่มต้นด้วยเครื่องหมายแบ็คสแลช `\` ซึ่งเรียกว่า "อักขระหลบ" (escape character) เนื่องจากมันมีความพิเศษ ถ้าเราต้องการแสดงแบ็คสแลชจริงๆ `\` ในสตริง เราต้องเขียนมันสองครั้ง:

```js run
alert( `The backslash: \\` ); // แสดงผล: แบ็คสแลช: \
```

เครื่องหมายคำพูดที่ "หลบ" (escaped) `\'`, `\"`, <code>\\`</code> ใช้เพื่อแทรกเครื่องหมายคำพูดลงในสตริงที่ใช้เครื่องหมายคำพูดแบบเดียวกัน

ตัวอย่างเช่น:

```js run
alert( 'I*!*\'*/!*m the Walrus!' ); // *!*I'm*/!* the Walrus!
```

ในตัวอย่างนี้ เราใช้ `\'` เพื่อแทรกเครื่องหมายคำพูดเดี่ยวลงในสตริงที่ล้อมรอบด้วยเครื่องหมายคำพูดเดี่ยวเช่นกัน ถ้าไม่ใช้ `\` JavaScript จะเข้าใจผิดว่าเครื่องหมายคำพูดนั้นเป็นจุดสิ้นสุดของสตริง

อย่างไรก็ตาม วิธีที่สะดวกและอ่านง่ายกว่าคือการใช้เครื่องหมายคำพูดที่ต่างกัน:


```js run
alert( "I'm the Walrus!" ); // I'm the Walrus!
```

ในกรณีนี้ เราใช้เครื่องหมายคำพูดคู่ภายนอกและเครื่องหมายคำพูดเดี่ยวภายใน ทำให้ไม่ต้องใช้อักขระหลบและอ่านง่ายขึ้น 

## ความยาวของสตริง

คุณสมบัติ `length` ใช้เพื่อหาความยาวของสตริง:

```js run
alert( `My\n`.length ); // 3
```

สังเกตว่า `\n` เป็น "อักขระพิเศษ" เดียว ดังนั้นความยาวของสตริงนี้จึงเป็น `3`

```warn header="`length` เป็นคุณสมบัติ"
ผู้ที่มีพื้นฐานจากภาษาอื่นบางครั้งอาจพิมพ์ผิดโดยเรียก `str.length()` แทนที่จะเป็นแค่ `str.length` ซึ่งไม่ทำงาน

โปรดทราบว่า `str.length` เป็นคุณสมบัติเชิงตัวเลข ไม่ใช่ฟังก์ชัน ไม่จำเป็นต้องเพิ่มวงเล็บหลังมัน ไม่ใช่ `.length()` แต่เป็น `.length`
```

## การเข้าถึงอักขระ

เพื่อเข้าถึงอักขระที่ตำแหน่ง `pos` ให้ใช้วงเล็บเหลี่ยม `[pos]` หรือเรียกเมธอด [str.at(pos)](mdn:js/String/at) อักขระแรกเริ่มจากตำแหน่งศูนย์:

```js run
let str = `สวัสดี`;

// อักขระแรก
alert( str[0] ); // ส
alert( str.at(0) ); // ส

// อักขระสุดท้าย
alert( str[str.length - 1] ); // ี
alert( str.at(-1) );
```

ดังที่คุณเห็น เมธอด `.at(pos)` มีข้อดีคือสามารถใช้ตำแหน่งเชิงลบได้ ถ้า `pos` เป็นลบ จะนับจากท้ายสตริง

ดังนั้น `.at(-1)` หมายถึงอักขระสุดท้าย และ `.at(-2)` คืออักขระก่อนหน้านั้น เป็นต้น

วงเล็บเหลี่ยมจะคืนค่า `undefined` เสมอสำหรับดัชนีที่เป็นลบ ตัวอย่างเช่น:

```js run
let str = `สวัสดี`;

alert( str[-2] ); // undefined
alert( str.at(-2) ); // ด
```

เราสามารถวนลูปผ่านอักขระโดยใช้ `for..of` ได้ด้วย:

```js run
for (let char of "สวัสดี") {
  alert(char); // ส,วั,ส,ดี,ี (char กลายเป็น "ส", แล้ว "วั", แล้ว "ส" และอื่นๆ)
}
```

## สตริงไม่สามารถเปลี่ยนแปลงได้

สตริงไม่สามารถเปลี่ยนแปลงได้ใน JavaScript เป็นไปไม่ได้ที่จะเปลี่ยนอักขระ

ลองดูตัวอย่างนี้เพื่อแสดงให้เห็นว่ามันไม่ทำงาน:

```js run
let str = 'สวัสดี';

str[0] = 'ห'; // เกิดข้อผิดพลาด
alert( str[0] ); // ไม่ทำงาน
```

วิธีแก้ปัญหาทั่วไปคือการสร้างสตริงใหม่ทั้งหมดและกำหนดให้กับ `str` แทนที่สตริงเดิม

ตัวอย่างเช่น:

```js run
let str = 'สวัสดี';

str = 'ห' + str[1] + str[2] + str[3] + str[4]; // แทนที่สตริง

alert( str ); // หวัสดี
```

ในหัวข้อต่อไปเราจะเห็นตัวอย่างเพิ่มเติมของการทำแบบนี้

## การเปลี่ยนตัวพิมพ์

เมธอด [toLowerCase()](mdn:js/String/toLowerCase) และ [toUpperCase()](mdn:js/String/toUpperCase) เปลี่ยนตัวพิมพ์:

```js run
alert( 'Interface'.toUpperCase() ); // INTERFACE
alert( 'Interface'.toLowerCase() ); // interface
```

หรือถ้าเราต้องการให้อักขระเดียวเป็นตัวพิมพ์เล็ก:

```js run
alert( 'Interface'[0].toLowerCase() ); // 'i'
```

## การค้นหาสตริงย่อย

มีหลายวิธีในการค้นหาสตริงย่อยภายในสตริง

### str.indexOf

วิธีแรกคือ [str.indexOf(substr, pos)](mdn:js/String/indexOf)

มันจะค้นหา `substr` ใน `str` โดยเริ่มจากตำแหน่ง `pos` ที่กำหนด และส่งคืนตำแหน่งที่พบการจับคู่หรือ `-1` ถ้าไม่พบ

ตัวอย่างเช่น:

```js run
let str = 'Widget with id';

alert( str.indexOf('Widget') ); // 0, เพราะ 'Widget' พบที่จุดเริ่มต้น
alert( str.indexOf('widget') ); // -1, ไม่พบ การค้นหานี้คำนึงถึงตัวพิมพ์ใหญ่-เล็ก

alert( str.indexOf("id") ); // 1, "id" พบที่ตำแหน่ง 1 (..idget with id)
```

พารามิเตอร์ที่สองเป็นตัวเลือก ช่วยให้เราเริ่มค้นหาจากตำแหน่งที่กำหนดได้

ตัวอย่างเช่น การปรากฏครั้งแรกของ `"id"` อยู่ที่ตำแหน่ง `1` ในการค้นหาการปรากฏครั้งถัดไป ให้เราเริ่มการค้นหาจากตำแหน่ง `2`:

```js run
let str = 'Widget with id';

alert( str.indexOf('id', 2) ) // 12
```

ถ้าเราสนใจทุกการปรากฏ เราสามารถเรียก `indexOf` ในลูปได้ ทุกการเรียกใหม่จะทำกับตำแหน่งหลังจากการจับคู่ก่อนหน้า:

```js run
let str = 'ฉลาดเหมือนสุนัขจิ้งจอก แข็งแรงเหมือนวัว';

let target = 'เหมือน'; // มาค้นหากัน

let pos = 0;
while (true) {
  let foundPos = str.indexOf(target, pos);
  if (foundPos == -1) break;

  alert( `พบที่ ${foundPos}` );
  pos = foundPos + 1; // ค้นหาต่อจากตำแหน่งถัดไป
}
```

อัลกอริทึมเดียวกันนี้สามารถเขียนให้สั้นลงได้:

```js run
let str = "ฉลาดเหมือนสุนัขจิ้งจอก แข็งแรงเหมือนวัว";
let target = "เหมือน";

*!*
let pos = -1;
while ((pos = str.indexOf(target, pos + 1)) != -1) {
  alert( pos );
}
*/!*
```

```smart header="`str.lastIndexOf(substr, position)`"
มีเมธอดที่คล้ายกันคือ [str.lastIndexOf(substr, position)](mdn:js/String/lastIndexOf) ที่ค้นหาจากท้ายสตริงไปยังจุดเริ่มต้น

มันจะแสดงรายการการปรากฏในลำดับย้อนกลับ
```

มีความไม่สะดวกเล็กน้อยกับ `indexOf` ในการทดสอบ `if` เราไม่สามารถใส่มันใน `if` แบบนี้ได้:

```js run
let str = "Widget with id";

if (str.indexOf("Widget")) {
    alert("เราพบมันแล้ว"); // ไม่ทำงาน!
}
```

`alert` ในตัวอย่างด้านบนไม่แสดงผลเพราะ `str.indexOf("Widget")` คืนค่า `0` (หมายความว่าพบการจับคู่ที่ตำแหน่งเริ่มต้น) ถูกต้อง แต่ `if` ถือว่า `0` เป็น `false`

ดังนั้น เราควรตรวจสอบ `-1` แบบนี้:

```js run
let str = "Widget with id";

*!*
if (str.indexOf("Widget") != -1) {
*/!*
    alert("เราพบมันแล้ว"); // ตอนนี้ทำงานแล้ว!
}
```

### includes, startsWith, endsWith

เมธอดที่ทันสมัยกว่าคือ [str.includes(substr, pos)](mdn:js/String/includes) ส่งคืน `true/false` ขึ้นอยู่กับว่า `str` มี `substr` อยู่หรือไม่

เป็นตัวเลือกที่เหมาะสมถ้าเราต้องการทดสอบการจับคู่ แต่ไม่ต้องการตำแหน่งของมัน:

```js run
alert( "Widget with id".includes("Widget") ); // true

alert( "สวัสดี".includes("ลาก่อน") ); // false
```

อาร์กิวเมนต์ที่สองของ `str.includes` เป็นตัวเลือก เป็นตำแหน่งที่จะเริ่มค้นหา:

```js run
alert( "Widget".includes("id") ); // true
alert( "Widget".includes("id", 3) ); // false, จากตำแหน่ง 3 ไม่มี "id"
```

เมธอด [str.startsWith](mdn:js/String/startsWith) และ [str.endsWith](mdn:js/String/endsWith) ทำตามชื่อของมันเลย:

```js run
alert( "*!*วิด*/!*เจ็ต".startsWith("วิด") ); // true, "วิดเจ็ต" เริ่มต้นด้วย "วิด"
alert( "วิด*!*เจ็ต*/!*".endsWith("เจ็ต") ); // true, "วิดเจ็ต" ลงท้ายด้วย "เจ็ต"
```

## การดึงสตริงย่อย

มี 3 เมธอดใน JavaScript สำหรับการดึงสตริงย่อย: `substring`, `substr` และ `slice`

`str.slice(start [, end])`
: ส่งคืนส่วนของสตริงจาก `start` ถึง (แต่ไม่รวม) `end`

    ตัวอย่างเช่น:

    ```js run
    let str = "stringify";
    alert( str.slice(0, 5) ); // 'strin', สตริงย่อยจาก 0 ถึง 5 (ไม่รวม 5)
    alert( str.slice(0, 1) ); // 's', จาก 0 ถึง 1 แต่ไม่รวม 1 ดังนั้นเป็นเพียงอักขระที่ 0
    ```

    ถ้าไม่มีอาร์กิวเมนต์ที่สอง `slice` จะไปจนถึงท้ายสตริง:

    ```js run
    let str = "st*!*ringify*/!*";
    alert( str.slice(2) ); // 'ringify', จากตำแหน่งที่ 2 จนถึงท้าย
    ```

    ค่าลบสำหรับ `start/end` ก็เป็นไปได้ หมายความว่าตำแหน่งจะถูกนับจากท้ายสตริง:

    ```js run
    let str = "strin*!*gif*/!*y";

    // เริ่มที่ตำแหน่งที่ 4 จากขวา จบที่ตำแหน่งที่ 1 จากขวา
    alert( str.slice(-4, -1) ); // 'gif'
    ```

`str.substring(start [, end])`
: ส่งคืนส่วนของสตริง*ระหว่าง* `start` และ `end` (ไม่รวม `end`)

    เกือบเหมือนกับ `slice` แต่อนุญาตให้ `start` มากกว่า `end` ได้ (ในกรณีนี้มันจะสลับค่า `start` และ `end`)

    ตัวอย่างเช่น:

    ```js run
    let str = "st*!*ring*/!*ify";

    // เหมือนกันสำหรับ substring
    alert( str.substring(2, 6) ); // "ring"
    alert( str.substring(6, 2) ); // "ring"

    // ...แต่ไม่เหมือนสำหรับ slice:
    alert( str.slice(2, 6) ); // "ring" (เหมือนกัน)
    alert( str.slice(6, 2) ); // "" (สตริงว่าง)

    ```

    อาร์กิวเมนต์ที่เป็นลบ (ไม่เหมือน slice) จะถูกปฏิบัติเสมือนเป็น `0`

`str.substr(start [, length])`
: ส่งคืนส่วนของสตริงจาก `start` โดยมีความยาวที่กำหนด

    ต่างจากเมธอดก่อนหน้า เมธอดนี้ช่วยให้เราระบุ `length` แทนตำแหน่งสิ้นสุดได้:

    ```js run
    let str = "st*!*ring*/!*ify";
    alert( str.substr(2, 4) ); // 'ring', จากตำแหน่งที่ 2 ดึง 4 อักขระ
    ```

    อาร์กิวเมนต์แรกอาจเป็นลบได้ เพื่อนับจากท้าย:

    ```js run
    let str = "strin*!*gi*/!*fy";
    alert( str.substr(-4, 2) ); // 'gi', จากตำแหน่งที่ 4 จากท้าย ดึง 2 อักขระ
    ```

    เมธอดนี้อยู่ใน [Annex B](https://tc39.es/ecma262/#sec-string.prototype.substr) ของข้อกำหนดภาษา หมายความว่ามีเพียงเครื่องมือจำลอง JavaScript ที่ทำงานบนเบราว์เซอร์เท่านั้นที่ควรสนับสนุนมัน และไม่แนะนำให้ใช้ ในทางปฏิบัติ มันได้รับการสนับสนุนทุกที่

มาสรุปเมธอดเหล่านี้เพื่อหลีกเลี่ยงความสับสน:

| เมธอด | เลือก... | ค่าลบ |
|--------|-----------|-----------|
| `slice(start, end)` | จาก `start` ถึง `end` (ไม่รวม `end`) | อนุญาตค่าลบ |
| `substring(start, end)` | ระหว่าง `start` และ `end` (ไม่รวม `end`) | ค่าลบหมายถึง `0` |
| `substr(start, length)` | จาก `start` ดึง `length` อักขระ | อนุญาต `start` เป็นลบ |

```smart header="เลือกตัวไหนดี?"
ทั้งหมดสามารถทำงานได้ อย่างเป็นทางการ `substr` มีข้อเสียเล็กน้อย: มันถูกอธิบายไว้ไม่ใช่ในข้อกำหนดหลักของ JavaScript แต่ใน Annex B ซึ่งครอบคลุมคุณลักษณะของเบราว์เซอร์เท่านั้นที่มีอยู่ส่วนใหญ่เพื่อเหตุผลทางประวัติศาสตร์ ดังนั้น สภาพแวดล้อมที่ไม่ใช่เบราว์เซอร์อาจล้มเหลวในการสนับสนุนมัน แต่ในทางปฏิบัติมันทำงานได้ทุกที่

จากสองตัวเลือกที่เหลือ `slice` มีความยืดหยุ่นมากกว่าเล็กน้อย เพราะอนุญาตให้ใช้อาร์กิวเมนต์ที่เป็นลบได้และสั้นกว่าในการเขียน

ดังนั้น สำหรับการใช้งานในทางปฏิบัติ การจำแค่ `slice` ก็เพียงพอแล้ว
```

## การเปรียบเทียบสตริง

ดังที่เราทราบจากบท <info:comparison> สตริงจะถูกเปรียบเทียบทีละอักขระตามลำดับตัวอักษร

อย่างไรก็ตาม มีความแปลกประหลาดบางอย่าง:

1. ตัวพิมพ์เล็กจะมากกว่าตัวพิมพ์ใหญ่เสมอ:

    ```js run
    alert( 'a' > 'Z' ); // true
    ```

2. ตัวอักษรที่มีเครื่องหมายกำกับจะ "ไม่เป็นไปตามลำดับ":

    ```js run
    alert( 'Österreich' > 'Zealand' ); // true
    ```

    สิ่งนี้อาจนำไปสู่ผลลัพธ์ที่แปลกประหลาดถ้าเราเรียงลำดับชื่อประเทศเหล่านี้ โดยปกติแล้วคนจะคาดหวังว่า `Zealand` จะอยู่หลัง `Österreich` ในรายการ

เพื่อเข้าใจว่าเกิดอะไรขึ้น เราควรตระหนักว่าสตริงใน JavaScript ถูกเข้ารหัสโดยใช้ [UTF-16](https://en.wikipedia.org/wiki/UTF-16) นั่นคือ: แต่ละอักขระมีรหัสตัวเลขที่สอดคล้องกัน

มีเมธอดพิเศษที่ช่วยให้เราได้อักขระจากรหัสและกลับกัน:

`str.codePointAt(pos)`
: ส่งคืนตัวเลขฐานสิบที่แสดงถึงรหัสสำหรับอักขระที่ตำแหน่ง `pos`:

    ```js run
    // ตัวอักษรที่มีตัวพิมพ์ต่างกันจะมีรหัสต่างกัน
    alert( "Z".codePointAt(0) ); // 90
    alert( "z".codePointAt(0) ); // 122
    alert( "z".codePointAt(0).toString(16) ); // 7a (ถ้าเราต้องการค่าฐานสิบหก)
    ```

`String.fromCodePoint(code)`
: สร้างอักขระโดยรหัสตัวเลข `code`

    ```js run
    alert( String.fromCodePoint(90) ); // Z
    alert( String.fromCodePoint(0x5a) ); // Z (เราสามารถใช้ค่าฐานสิบหกเป็นอาร์กิวเมนต์ได้ด้วย)
    ```

ตอนนี้มาดูอักขระที่มีรหัส `65..220` (ตัวอักษรละตินและเพิ่มเติมเล็กน้อย) โดยการสร้างสตริงจากพวกมัน:

```js run
let str = '';

for (let i = 65; i <= 220; i++) {
  str += String.fromCodePoint(i);
}
alert( str );
// ผลลัพธ์:
// ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
// ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜ
```

เห็นไหม? ตัวอักษรตัวพิมพ์ใหญ่มาก่อน จากนั้นก็มีอักขระพิเศษบางตัว แล้วตามด้วยตัวอักษรตัวพิมพ์เล็ก และ `Ö` อยู่ใกล้ท้ายของผลลัพธ์

ตอนนี้มันชัดเจนแล้วว่าทำไม `a > Z`

อักขระถูกเปรียบเทียบโดยรหัสตัวเลขของพวกมัน รหัสที่มากกว่าหมายความว่าอักขระนั้นมากกว่า รหัสสำหรับ `a` (97) มากกว่ารหัสสำหรับ `Z` (90)

- ตัวอักษรตัวพิมพ์เล็กทั้งหมดมาหลังตัวอักษรตัวพิมพ์ใหญ่เพราะรหัสของพวกมันมากกว่า
- ตัวอักษรบางตัวเช่น `Ö` แยกออกจากตัวอักษรหลัก ในที่นี้ รหัสของมันมากกว่าอะไรก็ตามจาก `a` ถึง `z`

### การเปรียบเทียบที่ถูกต้อง [#correct-comparisons]

อัลกอริทึม "ที่ถูกต้อง" ในการเปรียบเทียบสตริงนั้นซับซ้อนกว่าที่อาจดูเหมือน เพราะตัวอักษรแตกต่างกันสำหรับภาษาต่างๆ

ดังนั้น เบราว์เซอร์จำเป็นต้องรู้ภาษาเพื่อเปรียบเทียบ

โชคดีที่เบราว์เซอร์สมัยใหม่สนับสนุนมาตรฐานการทำให้เป็นสากล [ECMA-402](https://www.ecma-international.org/publications-and-standards/standards/ecma-402/)

มันให้เมธอดพิเศษสำหรับการเปรียบเทียบสตริงในภาษาต่างๆ ตามกฎของพวกมัน

การเรียก [str.localeCompare(str2)](mdn:js/String/localeCompare) ส่งคืนจำนวนเต็มที่บ่งบอกว่า `str` น้อยกว่า เท่ากับ หรือมากกว่า `str2` ตามกฎภาษา:

- ส่งคืนจำนวนติดลบถ้า `str` น้อยกว่า `str2`
- ส่งคืนจำนวนบวกถ้า `str` มากกว่า `str2`
- ส่งคืน `0` ถ้าพวกมันเท่ากัน

ตัวอย่างเช่น:

```js run
alert( 'Österreich'.localeCompare('Zealand') ); // -1
```

เมธอดนี้จริงๆ แล้วมีอาร์กิวเมนต์เพิ่มเติมอีกสองตัวที่ระบุใน [เอกสาร](mdn:js/String/localeCompare) ซึ่งช่วยให้ระบุภาษาได้ (โดยค่าเริ่มต้นจะใช้จากสภาพแวดล้อม ลำดับตัวอักษรขึ้นอยู่กับภาษา) และตั้งค่ากฎเพิ่มเติมเช่นการคำนึงถึงตัวพิมพ์ใหญ่-เล็กหรือควรปฏิบัติกับ `"a"` และ `"á"` เหมือนกันหรือไม่ เป็นต้น

## สรุป

- มีเครื่องหมายคำพูด 3 ประเภท Backticks ช่วยให้สตริงสามารถขึ้นหลายบรรทัดและแทรกนิพจน์ `${…}` ได้
- เราสามารถใช้อักขระพิเศษได้ เช่น การขึ้นบรรทัดใหม่ `\n`
- ในการรับอักขระ ใช้: `[]` หรือเมธอด `at`
- ในการรับสตริงย่อย ใช้: `slice` หรือ `substring`
- ในการทำให้สตริงเป็นตัวพิมพ์เล็ก/ใหญ่ ใช้: `toLowerCase/toUpperCase`
- ในการค้นหาสตริงย่อย ใช้: `indexOf` หรือ `includes/startsWith/endsWith` สำหรับการตรวจสอบอย่างง่าย
- ในการเปรียบเทียบสตริงตามภาษา ใช้: `localeCompare` มิฉะนั้นพวกมันจะถูกเปรียบเทียบตามรหัสอักขระ

มีเมธอดที่เป็นประโยชน์อื่นๆ อีกหลายตัวในสตริง:

- `str.trim()` -- ลบ ("ตัด") ช่องว่างจากจุดเริ่มต้นและจุดสิ้นสุดของสตริง
- `str.repeat(n)` -- ทำซ้ำสตริง `n` ครั้ง
- ...และอื่นๆ ที่สามารถพบได้ใน[คู่มือ](mdn:js/String)

สตริงยังมีเมธอดสำหรับการค้นหา/แทนที่ด้วยนิพจน์ทั่วไป (regular expressions) แต่นั่นเป็นหัวข้อใหญ่ ดังนั้นจึงอธิบายในส่วนบทเรียนแยกต่างหาก <info:regular-expressions>

นอกจากนี้ ณ ตอนนี้สิ่งสำคัญคือต้องทราบว่าสตริงอยู่บนพื้นฐานของการเข้ารหัส Unicode และดังนั้นจึงมีปัญหาเกี่ยวกับการเปรียบเทียบ มีข้อมูลเพิ่มเติมเกี่ยวกับ Unicode ในบท <info:unicode>