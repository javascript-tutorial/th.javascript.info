# สตริง (Strings)

ในภาษา JavaScript ข้อมูลที่เป็นตัวอักษรจะถูกเก็บไว้ในรูปแบบของสตริง ไม่มีประเภทข้อมูลแยกต่างหากสำหรับอักขระเดี่ยว

รูปแบบภายในของสตริงจะเป็น [UTF-16](https://en.wikipedia.org/wiki/UTF-16) เสมอ ไม่ได้ขึ้นอยู่กับการเข้ารหัสของหน้าเว็บ

## เครื่องหมายคำพูด

มาทบทวนประเภทของเครื่องหมายคำพูดกัน

สตริงสามารถอยู่ภายในเครื่องหมายคำพูดเดี่ยว เครื่องหมายคำพูดคู่ หรือเครื่องหมาย backticks ได้:

```js
let single = 'single-quoted';
let double = "double-quoted";

let backticks = `backticks`;
```

เครื่องหมายคำพูดเดี่ยวและคู่มีลักษณะการทำงานเหมือนกัน แต่เครื่องหมาย backticks ช่วยให้เราสามารถแทรกนิพจน์ (expression) ใดๆ ลงในสตริงได้ โดยครอบด้วย `${…}`:

```js run
function sum(a, b) {
  return a + b;
}

alert(`1 + 2 = ${sum(1, 2)}.`); // 1 + 2 = 3.
```

ข้อดีอีกอย่างของการใช้ backticks คือสามารถทำให้สตริงมีหลายบรรทัดได้:

```js run
let guestList = `รายชื่อแขก:
 * สมชาย
 * สมหญิง
 * สมศรี
`;

alert(guestList); // แสดงรายชื่อแขกหลายบรรทัด
```

ดูเป็นธรรมชาติใช่ไหมล่ะ? แต่เครื่องหมายคำพูดเดี่ยวหรือคู่ไม่สามารถทำแบบนี้ได้

ถ้าเราใช้เครื่องหมายคำพูดเดี่ยวหรือคู่และพยายามใช้หลายบรรทัด จะเกิดข้อผิดพลาด:

```js run
let guestList = "รายชื่อแขก: // Error: Unexpected token ILLEGAL
  * สมชาย";
```

เครื่องหมายคำพูดเดี่ยวและคู่มีมาตั้งแต่ยุคแรกๆ ของการสร้างภาษา ซึ่งตอนนั้นยังไม่ได้คำนึงถึงความต้องการในการใช้สตริงหลายบรรทัด ส่วน backticks เพิ่งมาในภายหลังจึงมีความสามารถที่หลากหลายกว่า

backticks ยังช่วยให้เราสามารถระบุ "ฟังก์ชันเทมเพลต" (template function) ก่อน backtick แรกได้ด้วย ไวยากรณ์คือ: <code>func&#96;string&#96;</code> ฟังก์ชัน `func` จะถูกเรียกโดยอัตโนมัติ รับสตริงและนิพจน์ที่แทรกเข้ามาและสามารถประมวลผลได้ คุณลักษณะนี้เรียกว่า "tagged templates" ซึ่งพบเห็นได้ไม่บ่อยนัก แต่คุณสามารถอ่านเพิ่มเติมได้ที่ MDN: [Template literals](mdn:/JavaScript/Reference/Template_literals#Tagged_templates)

## อักขระพิเศษ

ยังคงสามารถสร้างสตริงหลายบรรทัดด้วยเครื่องหมายคำพูดเดี่ยวและคู่ได้ โดยใช้ "อักขระขึ้นบรรทัดใหม่" (newline character) ซึ่งเขียนเป็น `\n` ที่แสดงถึงการขึ้นบรรทัดใหม่:

```js run
let guestList = "รายชื่อแขก:\n * สมชาย\n * สมหญิง\n * สมศรี";

alert(guestList); // แสดงรายชื่อแขกหลายบรรทัด เหมือนกับตัวอย่างก่อนหน้า
```

ตัวอย่างที่ง่ายกว่านี้ สองบรรทัดต่อไปนี้เท่ากัน แค่เขียนต่างกัน:

```js run
let str1 = "สวัสดี\nชาวโลก"; // สองบรรทัดโดยใช้ "สัญลักษณ์ขึ้นบรรทัดใหม่"

// สองบรรทัดโดยใช้การขึ้นบรรทัดปกติและ backticks
let str2 = `สวัสดี
ชาวโลก`;

alert(str1 == str2); // true
```

มีอักขระพิเศษอื่นๆ ที่พบได้น้อยกว่า:

| อักขระ | คำอธิบาย |
|-----------|-------------|
|`\n`|ขึ้นบรรทัดใหม่|
|`\r`|ในไฟล์ข้อความของ Windows การรวมกันของอักขระสองตัว `\r\n` แสดงถึงการขึ้นบรรทัดใหม่ ในขณะที่ระบบปฏิบัติการที่ไม่ใช่ Windows จะใช้แค่ `\n` นี่เป็นเพราะเหตุผลทางประวัติศาสตร์ ซอฟต์แวร์ Windows ส่วนใหญ่ก็เข้าใจ `\n` เช่นกัน |
|`\'`, `\"`, <code>\\`</code>|เครื่องหมายคำพูด|
|`\\`|แบ็คสแลช|
|`\t`|แท็บ|
|`\b`, `\f`, `\v`| Backspace, Form Feed, Vertical Tab -- กล่าวถึงเพื่อความครบถ้วน มาจากยุคเก่า ไม่ได้ใช้ในปัจจุบัน (คุณสามารถลืมมันไปได้เลย) |

ดังที่คุณเห็น อักขระพิเศษทั้งหมดเริ่มต้นด้วยเครื่องหมายแบ็คสแลช `\` ซึ่งเรียกว่า "อักขระหลบ" (escape character)

เนื่องจากมันพิเศษมาก ถ้าเราต้องการแสดงแบ็คสแลชจริงๆ `\` ในสตริง เราต้องเขียนมันสองครั้ง:

```js run
alert( `แบ็คสแลช: \\` ); // แบ็คสแลช: \
```

เครื่องหมายคำพูดที่ "หลบ" (escaped) `\'`, `\"`, <code>\\`</code> ใช้เพื่อแทรกเครื่องหมายคำพูดลงในสตริงที่ใช้เครื่องหมายคำพูดแบบเดียวกัน

ตัวอย่างเช่น:

```js run
alert( 'ฉัน*!*\'*/!*คือ วอลรัส!' ); // *!*ฉัน'*/!*คือ วอลรัส!
```

ดังที่คุณเห็น เราต้องนำเครื่องหมายแบ็คสแลช `\'` มาวางไว้หน้าเครื่องหมายคำพูดภายใน มิฉะนั้นมันจะบ่งบอกว่าเป็นจุดสิ้นสุดของสตริง

แน่นอนว่า เฉพาะเครื่องหมายคำพูดที่เหมือนกับเครื่องหมายที่ล้อมรอบเท่านั้นที่ต้องหลบ ดังนั้น วิธีที่สวยงามกว่าคือเปลี่ยนไปใช้เครื่องหมายคำพูดคู่หรือ backticks แทน:

```js run
alert( "ฉัน'คือ วอลรัส!" ); // ฉัน'คือ วอลรัส!
```

นอกเหนือจากอักขระพิเศษเหล่านี้ ยังมีสัญกรณ์พิเศษสำหรับรหัส Unicode `\u…` ซึ่งใช้ไม่บ่อยนักและอยู่ในบทเสริมเกี่ยวกับ [Unicode](info:unicode)

## ความยาวของสตริง

คุณสมบัติ `length` คือความยาวของสตริง:

```js run
alert( `สวัสดี\n`.length ); // 5
```

สังเกตว่า `\n` เป็น "อักขระพิเศษ" เดียว ดังนั้นความยาวจึงเป็น `5` จริงๆ

```warn header="`length` เป็นคุณสมบัติ"
ผู้ที่มีพื้นฐานจากภาษาอื่นบางครั้งอาจพิมพ์ผิดโดยเรียก `str.length()` แทนที่จะเป็นแค่ `str.length` ซึ่งไม่ทำงาน

โปรดทราบว่า `str.length` เป็นคุณสมบัติเชิงตัวเลข ไม่ใช่ฟังก์ชัน ไม่จำเป็นต้องเพิ่มวงเล็บหลังมัน ไม่ใช่ `.length()` แต่เป็น `.length`
```

## การเข้าถึงอักขระ

เพื่อเข้าถึงอักขระที่ตำแหน่ง `pos` ให้ใช้วงเล็บเหลี่ยม `[pos]` หรือเรียกเมธอด [str.at(pos)](mdn:js/String/at) อักขระแรกเริ่มจากตำแหน่งศูนย์:

```js run
let str = `สวัสดี`;

// อักขระแรก
alert( str[0] ); // ส
alert( str.at(0) ); // ส

// อักขระสุดท้าย
alert( str[str.length - 1] ); // ี
alert( str.at(-1) );
```

ดังที่คุณเห็น เมธอด `.at(pos)` มีข้อดีคือสามารถใช้ตำแหน่งเชิงลบได้ ถ้า `pos` เป็นลบ จะนับจากท้ายสตริง

ดังนั้น `.at(-1)` หมายถึงอักขระสุดท้าย และ `.at(-2)` คืออักขระก่อนหน้านั้น เป็นต้น

วงเล็บเหลี่ยมจะคืนค่า `undefined` เสมอสำหรับดัชนีที่เป็นลบ ตัวอย่างเช่น:

```js run
let str = `สวัสดี`;

alert( str[-2] ); // undefined
alert( str.at(-2) ); // ด
```

เราสามารถวนลูปผ่านอักขระโดยใช้ `for..of` ได้ด้วย:

```js run
for (let char of "สวัสดี") {
  alert(char); // ส,วั,ส,ดี,ี (char กลายเป็น "ส", แล้ว "วั", แล้ว "ส" และอื่นๆ)
}
```

## สตริงไม่สามารถเปลี่ยนแปลงได้

สตริงไม่สามารถเปลี่ยนแปลงได้ใน JavaScript เป็นไปไม่ได้ที่จะเปลี่ยนอักขระ

ลองดูตัวอย่างนี้เพื่อแสดงให้เห็นว่ามันไม่ทำงาน:

```js run
let str = 'สวัสดี';

str[0] = 'ห'; // เกิดข้อผิดพลาด
alert( str[0] ); // ไม่ทำงาน
```

วิธีแก้ปัญหาทั่วไปคือการสร้างสตริงใหม่ทั้งหมดและกำหนดให้กับ `str` แทนที่สตริงเดิม

ตัวอย่างเช่น:

```js run
let str = 'สวัสดี';

str = 'ห' + str[1] + str[2] + str[3] + str[4]; // แทนที่สตริง

alert( str ); // หวัสดี
```

ในหัวข้อต่อไปเราจะเห็นตัวอย่างเพิ่มเติมของการทำแบบนี้

## การเปลี่ยนตัวพิมพ์

เมธอด [toLowerCase()](mdn:js/String/toLowerCase) และ [toUpperCase()](mdn:js/String/toUpperCase) เปลี่ยนตัวพิมพ์:

```js run
alert( 'Interface'.toUpperCase() ); // INTERFACE
alert( 'Interface'.toLowerCase() ); // interface
```

หรือถ้าเราต้องการให้อักขระเดียวเป็นตัวพิมพ์เล็ก:

```js run
alert( 'Interface'[0].toLowerCase() ); // 'i'
```

## การค้นหาสตริงย่อย

มีหลายวิธีในการค้นหาสตริงย่อยภายในสตริง

### str.indexOf

วิธีแรกคือ [str.indexOf(substr, pos)](mdn:js/String/indexOf)

มันจะค้นหา `substr` ใน `str` โดยเริ่มจากตำแหน่ง `pos` ที่กำหนด และส่งคืนตำแหน่งที่พบการจับคู่หรือ `-1` ถ้าไม่พบ

ตัวอย่างเช่น:

```js run
let str = 'Widget with id';

alert( str.indexOf('Widget') ); // 0, เพราะ 'Widget' พบที่จุดเริ่มต้น
alert( str.indexOf('widget') ); // -1, ไม่พบ การค้นหานี้คำนึงถึงตัวพิมพ์ใหญ่-เล็ก

alert( str.indexOf("id") ); // 1, "id" พบที่ตำแหน่ง 1 (..idget with id)
```

พารามิเตอร์ที่สองเป็นตัวเลือก ช่วยให้เราเริ่มค้นหาจากตำแหน่งที่กำหนดได้

ตัวอย่างเช่น การปรากฏครั้งแรกของ `"id"` อยู่ที่ตำแหน่ง `1` ในการค้นหาการปรากฏครั้งถัดไป ให้เราเริ่มการค้นหาจากตำแหน่ง `2`:

```js run
let str = 'Widget with id';

alert( str.indexOf('id', 2) ) // 12
```

ถ้าเราสนใจทุกการปรากฏ เราสามารถเรียก `indexOf` ในลูปได้ ทุกการเรียกใหม่จะทำกับตำแหน่งหลังจากการจับคู่ก่อนหน้า:

```js run
let str = 'ฉลาดเหมือนสุนัขจิ้งจอก แข็งแรงเหมือนวัว';

let target = 'เหมือน'; // มาค้นหากัน

let pos = 0;
while (true) {
  let foundPos = str.indexOf(target, pos);
  if (foundPos == -1) break;

  alert( `พบที่ ${foundPos}` );
  pos = foundPos + 1; // ค้นหาต่อจากตำแหน่งถัดไป
}
```

อัลกอริทึมเดียวกันนี้สามารถเขียนให้สั้นลงได้:

```js run
let str = "ฉลาดเหมือนสุนัขจิ้งจอก แข็งแรงเหมือนวัว";
let target = "เหมือน";

*!*
let pos = -1;
while ((pos = str.indexOf(target, pos + 1)) != -1) {
  alert( pos );
}
*/!*
```

```smart header="`str.lastIndexOf(substr, position)`"
มีเมธอดที่คล้ายกันคือ [str.lastIndexOf(substr, position)](mdn:js/String/lastIndexOf) ที่ค้นหาจากท้ายสตริงไปยังจุดเริ่มต้น

มันจะแสดงรายการการปรากฏในลำดับย้อนกลับ
```

มีความไม่สะดวกเล็กน้อยกับ `indexOf` ในการทดสอบ `if` เราไม่สามารถใส่มันใน `if` แบบนี้ได้:

```js run
let str = "Widget with id";

if (str.indexOf("Widget")) {
    alert("เราพบมันแล้ว"); // ไม่ทำงาน!
}
```

`alert` ในตัวอย่างด้านบนไม่แสดงผลเพราะ `str.indexOf("Widget")` คืนค่า `0` (หมายความว่าพบการจับคู่ที่ตำแหน่งเริ่มต้น) ถูกต้อง แต่ `if` ถือว่า `0` เป็น `false`

ดังนั้น เราควรตรวจสอบ `-1` แบบนี้:

```js run
let str = "Widget with id";

*!*
if (str.indexOf("Widget") != -1) {
*/!*
    alert("เราพบมันแล้ว"); // ตอนนี้ทำงานแล้ว!
}
```

### includes, startsWith, endsWith

เมธอดที่ทันสมัยกว่าคือ [str.includes(substr, pos)](mdn:js/String/includes) ส่งคืน `true/false` ขึ้นอยู่กับว่า `str` มี `substr` อยู่หรือไม่

เป็นตัวเลือกที่เหมาะสมถ้าเราต้องการทดสอบการจับคู่ แต่ไม่ต้องการตำแหน่งของมัน:

```js run
alert( "Widget with id".includes("Widget") ); // true

alert( "สวัสดี".includes("ลาก่อน") ); // false
```

อาร์กิวเมนต์ที่สองของ `str.includes` เป็นตัวเลือก เป็นตำแหน่งที่จะเริ่มค้นหา:

```js run
alert( "Widget".includes("id") ); // true
alert( "Widget".includes("id", 3) ); // false, จากตำแหน่ง 3 ไม่มี "id"
```

เมธอด [str.startsWith](mdn:js/String/startsWith) และ [str.endsWith](mdn:js/String/endsWith) ทำตามชื่อของมันเลย:

```js run
alert( "*!*วิด*/!*เจ็ต".startsWith("วิด") ); // true, "วิดเจ็ต" เริ่มต้นด้วย "วิด"
alert( "วิด*!*เจ็ต*/!*".endsWith("เจ็ต") ); // true, "วิดเจ็ต" ลงท้ายด้วย "เจ็ต"
```

## การดึงสตริงย่อย

มี 3 เมธอดใน JavaScript สำหรับการดึงสตริงย่อย: `substring`, `substr` และ `slice`

`str.slice(start [, end])`
: ส่งคืนส่วนของสตริงจาก `start` ถึง (แต่ไม่รวม) `end`

    ตัวอย่างเช่น:

    ```js run
    let str = "stringify";
    alert( str.slice(0, 5) ); // 'strin', สตริงย่อยจาก 0 ถึง 5 (ไม่รวม 5)
    alert( str.slice(0, 1) ); // 's', จาก 0 ถึง 1 แต่ไม่รวม 1 ดังนั้นเป็นเพียงอักขระที่ 0
    ```

    ถ้าไม่มีอาร์กิวเมนต์ที่สอง `slice` จะไปจนถึงท้ายสตริง:

    ```js run
    let str = "st*!*ringify*/!*";
    alert( str.slice(2) ); // 'ringify', จากตำแหน่งที่ 2 จนถึงท้าย
    ```

    ค่าลบสำหรับ `start/end` ก็เป็นไปได้ หมายความว่าตำแหน่งจะถูกนับจากท้ายสตริง:

    ```js run
    let str = "strin*!*gif*/!*y";

    // เริ่มที่ตำแหน่งที่ 4 จากขวา จบที่ตำแหน่งที่ 1 จากขวา
    alert( str.slice(-4, -1) ); // 'gif'
    ```

`str.substring(start [, end])`
: ส่งคืนส่วนของสตริง*ระหว่าง* `start` และ `end` (ไม่รวม `end`)

    เกือบเหมือนกับ `slice` แต่อนุญาตให้ `start` มากกว่า `end` ได้ (ในกรณีนี้มันจะสลับค่า `start` และ `end`)

    ตัวอย่างเช่น:

    ```js run
    let str = "st*!*ring*/!*ify";

    // เหมือนกันสำหรับ substring
    alert( str.substring(2, 6) ); // "ring"
    alert( str.substring(6, 2) ); // "ring"

    // ...แต่ไม่เหมือนสำหรับ slice:
    alert( str.slice(2, 6) ); // "ring" (เหมือนกัน)
    alert( str.slice(6, 2) ); // "" (สตริงว่าง)

    ```

    อาร์กิวเมนต์ที่เป็นลบ (ไม่เหมือน slice) จะถูกปฏิบัติเสมือนเป็น `0`

`str.substr(start [, length])`
: ส่งคืนส่วนของสตริงจาก `start` โดยมีความยาวที่กำหนด

    ต่างจากเมธอดก่อนหน้า เมธอดนี้ช่วยให้เราระบุ `length` แทนตำแหน่งสิ้นสุดได้:

    ```js run
    let str = "st*!*ring*/!*ify";
    alert( str.substr(2, 4) ); // 'ring', จากตำแหน่งที่ 2 ดึง 4 อักขระ
    ```

    อาร์กิวเมนต์แรกอาจเป็นลบได้ เพื่อนับจากท้าย:

    ```js run
    let str = "strin*!*gi*/!*fy";
    alert( str.substr(-4, 2) ); // 'gi', จากตำแหน่งที่ 4 จากท้าย ดึง 2 อักขระ
    ```

    เมธอดนี้อยู่ใน [Annex B](https://tc39.es/ecma262/#sec-string.prototype.substr) ของข้อกำหนดภาษา หมายความว่ามีเพียงเครื่องมือจำลอง JavaScript ที่ทำงานบนเบราว์เซอร์เท่านั้นที่ควรสนับสนุนมัน และไม่แนะนำให้ใช้ ในทางปฏิบัติ มันได้รับการสนับสนุนทุกที่

มาสรุปเมธอดเหล่านี้เพื่อหลีกเลี่ยงความสับสน:

| เมธอด | เลือก... | ค่าลบ |
|--------|-----------|-----------|
| `slice(start, end)` | จาก `start` ถึง `end` (ไม่รวม `end`) | อนุญาตค่าลบ |
| `substring(start, end)` | ระหว่าง `start` และ `end` (ไม่รวม `end`) | ค่าลบหมายถึง `0` |
| `substr(start, length)` | จาก `start` ดึง `length` อักขระ | อนุญาต `start` เป็นลบ |

```smart header="เลือกตัวไหนดี?"
ทั้งหมดสามารถทำงานได้ อย่างเป็นทางการ `substr` มีข้อเสียเล็กน้อย: มันถูกอธิบายไว้ไม่ใช่ในข้อกำหนดหลักของ JavaScript แต่ใน Annex B ซึ่งครอบคลุมคุณลักษณะของเบราว์เซอร์เท่านั้นที่มีอยู่ส่วนใหญ่เพื่อเหตุผลทางประวัติศาสตร์ ดังนั้น สภาพแวดล้อมที่ไม่ใ